{
  HashMap<ByteArray,byte[]> entrySet=ServerTestUtils.createRandomKeyValuePairs(TEST_STREAM_KEYS_SIZE);
  List<Integer> fetchAndUpdatePartitionsList=Arrays.asList(0,2);
  int fetchPartitionKeyCount=0;
  Store<ByteArray,byte[],byte[]> store=getStore(0,testStoreName);
  for (  Entry<ByteArray,byte[]> entry : entrySet.entrySet()) {
    store.put(entry.getKey(),new Versioned<byte[]>(entry.getValue()),null);
    if (isKeyPartition(entry.getKey(),0,testStoreName,fetchAndUpdatePartitionsList)) {
      fetchPartitionKeyCount++;
    }
  }
  List<Integer> rebalancePartitionList=Arrays.asList(1,3);
  RebalancePartitionsInfo stealInfo=new RebalancePartitionsInfo(1,0,rebalancePartitionList,new ArrayList<Integer>(),rebalancePartitionList,Arrays.asList(testStoreName),0);
  try {
    adminClient.rebalanceNode(stealInfo);
    fail("Should have thrown an exception since the steal information is not on the server + not in rebalancing state");
  }
 catch (  VoldemortException e) {
  }
  getServer(1).getMetadataStore().put(MetadataStore.REBALANCING_STEAL_INFO,new RebalancerState(Lists.newArrayList(stealInfo)));
  try {
    adminClient.rebalanceNode(stealInfo);
    fail("Should have thrown an exception since not in rebalancing state");
  }
 catch (  VoldemortException e) {
  }
  getServer(1).getMetadataStore().put(MetadataStore.SERVER_STATE_KEY,MetadataStore.VoldemortState.REBALANCING_MASTER_SERVER);
  int asyncId=adminClient.rebalanceNode(stealInfo);
  assertNotSame("Got a valid rebalanceAsyncId",-1,asyncId);
  getAdminClient().waitForCompletion(1,asyncId,120,TimeUnit.SECONDS);
  store=getStore(1,testStoreName);
  for (  Entry<ByteArray,byte[]> entry : entrySet.entrySet()) {
    if (isKeyPartition(entry.getKey(),1,testStoreName,rebalancePartitionList)) {
      assertSame("entry should be present at store",1,store.get(entry.getKey(),null).size());
      assertEquals("entry value should match",new String(entry.getValue()),new String(store.get(entry.getKey(),null).get(0).getValue()));
    }
  }
}
