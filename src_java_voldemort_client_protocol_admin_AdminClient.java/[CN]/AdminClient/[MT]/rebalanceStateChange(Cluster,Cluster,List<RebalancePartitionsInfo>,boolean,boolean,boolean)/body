{
  HashMap<Integer,List<RebalancePartitionsInfo>> stealerNodeToPlan=groupPartitionsInfoByStealerNode(rebalancePartitionPlanList);
  Set<Integer> completedNodeIds=Sets.newHashSet();
  int nodeId=0;
  try {
    while (nodeId < transitionCluster.getNumberOfNodes()) {
      individualStateChange(nodeId,transitionCluster,stealerNodeToPlan.get(nodeId),swapRO,changeClusterMetadata,changeRebalanceState,stealerNodeToPlan.containsKey(nodeId),false);
      completedNodeIds.add(nodeId);
      nodeId++;
    }
  }
 catch (  Exception e) {
    logger.error("Got exceptions from node " + nodeId + " while changing state. Rolling back state on "+ completedNodeIds,e);
    for (    int completedNodeId : completedNodeIds) {
      try {
        individualStateChange(completedNodeId,existingCluster,stealerNodeToPlan.get(completedNodeId),swapRO,changeClusterMetadata,changeRebalanceState,stealerNodeToPlan.containsKey(completedNodeId),true);
      }
 catch (      Exception exception) {
        logger.error("Error while reverting back state change for completed node " + completedNodeIds,exception);
      }
    }
    throw new VoldemortRebalancingException("Got exceptions from node " + nodeId + " while changing state",Lists.newArrayList(e));
  }
}
