{
  HashMap<Integer,List<RebalancePartitionsInfo>> stealerNodeToPlan=groupPartitionsInfoByStealerNode(rebalancePartitionPlanList);
  Set<Integer> completedNodeIds=Sets.newHashSet();
  int nodeId=0;
  try {
    while (nodeId < transitionCluster.getNumberOfNodes()) {
      individualStateChange(nodeId,transitionCluster,stealerNodeToPlan.get(nodeId),swapRO,changeClusterMetadata,changeRebalanceState,false);
      completedNodeIds.add(nodeId);
      nodeId++;
    }
  }
 catch (  Exception e) {
    if (rollback) {
      logger.error("Got exceptions from node " + nodeId + " while changing state. Rolling back state on "+ completedNodeIds);
      for (      int completedNodeId : completedNodeIds) {
        try {
          individualStateChange(completedNodeId,existingCluster,stealerNodeToPlan.get(completedNodeId),swapRO,changeClusterMetadata,changeRebalanceState,true);
        }
 catch (        Exception exception) {
          logger.error("Error while reverting back state change for completed node " + completedNodeIds,exception);
        }
      }
    }
 else {
      logger.error("Got exceptions from node " + nodeId + " while changing state");
    }
    throw new VoldemortRebalancingException("Got exceptions from node " + nodeId + " while changing state",Lists.newArrayList(e));
  }
}
