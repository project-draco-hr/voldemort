{
  Map<Integer,Integer> partitionToNodeId=RebalanceUtils.getCurrentPartitionMapping(cluster);
  Map<Integer,HashMap<Integer,List<Integer>>> returnMap=Maps.newHashMap();
  RoutingStrategy strategy=new RoutingStrategyFactory().updateRoutingStrategy(storeDef,cluster);
  List<Integer> restoringNodePartition=cluster.getNodeById(restoringNode).getPartitionIds();
  for (  Node node : cluster.getNodes()) {
    for (    int partitionId : node.getPartitionIds()) {
      List<Integer> replicatingPartitions=strategy.getReplicatingPartitionList(partitionId);
      List<Integer> extraCopyReplicatingPartitions=Lists.newArrayList(replicatingPartitions);
      if (replicatingPartitions.size() <= 1) {
        throw new VoldemortException("Store " + storeDef.getName() + " cannot be restored from replica because replication factor = 1");
      }
      if (replicatingPartitions.removeAll(restoringNodePartition)) {
        if (replicatingPartitions.size() == 0) {
          throw new VoldemortException("Found a case where-in the overlap of " + "the node partition list results in no replicas " + "being left in replicating list");
        }
        int replicaType=extraCopyReplicatingPartitions.indexOf(replicatingPartitions.get(0));
        int partition=extraCopyReplicatingPartitions.get(0);
        int nodeId=partitionToNodeId.get(replicatingPartitions.get(0));
        HashMap<Integer,List<Integer>> replicaToPartitionList=null;
        if (returnMap.containsKey(nodeId)) {
          replicaToPartitionList=returnMap.get(nodeId);
        }
 else {
          replicaToPartitionList=Maps.newHashMap();
          returnMap.put(nodeId,replicaToPartitionList);
        }
        List<Integer> partitions=null;
        if (replicaToPartitionList.containsKey(replicaType)) {
          partitions=replicaToPartitionList.get(replicaType);
        }
 else {
          partitions=Lists.newArrayList();
          replicaToPartitionList.put(replicaType,partitions);
        }
        partitions.add(partition);
      }
    }
  }
  return returnMap;
}
