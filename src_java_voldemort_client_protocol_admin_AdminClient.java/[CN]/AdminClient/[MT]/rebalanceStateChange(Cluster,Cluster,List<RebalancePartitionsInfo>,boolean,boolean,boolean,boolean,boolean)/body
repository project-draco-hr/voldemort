{
  HashMap<Integer,List<RebalancePartitionsInfo>> stealerNodeToPlan=RebalanceUtils.groupPartitionsInfoByNode(rebalancePartitionPlanList,true);
  Set<Integer> completedNodeIds=Sets.newHashSet();
  int nodeId=0;
  HashMap<Integer,Exception> exceptions=Maps.newHashMap();
  try {
    while (nodeId < transitionCluster.getNumberOfNodes()) {
      try {
        individualStateChange(nodeId,transitionCluster,stealerNodeToPlan.get(nodeId),swapRO,changeClusterMetadata,changeRebalanceState,false);
        completedNodeIds.add(nodeId);
      }
 catch (      Exception e) {
        exceptions.put(nodeId,e);
        if (failEarly) {
          throw e;
        }
      }
      nodeId++;
    }
    if (exceptions.size() > 0) {
      throw new VoldemortRebalancingException("Got exceptions from nodes " + exceptions.keySet());
    }
    if (changeClusterMetadata) {
      try {
        updateMetadataversion(CLUSTER_VERSION_KEY);
      }
 catch (      Exception e) {
        logger.info("Exception occurred while setting cluster metadata version during Rebalance state change !!!");
      }
    }
  }
 catch (  Exception e) {
    if (rollback) {
      logger.error("Got exceptions from nodes " + exceptions.keySet() + " while changing state. Rolling back state on "+ completedNodeIds);
      for (      int completedNodeId : completedNodeIds) {
        try {
          individualStateChange(completedNodeId,existingCluster,stealerNodeToPlan.get(completedNodeId),swapRO,changeClusterMetadata,changeRebalanceState,true);
        }
 catch (        Exception exception) {
          logger.error("Error while reverting back state change for completed node " + completedNodeId,exception);
        }
      }
    }
 else {
      logger.error("Got exceptions from nodes " + exceptions.keySet() + " while changing state");
    }
    throw new VoldemortRebalancingException("Got exceptions from nodes " + exceptions.keySet() + " while changing state",Lists.newArrayList(exceptions.values()));
  }
}
