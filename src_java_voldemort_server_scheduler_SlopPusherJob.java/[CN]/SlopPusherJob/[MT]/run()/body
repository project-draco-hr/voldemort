{
  logger.debug("Pushing slop...");
  int numNodes=cluster.getNumberOfNodes();
  Map<Integer,Long> attemptedByNode=Maps.newHashMapWithExpectedSize(numNodes);
  for (int i=0; i < numNodes; i++)   attemptedByNode.put(i,0L);
  Map<Integer,Long> succeededByNode=Maps.newHashMapWithExpectedSize(numNodes);
  for (int i=0; i < numNodes; i++)   succeededByNode.put(i,0L);
  long slopsPushed=0L;
  long attemptedPushes=0L;
  ClosableIterator<Pair<ByteArray,Versioned<Slop>>> iterator=null;
  SlopStorageEngine slopStorageEngine=storeRepo.getSlopStore();
  try {
    StorageEngine<ByteArray,Slop,byte[]> slopStore=slopStorageEngine.asSlopStore();
    EventThrottler throttler=new EventThrottler(maxWriteBytesPerSec);
    iterator=slopStore.entries();
    while (iterator.hasNext()) {
      if (Thread.interrupted())       throw new InterruptedException("Task cancelled!");
      attemptedPushes++;
      if (attemptedPushes % 1000 == 0)       logger.info("Attempted pushing " + attemptedPushes + " slops");
      try {
        Pair<ByteArray,Versioned<Slop>> keyAndVal=iterator.next();
        Versioned<Slop> versioned=keyAndVal.getSecond();
        Slop slop=versioned.getValue();
        int nodeId=slop.getNodeId();
        Node node=cluster.getNodeById(nodeId);
        Long attempted=attemptedByNode.get(nodeId);
        if (attempted == null)         attempted=0L;
        attemptedByNode.put(nodeId,attempted);
        if (failureDetector.isAvailable(node)) {
          Store<ByteArray,byte[],byte[]> store=storeRepo.getNodeStore(slop.getStoreName(),node.getId());
          Long startNs=System.nanoTime();
          try {
            int nBytes=slop.getKey().length();
            if (slop.getOperation() == Operation.PUT) {
              store.put(slop.getKey(),new Versioned<byte[]>(slop.getValue(),versioned.getVersion()),slop.getTransforms());
              nBytes+=slop.getValue().length + ((VectorClock)versioned.getVersion()).sizeInBytes() + 1;
            }
 else             if (slop.getOperation() == Operation.DELETE) {
              nBytes+=((VectorClock)versioned.getVersion()).sizeInBytes() + 1;
              store.delete(slop.getKey(),versioned.getVersion());
            }
 else {
              logger.error("Unknown slop operation: " + slop.getOperation());
              continue;
            }
            failureDetector.recordSuccess(node,deltaMs(startNs));
            slopStore.delete(slop.makeKey(),versioned.getVersion());
            slopsPushed++;
            Long succeeded=succeededByNode.get(nodeId);
            if (succeeded == null) {
              succeeded=0L;
            }
            succeededByNode.put(nodeId,succeeded + 1L);
            throttler.maybeThrottle(nBytes);
          }
 catch (          ObsoleteVersionException e) {
            slopStore.delete(slop.makeKey(),versioned.getVersion());
          }
catch (          UnreachableStoreException e) {
            failureDetector.recordException(node,deltaMs(startNs),e);
          }
        }
      }
 catch (      Exception e) {
        logger.error(e,e);
      }
    }
  }
 catch (  Exception e) {
    logger.error(e,e);
  }
 finally {
    try {
      if (iterator != null)       iterator.close();
    }
 catch (    Exception e) {
      logger.error("Failed to close iterator.",e);
    }
  }
  logger.log(attemptedPushes > 0 ? Level.INFO : Level.DEBUG,"Attempted " + attemptedPushes + " hinted handoff pushes of which "+ slopsPushed+ " succeeded.");
  Map<Integer,Long> outstanding=Maps.newHashMapWithExpectedSize(numNodes);
  for (  int i : succeededByNode.keySet())   outstanding.put(i,attemptedByNode.get(i) - succeededByNode.get(i));
  slopStorageEngine.resetStats(outstanding);
}
