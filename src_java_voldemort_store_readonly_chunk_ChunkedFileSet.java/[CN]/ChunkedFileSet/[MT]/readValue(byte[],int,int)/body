{
  FileChannel dataFile=dataFileFor(chunk);
  try {
switch (storageFormat) {
case READONLY_V0:
case READONLY_V1:
{
        ByteBuffer sizeBuffer=ByteBuffer.allocate(ByteUtils.SIZE_OF_INT);
        dataFile.read(sizeBuffer,valueLocation);
        int valueSize=sizeBuffer.getInt(0);
        ByteBuffer valueBuffer=ByteBuffer.allocate(valueSize);
        dataFile.read(valueBuffer,valueLocation + ByteUtils.SIZE_OF_INT);
        return valueBuffer.array();
      }
case READONLY_V2:
{
      ByteBuffer numKeyValsBuffer=ByteBuffer.allocate(ByteUtils.SIZE_OF_BYTE);
      dataFile.read(numKeyValsBuffer,valueLocation);
      int numKeyVal=numKeyValsBuffer.get(0) & ByteUtils.MASK_11111111;
      int currentPosition=valueLocation + ByteUtils.SIZE_OF_BYTE;
      for (int keyId=0; keyId < numKeyVal; keyId++) {
        ByteBuffer sizeBuffer=ByteBuffer.allocate(2 * ByteUtils.SIZE_OF_INT);
        dataFile.read(sizeBuffer,currentPosition);
        int keySize=sizeBuffer.getInt(0);
        int valueSize=sizeBuffer.getInt(ByteUtils.SIZE_OF_INT);
        ByteBuffer keyBuffer=ByteBuffer.allocate(keySize);
        dataFile.read(keyBuffer,currentPosition + (2 * ByteUtils.SIZE_OF_INT));
        if (ByteUtils.compare(keyBuffer.array(),key) == 0) {
          ByteBuffer valueBuffer=ByteBuffer.allocate(valueSize);
          dataFile.read(valueBuffer,currentPosition + (2 * ByteUtils.SIZE_OF_INT) + keySize);
          return valueBuffer.array();
        }
 else {
          currentPosition+=(2 * ByteUtils.SIZE_OF_INT) + keySize + valueSize;
        }
      }
      return new byte[0];
    }
default :
{
    throw new VoldemortException("Storage format not supported ");
  }
}
}
 catch (IOException e) {
throw new VoldemortException(e);
}
}
