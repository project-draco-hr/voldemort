{
  this.indexFileStream.write(key.get(),0,key.getSize());
  this.indexFileStream.writeInt(this.position);
  if (this.checkSumDigestIndex != null) {
    this.checkSumDigestIndex.update(key.get(),0,key.getSize());
    this.checkSumDigestIndex.update(this.position);
  }
  int numKeyValues=0;
  ByteArrayOutputStream valueStream=new ByteArrayOutputStream();
  while (iterator.hasNext()) {
    BytesWritable writable=iterator.next();
    byte[] valueBytes=writable.get();
    if (this.nodeId == -1)     this.nodeId=ByteUtils.readInt(valueBytes,0);
    if (this.partitionId == -1)     this.partitionId=ByteUtils.readInt(valueBytes,4);
    if (this.chunkId == -1)     this.chunkId=ReadOnlyUtils.chunk(key.get(),this.numChunks);
    int valueLength=writable.getSize() - 8;
    if (saveKeys) {
      valueStream.write(valueBytes,8,valueLength);
    }
 else {
      valueStream.write(valueLength);
      valueStream.write(valueBytes,8,valueLength);
    }
    numKeyValues++;
    if (!saveKeys && numKeyValues > 1)     throw new VoldemortException("Duplicate keys detected for md5 sum " + ByteUtils.toHexString(ByteUtils.copy(key.get(),0,key.getSize())));
  }
  if (saveKeys) {
    this.valueFileStream.writeByte(numKeyValues);
    this.position+=1;
  }
  this.valueFileStream.write(valueStream.toByteArray());
  this.position+=valueStream.size();
  if (this.checkSumDigestValue != null) {
    this.checkSumDigestValue.update(valueStream.toByteArray());
  }
  if (this.position < 0)   throw new VoldemortException("Chunk overflow exception: chunk " + chunkId + " has exceeded "+ Integer.MAX_VALUE+ " bytes.");
}
