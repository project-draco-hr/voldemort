{
  int chunkId=ReadOnlyUtils.chunk(key.get(),getNumChunks());
  this.indexFileStream[chunkId].write(key.get(),0,key.getSize());
  this.indexFileStream[chunkId].writeInt(this.position[chunkId]);
  if (this.checkSumDigestIndex[chunkId] != null) {
    this.checkSumDigestIndex[chunkId].update(key.get(),0,key.getSize());
    this.checkSumDigestIndex[chunkId].update(this.position[chunkId]);
  }
  int numKeyValues=0;
  ByteArrayOutputStream stream=new ByteArrayOutputStream();
  DataOutputStream valueStream=new DataOutputStream(stream);
  while (iterator.hasNext()) {
    BytesWritable writable=iterator.next();
    byte[] valueBytes=writable.get();
    int offsetTillNow=0;
    if (this.nodeId == -1)     this.nodeId=ByteUtils.readInt(valueBytes,offsetTillNow);
    offsetTillNow+=ByteUtils.SIZE_OF_INT;
    if (this.partitionId == -1)     this.partitionId=ByteUtils.readInt(valueBytes,offsetTillNow);
    offsetTillNow+=ByteUtils.SIZE_OF_INT;
    if (getSaveKeys()) {
      if (this.replicaType == -1)       this.replicaType=(int)ByteUtils.readBytes(valueBytes,offsetTillNow,ByteUtils.SIZE_OF_BYTE);
      offsetTillNow+=ByteUtils.SIZE_OF_BYTE;
    }
    int valueLength=writable.getSize() - offsetTillNow;
    if (getSaveKeys()) {
      valueStream.write(valueBytes,offsetTillNow,valueLength);
    }
 else {
      valueStream.writeInt(valueLength);
      valueStream.write(valueBytes,offsetTillNow,valueLength);
    }
    numKeyValues++;
    if (!getSaveKeys() && numKeyValues > 1)     throw new VoldemortException("Duplicate keys detected for md5 sum " + ByteUtils.toHexString(ByteUtils.copy(key.get(),0,key.getSize())));
  }
  if (numKeyValues > 1) {
    reporter.incrCounter(CollisionCounter.NUM_COLLISIONS,1);
    long numCollisions=reporter.getCounter(CollisionCounter.MAX_COLLISIONS).getCounter();
    if (numKeyValues > numCollisions) {
      reporter.incrCounter(CollisionCounter.MAX_COLLISIONS,numKeyValues - numCollisions);
    }
  }
  if (getSaveKeys()) {
    byte[] numBuf=new byte[ByteUtils.SIZE_OF_BYTE];
    ByteUtils.writeBytes(numBuf,numKeyValues,0,ByteUtils.SIZE_OF_BYTE);
    this.valueFileStream[chunkId].write(numBuf);
    this.position[chunkId]+=ByteUtils.SIZE_OF_BYTE;
    if (this.checkSumDigestValue[chunkId] != null) {
      this.checkSumDigestValue[chunkId].update(numBuf);
    }
  }
  valueStream.flush();
  byte[] value=stream.toByteArray();
  this.valueFileStream[chunkId].write(value);
  this.position[chunkId]+=value.length;
  if (this.checkSumDigestValue[chunkId] != null) {
    this.checkSumDigestValue[chunkId].update(value);
  }
  if (this.position[chunkId] < 0)   throw new VoldemortException("Chunk overflow exception: chunk " + chunkId + " has exceeded "+ Integer.MAX_VALUE+ " bytes.");
}
