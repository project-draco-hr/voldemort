{
  BytesWritable writable=values.next();
  byte[] valueBytes=writable.get();
  if (this.nodeId == -1)   this.nodeId=ByteUtils.readInt(valueBytes,0);
  if (this.partitionId == -1)   this.partitionId=ByteUtils.readInt(valueBytes,4);
  if (this.chunkId == -1)   this.chunkId=ReadOnlyUtils.chunk(key.get(),this.numChunks);
  this.indexFileStream.write(key.get(),0,key.getSize());
  this.indexFileStream.writeInt(this.position);
  if (this.checkSumDigestIndex != null) {
    this.checkSumDigestIndex.update(key.get(),0,key.getSize());
    this.checkSumDigestIndex.update(this.position);
  }
  int valueLength=writable.getSize() - 4;
  this.valueFileStream.writeInt(valueLength);
  this.valueFileStream.write(valueBytes,4,valueLength);
  if (this.checkSumDigestValue != null) {
    this.checkSumDigestValue.update(valueLength);
    this.checkSumDigestValue.update(valueBytes,4,valueLength);
  }
  this.position+=4 + valueLength;
  if (this.position < 0)   throw new VoldemortException("Chunk overflow exception: chunk " + chunkId + " has exceeded "+ Integer.MAX_VALUE+ " bytes.");
  if (values.hasNext())   throw new VoldemortException("Duplicate keys detected for md5 sum " + ByteUtils.toHexString(ByteUtils.copy(key.get(),0,key.getSize())));
}
