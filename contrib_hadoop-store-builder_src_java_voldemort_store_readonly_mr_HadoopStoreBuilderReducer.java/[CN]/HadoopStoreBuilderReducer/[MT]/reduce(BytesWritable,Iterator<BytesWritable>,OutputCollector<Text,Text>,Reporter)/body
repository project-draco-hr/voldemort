{
  this.indexFileStream.write(key.get(),0,key.getSize());
  this.indexFileStream.writeInt(this.position);
  if (this.checkSumDigestIndex != null) {
    this.checkSumDigestIndex.update(key.get(),0,key.getSize());
    this.checkSumDigestIndex.update(this.position);
  }
  int numKeyValues=0;
  ByteArrayOutputStream stream=new ByteArrayOutputStream();
  DataOutputStream valueStream=new DataOutputStream(stream);
  while (iterator.hasNext()) {
    BytesWritable writable=iterator.next();
    byte[] valueBytes=writable.get();
    int offsetTillNow=0;
    if (this.nodeId == -1)     this.nodeId=ByteUtils.readInt(valueBytes,offsetTillNow);
    offsetTillNow+=ByteUtils.SIZE_OF_INT;
    if (this.partitionId == -1)     this.partitionId=ByteUtils.readInt(valueBytes,offsetTillNow);
    offsetTillNow+=ByteUtils.SIZE_OF_INT;
    if (this.chunkId == -1)     this.chunkId=ReadOnlyUtils.chunk(key.get(),getNumChunks());
    if (getSaveKeys()) {
      if (this.replicaType == -1)       this.replicaType=(int)ByteUtils.readBytes(valueBytes,offsetTillNow,ByteUtils.SIZE_OF_BYTE);
      offsetTillNow+=ByteUtils.SIZE_OF_BYTE;
      if (this.previousDir.length() != 0 && previousIterator == null) {
        DataFileChunkSet dataFileChunkSet=HadoopStoreBuilderUtils.getDataFileChunkSet(this.fs,HadoopStoreBuilderUtils.getDataChunkFiles(this.fs,new Path(previousDir),this.partitionId,this.replicaType,this.chunkId));
        previousIterator=new ROCollidedEntriesIterator(dataFileChunkSet);
      }
    }
    int valueLength=writable.getSize() - offsetTillNow;
    if (getSaveKeys()) {
      valueStream.write(valueBytes,offsetTillNow,valueLength);
    }
 else {
      valueStream.writeInt(valueLength);
      valueStream.write(valueBytes,offsetTillNow,valueLength);
    }
    numKeyValues++;
    if (!getSaveKeys() && numKeyValues > 1)     throw new VoldemortException("Duplicate keys detected for md5 sum " + ByteUtils.toHexString(ByteUtils.copy(key.get(),0,key.getSize())));
  }
  if (numKeyValues > 1) {
    reporter.incrCounter(CollisionCounter.NUM_COLLISIONS,1);
    long numCollisions=reporter.getCounter(CollisionCounter.MAX_COLLISIONS).getCounter();
    if (numKeyValues > numCollisions) {
      reporter.incrCounter(CollisionCounter.MAX_COLLISIONS,numKeyValues - numCollisions);
    }
  }
  valueStream.flush();
  byte[] value=stream.toByteArray();
  if (this.previousDir.length() != 0 && getSaveKeys()) {
    byte[] numBuf=new byte[ByteUtils.SIZE_OF_BYTE];
    ByteUtils.writeBytes(numBuf,numKeyValues,0,ByteUtils.SIZE_OF_BYTE);
    boolean retry=false;
    do {
      retry=false;
      if (previousElement == null && !previousIterator.hasNext()) {
        patch(ByteUtils.cat(numBuf,value),0);
      }
 else {
        if (previousElement == null)         previousElement=previousIterator.next();
switch (ByteUtils.compare(previousElement.getFirst().array(),key.get())) {
case -1:
          patch(previousElement.getSecond().array(),1);
        if (previousIterator.hasNext()) {
          previousElement=previousIterator.next();
        }
 else {
          previousElement=null;
        }
      retry=true;
    break;
case 1:
  patch(ByteUtils.cat(numBuf,value),0);
break;
case 0:
if (ByteUtils.compare(previousElement.getSecond().array(),ByteUtils.cat(numBuf,value)) != 0) {
patch(previousElement.getSecond().array(),1);
patch(ByteUtils.cat(numBuf,value),0);
}
if (previousIterator.hasNext()) previousElement=previousIterator.next();
 else previousElement=null;
break;
default :
throw new VoldemortException("Comparison of key throw an exception");
}
}
}
 while (retry);
this.position+=value.length + ByteUtils.SIZE_OF_BYTE;
}
 else {
if (getSaveKeys()) {
byte[] numBuf=new byte[ByteUtils.SIZE_OF_BYTE];
ByteUtils.writeBytes(numBuf,numKeyValues,0,ByteUtils.SIZE_OF_BYTE);
this.valueFileStream.write(numBuf);
this.position+=ByteUtils.SIZE_OF_BYTE;
if (this.checkSumDigestValue != null) {
this.checkSumDigestValue.update(numBuf);
}
}
this.valueFileStream.write(value);
this.position+=value.length;
if (this.checkSumDigestValue != null) {
this.checkSumDigestValue.update(value);
}
}
if (this.position < 0) throw new VoldemortException("Chunk overflow exception: chunk " + chunkId + " has exceeded "+ Integer.MAX_VALUE+ " bytes.");
}
