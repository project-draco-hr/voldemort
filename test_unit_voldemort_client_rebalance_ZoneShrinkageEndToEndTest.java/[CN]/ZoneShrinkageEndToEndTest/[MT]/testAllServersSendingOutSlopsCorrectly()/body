{
  final Serializer<ByteArray> slopKeySerializer=new ByteArraySerializer();
  final Serializer<Slop> slopValueSerializer=new SlopSerializer();
  final SlopSerializer slopSerializer=new SlopSerializer();
  StoreDefinition storeDef=storeDefs.get(0);
  SocketStoreFactoryForTest ssf=new SocketStoreFactoryForTest();
  Map<Integer,SocketStore> slopStoresCreatedBeforeShrink=new HashMap<Integer,SocketStore>();
  Map<Integer,SocketStore> slopStoresCreatedAfterShrink=new HashMap<Integer,SocketStore>();
  Map<Integer,List<Pair<ByteArray,Integer>>> serverKeys=new HashMap<Integer,List<Pair<ByteArray,Integer>>>();
  for (  Node slopFinalDestinationNode : cluster.getNodes()) {
    serverKeys.put(slopFinalDestinationNode.getId(),new ArrayList<Pair<ByteArray,Integer>>());
  }
  for (  Integer nodeId : vservers.keySet()) {
    SocketStore slopStore=ssf.createSocketStore(vservers.get(nodeId).getIdentityNode(),"slop");
    SerializingStore.wrap(slopStore,slopKeySerializer,slopValueSerializer,new IdentitySerializer());
    slopStoresCreatedBeforeShrink.put(nodeId,slopStore);
  }
  for (int i=0; i < 2; i++) {
    for (    Integer slopHostId : vservers.keySet()) {
      SocketStore slopStore=slopStoresCreatedBeforeShrink.get(slopHostId);
      for (      Integer destinationNodeId : vservers.keySet()) {
        if (!destinationNodeId.equals(slopHostId)) {
          ByteArray key=generateRandomKey(cluster,destinationNodeId,storeDef.getReplicationFactor());
          serverKeys.get(destinationNodeId).add(new Pair<ByteArray,Integer>(key,slopHostId));
          Slop slop=new Slop(storeDef.getName(),Slop.Operation.PUT,key.get(),key.get(),destinationNodeId,new Date());
          slopStore.put(slop.makeKey(),new Versioned<byte[]>(slopSerializer.toBytes(slop),new VectorClock()),null);
        }
      }
    }
  }
  executeShrinkZone();
  System.out.println("-------------------------------");
  System.out.println("    CONNECTING SLOP STORES     ");
  System.out.println("-------------------------------");
  for (  Integer nodeId : vservers.keySet()) {
    SocketStore slopStore=ssf.createSocketStore(vservers.get(nodeId).getIdentityNode(),"slop");
    SerializingStore.wrap(slopStore,slopKeySerializer,slopValueSerializer,new IdentitySerializer());
    slopStoresCreatedAfterShrink.put(nodeId,slopStore);
  }
  System.out.println("-------------------------------");
  System.out.println("     CONNECTED SLOP STORES     ");
  System.out.println("-------------------------------");
  System.out.println("-------------------------------");
  System.out.println("         SENDING SLOPS         ");
  System.out.println("-------------------------------");
  for (int i=0; i < 2; i++) {
    for (    Integer slopHostId : vservers.keySet()) {
      SocketStore slopStore=slopStoresCreatedAfterShrink.get(slopHostId);
      for (      Integer destinationNodeId : vservers.keySet()) {
        if (!destinationNodeId.equals(slopHostId)) {
          ByteArray key=generateRandomKey(cluster,destinationNodeId,storeDef.getReplicationFactor());
          serverKeys.get(destinationNodeId).add(new Pair<ByteArray,Integer>(key,slopHostId));
          Slop slop=new Slop(storeDef.getName(),Slop.Operation.PUT,key.get(),key.get(),destinationNodeId,new Date());
          slopStore.put(slop.makeKey(),new Versioned<byte[]>(slopSerializer.toBytes(slop),new VectorClock()),null);
        }
      }
    }
  }
  System.out.println("-------------------------------");
  System.out.println("           SENT SLOPS          ");
  System.out.println("-------------------------------");
  System.out.println("-------------------------------");
  System.out.println("  WAITING FOR SLOPS TO DRAIN   ");
  System.out.println("-------------------------------");
  long slopDrainTimoutMs=30000L;
  long timeStart=System.currentTimeMillis();
  boolean allSlopsEmpty=false;
  while (System.currentTimeMillis() < timeStart + slopDrainTimoutMs) {
    allSlopsEmpty=true;
    for (    Integer nodeId : vservers.keySet()) {
      VoldemortServer vs=vservers.get(nodeId);
      SlopStorageEngine sse=vs.getStoreRepository().getSlopStore();
      ClosableIterator<ByteArray> keys=sse.keys();
      long count=0;
      while (keys.hasNext()) {
        keys.next();
        count++;
      }
      keys.close();
      if (count > 0) {
        allSlopsEmpty=false;
        System.out.format("Slop engine for node %d is not yet empty with %d slops\n",nodeId,count);
      }
    }
    if (allSlopsEmpty) {
      break;
    }
    Thread.sleep(1000);
  }
  if (!allSlopsEmpty) {
    Assert.fail("Timeout while waiting for all slops to drain");
  }
  System.out.println("-------------------------------");
  System.out.println("        ALL SLOPS DRAINED      ");
  System.out.println("-------------------------------");
  boolean hasError=false;
  int goodCount=0;
  int errorCount=0;
  for (  Integer nodeId : serverKeys.keySet()) {
    VoldemortServer vs=vservers.get(nodeId);
    Store<ByteArray,byte[],byte[]> store=vs.getStoreRepository().getStorageEngine(storeDef.getName());
    List<Pair<ByteArray,Integer>> keySet=serverKeys.get(nodeId);
    for (    Pair<ByteArray,Integer> keyHostIdPair : keySet) {
      ByteArray key=keyHostIdPair.getFirst();
      Integer hostId=keyHostIdPair.getSecond();
      Integer nodeZoneId=cluster.getNodeById(nodeId).getZoneId();
      List<Versioned<byte[]>> result=store.get(key,null);
      if (cluster.getNodeById(nodeId).getZoneId() == droppingZoneId) {
        if (!result.isEmpty()) {
          System.err.format("Key %s for Node %d (zone %d) slopped on Node %d should be gone but exists\n",key.toString(),nodeId,nodeZoneId,hostId);
          hasError=true;
          errorCount++;
        }
 else {
          goodCount++;
        }
      }
 else {
        if (result.isEmpty()) {
          System.err.format("Key %s for Node %d (zone %d) slopped on Node %d should exist but not\n",key.toString(),nodeId,nodeZoneId,hostId);
          hasError=true;
          errorCount++;
        }
 else {
          goodCount++;
        }
      }
    }
  }
  System.out.format("Good keys count: %d; Error keys count: %d",goodCount,errorCount);
  Assert.assertFalse("Error Occurred BAD:" + errorCount + "; GOOD: "+ goodCount+ ". Check log.",hasError);
}
