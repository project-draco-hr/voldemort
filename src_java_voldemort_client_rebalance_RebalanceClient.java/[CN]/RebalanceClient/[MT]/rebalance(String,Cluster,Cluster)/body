{
  adminClient.setCluster(currentCluster);
  if (!RebalanceUtils.getClusterRebalancingToken()) {
    throw new VoldemortException("Failed to get Cluster permission to rebalance sleep and retry ...");
  }
  final Map<Integer,List<RebalanceStealInfo>> stealPartitionsMap=RebalanceUtils.getStealPartitionsMap(storeName,currentCluster,targetCluster);
  logger.info("Rebalancing plan:\n" + RebalanceUtils.getStealPartitionsMapAsString(stealPartitionsMap));
  final Map<Integer,AtomicBoolean> nodeLock=new HashMap<Integer,AtomicBoolean>();
  final List<Exception> failures=new ArrayList<Exception>();
  final Semaphore semaphore=new Semaphore(config.getMaxParallelRebalancingNodes());
  for (  int stealerNode : stealPartitionsMap.keySet()) {
    nodeLock.put(stealerNode,new AtomicBoolean(false));
  }
  while (!stealPartitionsMap.isEmpty()) {
    this.executor.execute(new Runnable(){
      public void run(){
        if (acquireSemaphore(semaphore)) {
          try {
            int stealerNodeId=getRandomStealerNodeId(stealPartitionsMap);
            if (nodeLock.get(stealerNodeId).compareAndSet(false,true)) {
              Pair<Integer,RebalanceStealInfo> rebalanceNodeInfo=getOneStealInfoAndupdateStealMap(stealerNodeId,stealPartitionsMap);
              attemptOneRebalanceTransfer(rebalanceNodeInfo.getFirst(),rebalanceNodeInfo.getSecond());
              nodeLock.get(stealerNodeId).set(false);
            }
          }
 catch (          Exception e) {
            failures.add(e);
          }
 finally {
            semaphore.release();
          }
        }
 else {
          failures.add(new VoldemortException("Failed to get rebalance task permit."));
        }
      }
      /** 
 * Given a stealerNode and stealInfo {@link RebalanceStealInfo}tries stealing unless succeed or failed max number of allowed
 * tries.
 * @param stealPartitionsMap
 */
      private void attemptOneRebalanceTransfer(      int stealerNodeId,      RebalanceStealInfo stealInfo){
        while (stealInfo.getAttempt() < config.getMaxRebalancingAttempt()) {
          try {
            getAdminClient().rebalanceNode(stealerNodeId,stealInfo);
            return;
          }
 catch (          Exception e) {
            logger.warn("Failed Attempt number " + stealInfo.getAttempt() + " Rebalance transfer "+ stealerNodeId+ " <== "+ stealInfo.getDonorId()+ " "+ stealInfo.getPartitionList()+ " with exception:",e);
          }
        }
        throw new VoldemortException("Failed rebalance transfer to:" + stealerNodeId + " <== from:"+ stealInfo.getDonorId()+ " partitions:"+ stealInfo.getPartitionList()+ ")");
      }
      /** 
 * Pick and remove the RebalanceStealInfo from the
 * List<RebalanceStealInfo> tail for the given stealerNodeId<br>
 * Deletes the entire key from map if the resultant list becomes
 * empty.
 * @param stealPartitionsMap
 * @return
 */
      private Pair<Integer,RebalanceStealInfo> getOneStealInfoAndupdateStealMap(      int stealerNodeId,      Map<Integer,List<RebalanceStealInfo>> stealPartitionsMap){
synchronized (stealPartitionsMap) {
          List<RebalanceStealInfo> stealInfoList=stealPartitionsMap.get(stealerNodeId);
          int stealInfoIndex=stealInfoList.size() - 1;
          RebalanceStealInfo stealInfo=stealInfoList.get(stealInfoIndex);
          stealInfoList.remove(stealInfoIndex);
          if (stealInfoList.isEmpty()) {
            stealPartitionsMap.remove(stealerNodeId);
          }
          return new Pair<Integer,RebalanceStealInfo>(stealerNodeId,stealInfo);
        }
      }
      private int getRandomStealerNodeId(      Map<Integer,List<RebalanceStealInfo>> stealPartitionsMap){
        int size=stealPartitionsMap.keySet().size();
        int randomIndex=(int)(Math.random() * size);
        return stealPartitionsMap.keySet().toArray(new Integer[0])[randomIndex];
      }
    }
);
  }
}
