{
  adminClient.setCluster(currentCluster);
  if (!RebalanceUtils.getClusterRebalancingToken()) {
    throw new VoldemortException("Failed to get Cluster permission to rebalance sleep and retry ...");
  }
  final Map<Integer,List<RebalanceStealInfo>> stealPartitionsMap=RebalanceUtils.getStealPartitionsMap(storeName,currentCluster,targetCluster);
  logger.info("Rebalancing plan:\n" + RebalanceUtils.getStealPartitionsMapAsString(stealPartitionsMap));
  final Map<Integer,AtomicBoolean> nodeRebalancingLock=createRebalancingLocks(stealPartitionsMap);
  final Semaphore semaphore=new Semaphore(config.getMaxParallelRebalancingNodes());
  while (!stealPartitionsMap.isEmpty()) {
    this.executor.execute(new Runnable(){
      public void run(){
        if (acquireSemaphore(semaphore)) {
          try {
            int stealerNodeId=RebalanceUtils.getRandomStealerNodeId(stealPartitionsMap);
            if (nodeRebalancingLock.get(stealerNodeId).compareAndSet(false,true)) {
              RebalanceStealInfo rebalanceStealInfo=RebalanceUtils.getOneStealInfoAndUpdateStealMap(stealerNodeId,stealPartitionsMap);
              if (rebalanceCommitOrRevert(stealPartitionsMap,stealerNodeId,rebalanceStealInfo)) {
                boolean success=attemptRebalanceTransfer(stealerNodeId,rebalanceStealInfo);
                if (!success) {
                  if (rebalanceStealInfo.getAttempt() < config.getMaxRebalancingAttempt()) {
                    rebalanceStealInfo.setAttempt(rebalanceStealInfo.getAttempt() + 1);
                    RebalanceUtils.revertStealPartitionsMap(stealPartitionsMap,stealerNodeId,rebalanceStealInfo);
                  }
 else {
                    logger.error("Rebalance attempt for node:" + stealerNodeId + " failed max times.");
                  }
                }
              }
              nodeRebalancingLock.get(stealerNodeId).set(false);
            }
          }
 catch (          Exception e) {
            logger.warn("Rebalance step failed",e);
          }
 finally {
            semaphore.release();
            logger.debug("rebalancing semaphore released.");
          }
        }
 else {
          logger.warn(new VoldemortException("Failed to get rebalance task permit."));
        }
      }
      /** 
 * Does an atomic commit or revert for the intended partitions
 * ownership changes.<br>
 * creates a new cluster metadata by moving partitions list
 * passed in parameter rebalanceStealInfo and propagates it to
 * all nodes.<br>
 * Revert all changes if failed to copy on required copies
 * (stealerNode and donorNode).<br>
 * holds a lock untill the commit/revert finishes.
 * @param stealPartitionsMap
 * @param stealerNodeId
 * @param rebalanceStealInfo
 * @return
 */
      private boolean rebalanceCommitOrRevert(      Map<Integer,List<RebalanceStealInfo>> stealPartitionsMap,      int stealerNodeId,      RebalanceStealInfo rebalanceStealInfo){
synchronized (stealPartitionsMap) {
          VectorClock clock=(VectorClock)adminClient.getRemoteCluster(rebalanceStealInfo.getDonorId()).getVersion();
          Cluster oldCluster=adminClient.getCluster();
          try {
            Cluster newCluster=RebalanceUtils.createUpdatedCluster(oldCluster,getStealerNode(currentCluster,targetCluster,stealerNodeId),currentCluster.getNodeById(rebalanceStealInfo.getDonorId()),rebalanceStealInfo.getPartitionList());
            clock.incrementVersion(stealerNodeId,System.currentTimeMillis());
            RebalanceUtils.propagateCluster(adminClient,newCluster,clock,Arrays.asList(stealerNodeId,rebalanceStealInfo.getDonorId()));
            adminClient.setCluster(newCluster);
            return true;
          }
 catch (          Exception e) {
            logger.warn("Failed to commit rebalance on node:" + stealerNodeId,e);
            RebalanceUtils.revertStealPartitionsMap(stealPartitionsMap,stealerNodeId,rebalanceStealInfo);
            clock.incrementVersion(stealerNodeId,System.currentTimeMillis());
            RebalanceUtils.propagateCluster(adminClient,oldCluster,clock,new ArrayList<Integer>());
          }
          return false;
        }
      }
      private Node getStealerNode(      Cluster currentCluster,      Cluster targetCluster,      int stealerNodeId){
        if (RebalanceUtils.containsNode(currentCluster,stealerNodeId))         return currentCluster.getNodeById(stealerNodeId);
 else         return RebalanceUtils.updateNode(targetCluster.getNodeById(stealerNodeId),new ArrayList<Integer>());
      }
      /** 
 * Attempt the data transfer on the stealerNode through the{@link AdminClient#rebalanceNode()} api.<br>
 * Blocks untill the AsyncStatus is set to success or exception <br>
 * @param stealerNodeId
 * @param stealPartitionsMap
 * @return success: true or false
 */
      private boolean attemptRebalanceTransfer(      int stealerNodeId,      RebalanceStealInfo stealInfo){
        if (stealInfo.getAttempt() < config.getMaxRebalancingAttempt()) {
          try {
            int rebalanceAsyncId=getAdminClient().rebalanceNode(stealerNodeId,stealInfo);
            adminClient.waitForCompletion(stealerNodeId,rebalanceAsyncId,24 * 60 * 60,TimeUnit.SECONDS);
            return true;
          }
 catch (          Exception e) {
            logger.warn("Failed Attempt number " + stealInfo.getAttempt() + " Rebalance transfer "+ stealerNodeId+ " <== "+ stealInfo.getDonorId()+ " "+ stealInfo.getPartitionList()+ " with exception:",e);
          }
        }
        return false;
      }
    }
);
  }
}
