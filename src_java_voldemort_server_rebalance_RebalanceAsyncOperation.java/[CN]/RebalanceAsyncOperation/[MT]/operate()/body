{
  adminClient=RebalanceUtils.createTempAdminClient(voldemortConfig,metadataStore.getCluster(),maxParallelStoresRebalancing * 4,maxParallelStoresRebalancing * 2);
  final List<Exception> failures=new ArrayList<Exception>();
  final List<String> readOnlyStoresCompleted=new ArrayList<String>();
  try {
    rebalancer.setRebalancingState(stealInfo,RebalancePartitionsInfoLifeCycleStatus.RUNNING);
    if (logger.isInfoEnabled()) {
      logger.info("starting rebalancing task" + stealInfo + ", setting status to: "+ RebalancePartitionsInfoLifeCycleStatus.RUNNING.name());
    }
    for (    final String storeName : ImmutableList.copyOf(stealInfo.getUnbalancedStoreList())) {
      executors.submit(new Runnable(){
        public void run(){
          try {
            boolean isReadOnlyStore=metadataStore.getStoreDef(storeName).getType().compareTo(ReadOnlyStorageConfiguration.TYPE_NAME) == 0;
            if (isReadOnlyStore) {
              readOnlyStoresCompleted.add(storeName);
            }
            if (logger.isDebugEnabled()) {
              logger.debug("operate() -  storeName: " + storeName + ", stealInfo: "+ stealInfo);
            }
            rebalanceStore(storeName,adminClient,stealInfo,isReadOnlyStore);
            if (!isReadOnlyStore) {
              List<String> tempUnbalancedStoreList=new ArrayList<String>(stealInfo.getUnbalancedStoreList());
              tempUnbalancedStoreList.remove(storeName);
              stealInfo.setUnbalancedStoreList(tempUnbalancedStoreList);
              if (logger.isDebugEnabled()) {
                logger.debug("Not read-only store, removed from unbalanced store list: " + storeName);
              }
            }
          }
 catch (          Exception e) {
            logger.error("rebalanceSubTask:" + stealInfo + " failed for store:"+ storeName+ " - "+ e.getMessage(),e);
            failures.add(e);
          }
        }
      }
);
    }
    waitForShutdown();
    rebalancer.setRebalancingState(stealInfo,RebalancePartitionsInfoLifeCycleStatus.NOT_RUNNING);
    if (logger.isInfoEnabled()) {
      logger.info("Not running rebalancing task" + stealInfo + ", setting status to: "+ RebalancePartitionsInfoLifeCycleStatus.NOT_RUNNING.name());
    }
    List<String> unbalancedStores=Lists.newArrayList(stealInfo.getUnbalancedStoreList());
    if (unbalancedStores.isEmpty()) {
      logger.info("Rebalancer: rebalance " + stealInfo + " completed successfully.");
      metadataStore.cleanRebalancingState(stealInfo);
    }
 else {
      unbalancedStores.removeAll(readOnlyStoresCompleted);
      if (unbalancedStores.size() > 0) {
        throw new VoldemortRebalancingException("Failed to rebalance task " + stealInfo,failures);
      }
 else {
        logger.info("Rebalancer: rebalance " + stealInfo + " on all read-write stores completed successfully. Read-only stores left.");
        rebalancer.acquireRebalancingPermit(metadataStore.getNodeId());
      }
    }
  }
  finally {
    if (logger.isInfoEnabled()) {
      logger.info("Releasing permit for Donor: " + stealInfo.getDonorId());
    }
    rebalancer.releaseRebalancingPermit(stealInfo.getDonorId());
    adminClient.stop();
    adminClient=null;
  }
}
