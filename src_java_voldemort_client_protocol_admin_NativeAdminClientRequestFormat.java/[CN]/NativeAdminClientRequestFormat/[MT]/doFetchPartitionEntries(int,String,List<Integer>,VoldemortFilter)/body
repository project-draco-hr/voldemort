{
  Node node=this.getMetadata().getCluster().getNodeById(nodeId);
  final SocketDestination destination=new SocketDestination(node.getHost(),node.getSocketPort(),RequestFormatType.ADMIN);
  final SocketAndStreams sands=pool.checkout(destination);
  try {
    DataOutputStream outputStream=sands.getOutputStream();
    outputStream.writeByte(VoldemortOpCode.GET_PARTITION_AS_STREAM_OP_CODE);
    outputStream.writeUTF(storeName);
    outputStream.writeInt(partitionList.size());
    for (    Integer p : partitionList) {
      outputStream.writeInt(p.intValue());
    }
    writeFilterClassToStream(outputStream,filter);
    outputStream.flush();
  }
 catch (  IOException e) {
    close(sands.getSocket());
    throw new VoldemortException(e);
  }
  final DataInputStream inputStream=sands.getInputStream();
  return new AbstractIterator<Pair<ByteArray,Versioned<byte[]>>>(){
    @Override public Pair<ByteArray,Versioned<byte[]>> computeNext(){
      try {
        int keySize=inputStream.readInt();
        if (keySize == -1) {
          checkException(inputStream);
          pool.checkin(destination,sands);
          return endOfData();
        }
 else {
          byte[] key=new byte[keySize];
          ByteUtils.read(inputStream,key);
          int valueSize=inputStream.readInt();
          byte[] value=new byte[valueSize];
          ByteUtils.read(inputStream,value);
          VectorClock clock=new VectorClock(value);
          Versioned<byte[]> versionedValue=new Versioned<byte[]>(ByteUtils.copy(value,clock.sizeInBytes(),value.length),clock);
          checkException(inputStream);
          return Pair.create(new ByteArray(key),versionedValue);
        }
      }
 catch (      IOException e) {
        close(sands.getSocket());
        pool.checkin(destination,sands);
        throw new VoldemortException(e);
      }
    }
  }
;
}
