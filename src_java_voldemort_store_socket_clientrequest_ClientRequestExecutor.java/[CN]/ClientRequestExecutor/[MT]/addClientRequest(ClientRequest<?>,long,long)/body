{
  if (logger.isTraceEnabled())   logger.trace("Associating client with " + socketChannel.socket());
  this.clientRequest=clientRequest;
  startTime=System.nanoTime();
  if (elapsedNs > (Time.NS_PER_MS * timeoutMs)) {
    this.expiration=startTime;
  }
 else {
    this.expiration=startTime + (Time.NS_PER_MS * timeoutMs) - elapsedNs;
  }
  if (this.expiration < startTime) {
    String errorMessage=String.format("Invalid timeout specified. startTime (%d) ns expiration (%d) ns timeout (%d) ms elapsed (%d) ns",startTime,expiration,timeoutMs,elapsedNs);
    throw new IllegalArgumentException(errorMessage);
  }
  resetStreams();
  boolean wasSuccessful=clientRequest.formatRequest(new DataOutputStream(outputStream));
  outputStream.getBuffer().flip();
  if (wasSuccessful) {
    SelectionKey selectionKey=socketChannel.keyFor(selector);
    if (selectionKey != null) {
      selectionKey.interestOps(SelectionKey.OP_WRITE);
      selector.wakeup();
    }
 else {
      if (logger.isDebugEnabled())       logger.debug("Client associated with " + socketChannel.socket() + " was not registered with Selector "+ selector+ ", assuming initial protocol negotiation");
    }
  }
 else {
    if (logger.isEnabledFor(Level.WARN))     logger.warn("Client associated with " + socketChannel.socket() + " did not successfully buffer output for request");
    completeClientRequest();
  }
}
