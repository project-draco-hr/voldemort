{
  stream.println("Commands supported");
  stream.println("------------------");
  stream.println("REBALANCE");
  stream.println("a) --url <url> --target-cluster <path> [ Run the actual rebalancing process ] ");
  stream.println("b) --current-cluster <path> --current-stores <path> --target-cluster <path> [ Generates the plan ]");
  stream.println("\t (i) --no-delete [ Will not delete the data after rebalancing ]");
  stream.println("\t (ii) --show-plan [ Will generate only the plan ]");
  stream.println("\t (iii) --output-dir [ Path to output dir where we store intermediate metadata ]");
  stream.println("\t (iv) --parallelism [ Number of parallel stealer - donor node tasks to run in parallel ] ");
  stream.println("\t (v) --tries [ Number of times we try to move the data before declaring failure ]");
  stream.println("\t (vi) --timeout [ Timeout in seconds for one rebalancing task ( stealer - donor tuple ) ]");
  stream.println("\t (vii) --batch [ Number of primary partitions to move together ]");
  stream.println("\t (viii) --stealer-based [ Run the rebalancing from the stealers perspective ]");
  stream.println();
  stream.println("GENERATE");
  stream.println("a) --current-cluster <path> --current-stores <path> --target-cluster <path> --generate [ Generates a new cluster xml with least number of movements." + " Uses target cluster i.e. current-cluster + new nodes ( with empty partitions ) ]");
  stream.println("\t (i)  --output-dir [ Output directory is where we store the optimized cluster ]");
  stream.println("\t (ii) --tries [ Number of optimization cycles ] ");
  stream.println("\t (iii) --generate-primaries-within-zone [ Keep primaries within same zone, default true ] ");
  stream.println("\t (iv) --generate-permit-xzone-moves [ Allow non-primary partitions to move across zones, default true ] ");
  stream.println("\t (v) --generate-random-num-partitions num-partitions [ Allow number of partitions per node to vary by (roughly) num-partitions, default 0 ] ");
  stream.println("\t (vi) --generate-enable-random-swaps [ Attempt to randomly swap partitions within a zone to improve balance, default true ] ");
  stream.println("\t (vii) --generate-random-swamp-attempts num-attempts [ Number of random swamps to attempt in hopes of improving balance, default 100 ] ");
  stream.println("\t (viii) --generate-random-swamp-successes num-successes [ Stop after num-successes successful random swap atttempts, default 100 ] ");
  stream.println("\t (ix) --generate-max-contiguous-partitions num-contiguous [ Max allowed contiguous partition IDs within a zone, default of -1 which is no limit ] ");
  stream.println();
  stream.println("ANALYZE");
  stream.println("a) --current-cluster <path> --current-stores <path> --analyze [ Analyzes a cluster xml for balance]");
  stream.println();
  stream.println("ENTROPY");
  stream.println("a) --current-cluster <path> --current-stores <path> --entropy <true / false> --output-dir <path> [ Runs the entropy calculator if " + "--entropy is true. Else dumps keys to the directory ]");
  stream.println("\t (i) --keys [ Number of keys ( per store ) we calculate entropy for ]");
  stream.println("\t (ii) --verbose-logging [ print keys found missing during entropy ]");
  parser.printHelpOn(stream);
}
