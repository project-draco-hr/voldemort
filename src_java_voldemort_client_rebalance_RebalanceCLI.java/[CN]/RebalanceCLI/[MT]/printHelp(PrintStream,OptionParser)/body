{
  stream.println("Commands supported");
  stream.println("------------------");
  stream.println("REBALANCE");
  stream.println("a) --url <url> --target-cluster <path> [ Run the actual rebalancing process ] ");
  stream.println("b) --current-cluster <path> --current-stores <path> --target-cluster <path> [ Generates the plan ]");
  stream.println("\t (i) --no-delete [ Will not delete the data after rebalancing ]");
  stream.println("\t (ii) --show-plan [ Will generate only the plan ]");
  stream.println("\t (iii) --output-dir [ Path to output dir where we store intermediate metadata ]");
  stream.println("\t (iv) --parallelism [ Number of parallel stealer - donor node tasks to run in parallel ] ");
  stream.println("\t (v) --tries [ Number of times we try to move the data before declaring failure ]");
  stream.println("\t (vi) --timeout [ Timeout in seconds for one rebalancing task ( stealer - donor tuple ) ]");
  stream.println("\t (vii) --batch [ Number of primary partitions to move together ]");
  stream.println("\t (viii) --stealer-based [ Run the rebalancing from the stealers perspective ]");
  stream.println();
  stream.println("GENERATE");
  stream.println("a) --current-cluster <path> --current-stores <path> --target-cluster <path> --generate [ Generates a new cluster xml with least number of movements." + " Uses target cluster i.e. current-cluster + new nodes ( with empty partitions ) ]");
  stream.println("\t (i)  --output-dir [ Output directory is where we store the optimized cluster ]");
  stream.println("\t (ii) --tries [ Number of optimization cycles ] ");
  stream.println();
  stream.println("ENTROPY");
  stream.println("a) --current-cluster <path> --current-stores <path> --entropy <true / false> --output-dir <path> [ Runs the entropy calculator if " + "--entropy is true. Else dumps keys to the directory ]");
  stream.println("\t (i) --keys [ Number of keys ( per store ) we calculate entropy for ]");
  parser.printHelpOn(stream);
}
