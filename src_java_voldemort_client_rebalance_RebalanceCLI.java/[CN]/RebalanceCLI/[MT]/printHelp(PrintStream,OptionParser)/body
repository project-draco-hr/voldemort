{
  stream.println("Commands supported");
  stream.println("------------------");
  stream.println();
  stream.println("REBALANCE (RUN PROCESS)");
  stream.println("a) --url <url> --target-cluster <path> [ Run the actual rebalancing process ] ");
  stream.println();
  stream.println("REBALANCE (GENERATE PLAN)");
  stream.println("b) --current-cluster <path> --current-stores <path> --target-cluster <path>");
  stream.println("\t (1) --no-delete [ Will not delete the data after rebalancing ]");
  stream.println("\t (2) --show-plan [ Will generate only the plan ]");
  stream.println("\t (3) --output-dir [ Path to output dir where we store intermediate metadata ]");
  stream.println("\t (4) --parallelism [ Number of parallel stealer - donor node tasks to run in parallel ] ");
  stream.println("\t (5) --tries [ Number of times we try to move the data before declaring failure ]");
  stream.println("\t (6) --timeout [ Timeout in seconds for one rebalancing task ( stealer - donor tuple ) ]");
  stream.println("\t (7) --batch [ Number of primary partitions to move together ]");
  stream.println("\t (8) --stealer-based [ Run the rebalancing from the stealers perspective ]");
  stream.println();
  stream.println("GENERATE");
  stream.println("a) --current-cluster <path> --current-stores <path> --target-cluster <path> --generate [ Generates a new cluster xml with least number of movements." + " Uses target cluster i.e. current-cluster + new nodes ( with empty partitions ) ]");
  stream.println("\t (1)  --output-dir [ Output directory is where we store the optimized cluster ]");
  stream.println("\t (2) --tries [ Number of optimization cycles ] ");
  stream.println("\t (3) --generate-disable-primary-balancing [ Do not balance number of primary partitions across nodes within each zone ] ");
  stream.println("\t (4) --generate-enable-xzone-primary-moves [ Allow primary partitions to move across zones ] ");
  stream.println("\t (5) --generate-enable-any-xzone-nary-moves [ Allow non-primary partitions to move across zones. ]");
  stream.println("\t (6) --generate-enable-last-resort-xzone-nary-moves [ Allow non-primary partitions to move across zones as a last resort --- Will only do such a move if all possible moves result in xzone move.] ");
  stream.println("\t (7) --generate-enable-xzone-shuffle [ Allow non-primary partitions to move across zones for random swaps or greedy swaps.] ");
  stream.println("\t (8) --generate-enable-random-swaps [ Attempt to randomly swap partitions within a zone to improve balance ] ");
  stream.println("\t (9) --generate-random-swap-attempts num-attempts [ Number of random swaps to attempt in hopes of improving balance ] ");
  stream.println("\t(10) --generate-random-swap-successes num-successes [ Stop after num-successes successful random swap atttempts ] ");
  stream.println("\t(11) --generate-enable-greedy-swaps [ Attempt to greedily (randomly) swap partitions within a zone to improve balance. Greedily/randomly means sample many swaps for each node and choose best swap. ] ");
  stream.println("\t(12) --generate-greedy-swap-attempts num-attempts [ Number of greedy swap passes to attempt. Each pass can be fairly expensive. ] ");
  stream.println("\t(13) --generate-greedy-max-partitions-per-node num-partitions [ num-partitions per node to consider in each greedy pass. Partitions selected randomly from each node.  ] ");
  stream.println("\t(14) --generate-greedy-max-partitions-per-zone num-partitions [ num-partitions per zone to consider in each greedy pass. Partitions selected randomly from all partitions in zone not on node being considered. ] ");
  stream.println("\t(15) --generate-max-contiguous-partitions num-contiguous [ Max allowed contiguous partition IDs within a zone ] ");
  stream.println();
  stream.println("ANALYZE");
  stream.println("a) --current-cluster <path> --current-stores <path> --analyze [ Analyzes a cluster xml for balance]");
  stream.println();
  stream.println("ENTROPY");
  stream.println("a) --current-cluster <path> --current-stores <path> --entropy <true / false> --output-dir <path> [ Runs the entropy calculator if " + "--entropy is true. Else dumps keys to the directory ]");
  stream.println("\t (1) --keys [ Number of keys ( per store ) we calculate entropy for ]");
  stream.println("\t (2) --verbose-logging [ print keys found missing during entropy ]");
  parser.printHelpOn(stream);
}
