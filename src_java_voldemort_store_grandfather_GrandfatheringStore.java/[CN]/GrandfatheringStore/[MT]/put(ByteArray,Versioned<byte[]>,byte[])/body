{
  if (this.isReadOnly)   throw new UnsupportedOperationException("Put is not supported on this store, it is read-only.");
  if (metadata.getServerState().equals(MetadataStore.VoldemortState.GRANDFATHERING_SERVER)) {
    final List<Integer> mappedPartitions=metadata.getRoutingStrategy(getName()).getPartitionList(key.get());
    List<Integer> currentPartitions=metadata.getCluster().getNodeById(metadata.getNodeId()).getPartitionIds();
    mappedPartitions.removeAll(currentPartitions);
    if (mappedPartitions.size() != 1) {
      logger.error("Received key which mapped to multiple partitions on single node");
    }
 else     if (metadata.getGrandfatherState().findNodeIds(mappedPartitions.get(0)) != null) {
      this.threadPool.execute(new Runnable(){
        public void run(){
          try {
            Date date=new Date();
            Set<Integer> futureNodeIds=metadata.getGrandfatherState().findNodeIds(mappedPartitions.get(0));
            for (            int futureNodeId : futureNodeIds) {
              Slop slop=new Slop(getName(),Operation.PUT,key,value.getValue(),transform,futureNodeId,date);
              try {
                slopStore.put(slop.makeKey(),Versioned.value(slop,value.getVersion()),null);
              }
 catch (              Exception e) {
                logger.warn("Failed to put PUT operation on " + getName() + " to node "+ futureNodeId);
              }
            }
          }
 catch (          Exception e) {
            logger.warn("Failed to put PUT operation on " + getName() + " to slop store",e);
          }
        }
      }
);
    }
  }
  getInnerStore().put(key,value,transform);
}
