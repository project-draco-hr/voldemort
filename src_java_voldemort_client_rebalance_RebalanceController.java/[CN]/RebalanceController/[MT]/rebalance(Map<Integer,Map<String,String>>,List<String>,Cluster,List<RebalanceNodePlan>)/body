{
  final List<RebalanceTask> primaryTasks=new ArrayList<RebalanceTask>();
  final List<RebalanceTask> replicaTasks=new ArrayList<RebalanceTask>();
  List<Exception> failures=new ArrayList<Exception>();
  final Set<Integer> participatingNodesId=Collections.synchronizedSet(new HashSet<Integer>());
  final List<RebalancePartitionsInfo> onlyPrimaries=getTasks(rebalanceNodePlanList,true);
  final List<RebalancePartitionsInfo> onlyReplicas=getTasks(rebalanceNodePlanList,false);
  final CountDownLatch gate=new CountDownLatch(onlyPrimaries.size());
  ExecutorService execPrimaries=executeTasks(participatingNodesId,onlyPrimaries,rebalanceConfig.getMaxParallelRebalancing(),gate,primaryTasks);
  try {
    if (logger.isDebugEnabled()) {
      logger.debug("Waiting on the gate");
    }
    gate.await();
    if (logger.isDebugEnabled()) {
      logger.debug("Gate opened");
    }
  }
 catch (  InterruptedException e) {
    failures.add(e);
  }
  final ExecutorService execReplicas=executeTasks(participatingNodesId,onlyReplicas,rebalanceConfig.getMaxParallelDonors(),null,replicaTasks);
  if (logger.isInfoEnabled()) {
    logger.info("All rebalance tasks were submitted (shutting down in " + rebalanceConfig.getRebalancingClientTimeoutSeconds() + " sec");
  }
  RebalanceUtils.executorShutDown(execPrimaries,rebalanceConfig.getRebalancingClientTimeoutSeconds());
  RebalanceUtils.executorShutDown(execReplicas,rebalanceConfig.getRebalancingClientTimeoutSeconds());
  if (logger.isInfoEnabled()) {
    logger.info("Finished waiting for executors ");
  }
  failures=addFailures(failures,primaryTasks);
  failures=addFailures(failures,replicaTasks);
  if (failures.size() == 0 && readOnlyStores.size() > 0) {
    logger.info("Swapping stores " + readOnlyStores + " on "+ participatingNodesId);
    ExecutorService swapExecutors=RebalanceUtils.createExecutors(transitionTarget.getNumberOfNodes());
    for (    final Integer nodeId : participatingNodesId) {
      swapExecutors.submit(new Runnable(){
        public void run(){
          Map<String,String> storeDirs=currentROStoreVersionsDirs.get(nodeId);
          try {
            logger.info("Swapping read-only stores on node " + nodeId);
            adminClient.swapStoresAndCleanState(nodeId,storeDirs);
            logger.info("Successfully swapped on node " + nodeId);
          }
 catch (          Exception e) {
            logger.error("Failed swapping on node " + nodeId,e);
          }
        }
      }
);
    }
    try {
      RebalanceUtils.executorShutDown(swapExecutors,rebalanceConfig.getRebalancingClientTimeoutSeconds());
    }
 catch (    Exception e) {
      logger.error("Interrupted swapping executor ",e);
    }
  }
  if (failures.size() > 0) {
    throw new VoldemortRebalancingException("Rebalance task terminated unsuccessfully");
  }
}
