{
  RebalanceUtils.printLog(taskId,logger,"Submitting rebalance tasks ");
  if (rebalanceConfig.isShowPlanEnabled()) {
    return;
  }
  ExecutorService service=RebalanceUtils.createExecutors(rebalanceConfig.getMaxParallelRebalancing());
  final List<RebalanceTask> successfulTasks=Lists.newArrayList();
  final List<RebalanceTask> failedTasks=Lists.newArrayList();
  Semaphore[] donorPermits=new Semaphore[currentCluster.getNumberOfNodes()];
  for (  Node node : currentCluster.getNodes()) {
    donorPermits[node.getId()]=new Semaphore(1);
  }
  try {
    List<RebalanceTask> allTasks=executeTasks(taskId,service,rebalancePartitionPlanList,donorPermits);
    RebalanceUtils.printLog(taskId,logger,"All rebalance tasks were submitted ( shutting down in " + rebalanceConfig.getRebalancingClientTimeoutSeconds() + " sec )");
    RebalanceUtils.executorShutDown(service,rebalanceConfig.getRebalancingClientTimeoutSeconds());
    RebalanceUtils.printLog(taskId,logger,"Finished waiting for executors");
    List<Exception> failures=filterTasks(allTasks,successfulTasks,failedTasks);
    if (failedTasks.size() > 0) {
      throw new VoldemortRebalancingException("Rebalance task terminated unsuccessfully",failures);
    }
  }
 catch (  VoldemortRebalancingException e) {
    logger.error("Failure while migrating partitions for rebalance task " + taskId);
    if (hasReadOnlyStores && hasReadWriteStores && finishedReadOnlyStores) {
      adminClient.rebalanceStateChange(null,currentCluster,null,true,true,false,false,false);
    }
 else     if (hasReadWriteStores && finishedReadOnlyStores) {
      adminClient.rebalanceStateChange(null,currentCluster,null,false,true,false,false,false);
    }
    throw e;
  }
 finally {
    if (!service.isShutdown()) {
      RebalanceUtils.printErrorLog(taskId,logger,"Could not shutdown service cleanly for rebalance task " + taskId,null);
      service.shutdownNow();
    }
  }
}
