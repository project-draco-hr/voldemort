{
  List<Node> nodes=stateData.getNodes();
  while (stateData.getSuccesses() < preferred && stateData.getNodeIndex() < nodes.size()) {
    Node node=nodes.get(stateData.getNodeIndex());
    long start=System.nanoTime();
    try {
      Store<ByteArray,byte[]> store=stores.get(node.getId());
      Object result=storeRequest.request(node,store);
      RequestCompletedCallback rcc=new RequestCompletedCallback(node,key,((System.nanoTime() - start) / Time.NS_PER_MS),result);
      stateData.incrementSuccesses();
      stateData.getInterimResults().add(rcc);
      failureDetector.recordSuccess(rcc.getNode(),rcc.getRequestTime());
    }
 catch (    UnreachableStoreException e) {
      stateData.recordFailure(e);
      failureDetector.recordException(node,((System.nanoTime() - start) / Time.NS_PER_MS),e);
    }
catch (    VoldemortApplicationException e) {
      stateData.setFatalError(e);
      stateMachine.addEvent(Event.ERROR);
      return;
    }
catch (    Exception e) {
      stateData.recordFailure(e);
      if (logger.isEnabledFor(Level.WARN))       logger.warn("Error in " + stateData.getOperation() + " on node "+ node.getId()+ "("+ node.getHost()+ ")",e);
    }
    stateData.incrementNodeIndex();
  }
  if (stateData.getSuccesses() < required) {
    if (insufficientSuccessesEvent != null) {
      stateMachine.addEvent(insufficientSuccessesEvent);
    }
 else {
      stateData.setFatalError(new InsufficientOperationalNodesException(required + " " + stateData.getOperation().getSimpleName()+ "s required, but "+ stateData.getSuccesses()+ " succeeded",stateData.getFailures()));
      stateMachine.addEvent(Event.ERROR);
    }
  }
 else {
    stateMachine.addEvent(completeEvent);
  }
}
