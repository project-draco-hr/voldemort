{
  List<Node> nodes=pipelineData.getNodes();
  int attempts=Math.min(preferred,nodes.size());
  final Map<Integer,Response<ByteArray,Object>> responses=new ConcurrentHashMap<Integer,Response<ByteArray,Object>>();
  final CountDownLatch latch=new CountDownLatch(attempts);
  if (logger.isTraceEnabled())   logger.trace("Attempting " + attempts + " "+ pipeline.getOperation().getSimpleName()+ " operations in parallel");
  for (int i=0; i < attempts; i++) {
    final Node node=nodes.get(i);
    pipelineData.incrementNodeIndex();
    NonblockingStoreCallback callback=new NonblockingStoreCallback(){
      public void requestComplete(      Object result,      long requestTime){
        if (logger.isTraceEnabled())         logger.trace(pipeline.getOperation().getSimpleName() + " response received (" + requestTime+ " ms.) from node "+ node.getId());
        responses.put(node.getId(),new Response<ByteArray,Object>(node,key,result,requestTime));
        latch.countDown();
      }
    }
;
    if (logger.isTraceEnabled())     logger.trace("Submitting " + pipeline.getOperation().getSimpleName() + " request on node "+ node.getId());
    NonblockingStore store=nonblockingStores.get(node.getId());
    storeRequest.submit(node,store,callback);
  }
  try {
    latch.await(timeoutMs,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
    if (logger.isEnabledFor(Level.WARN))     logger.warn(e,e);
  }
  for (  Response<ByteArray,Object> response : responses.values()) {
    if (response.getValue() instanceof Exception) {
      Node node=response.getNode();
      Exception e=(Exception)response.getValue();
      long requestTime=response.getRequestTime();
      if (logger.isEnabledFor(Level.WARN))       logger.warn("Error in " + pipeline.getOperation().getSimpleName() + " on node "+ node.getId()+ "("+ node.getHost()+ ")",e);
      if (e instanceof UnreachableStoreException) {
        pipelineData.recordFailure(e);
        failureDetector.recordException(node,requestTime,(UnreachableStoreException)e);
      }
 else       if (e instanceof VoldemortApplicationException) {
        pipelineData.setFatalError((VoldemortApplicationException)e);
        pipeline.addEvent(Event.ERROR);
        return;
      }
 else {
        pipelineData.recordFailure(e);
      }
    }
 else {
      pipelineData.incrementSuccesses();
      pipelineData.getResponses().add((Response<ByteArray,V>)response);
      failureDetector.recordSuccess(response.getNode(),response.getRequestTime());
    }
  }
  if (pipelineData.getSuccesses() < required) {
    if (insufficientSuccessesEvent != null) {
      pipeline.addEvent(insufficientSuccessesEvent);
    }
 else {
      pipelineData.setFatalError(new InsufficientOperationalNodesException(required + " " + pipeline.getOperation().getSimpleName()+ "s required, but "+ pipelineData.getSuccesses()+ " succeeded",pipelineData.getFailures()));
      pipeline.addEvent(Event.ERROR);
    }
  }
 else {
    pipeline.addEvent(completeEvent);
  }
}
