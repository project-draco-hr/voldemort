{
  final AtomicBoolean isRunning=new AtomicBoolean(true);
  ExecutorService threadPool=Executors.newFixedThreadPool(ec2FailureDetectorTestConfig.testThreads + 1);
  for (int i=0; i < ec2FailureDetectorTestConfig.testThreads; i++) {
    threadPool.submit(new Runnable(){
      public void run(){
        while (isRunning.get())         test(store);
      }
    }
);
  }
  threadPool.submit(new Runnable(){
    public void run(){
      try {
        Random random=new Random();
        while (isRunning.get()) {
          String offlineHostName=getRandomHostName();
          Node offlineNode=getNodeByHostName(offlineHostName,failureDetector);
          stopClusterNode(offlineHostName,ec2FailureDetectorTestConfig);
          Thread.sleep(random.nextInt(10000));
          startClusterNode(offlineHostName,ec2FailureDetectorTestConfig,offlineNode.getId());
          Thread.sleep(random.nextInt(10000));
        }
      }
 catch (      Exception e) {
        if (logger.isEnabledFor(Level.ERROR))         logger.error(e);
      }
    }
  }
);
  Thread.sleep(ec2FailureDetectorTestConfig.testTime * 60 * 1000);
  if (logger.isInfoEnabled())   logger.info("Shutting down");
  isRunning.set(false);
  threadPool.shutdown();
  threadPool.awaitTermination(Long.MAX_VALUE,TimeUnit.SECONDS);
  assertEquals(hostNamePairs.size(),failureDetector.getAvailableNodeCount());
}
