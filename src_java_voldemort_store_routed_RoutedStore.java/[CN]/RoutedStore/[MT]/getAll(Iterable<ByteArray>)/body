{
  StoreUtils.assertValidKeys(keys);
  GetAllPipelineData pipelineData=new GetAllPipelineData();
  Pipeline pipeline=new Pipeline(Operation.GET_ALL);
  Action configureNodes=new GetAllConfigureNodes(pipelineData,Event.CONFIGURED,failureDetector,storeDef.getPreferredReads(),storeDef.getRequiredReads(),routingStrategy,keys);
  Action performParallelRequests=new PerformParallelGetAllRequests(pipelineData,null,storeDef.getPreferredReads(),nonblockingStores);
  Action acknowledgeResponse=new GetAllAcknowledgeResponse(pipelineData,repairReads ? Event.RESPONSES_RECEIVED : Event.COMPLETED,failureDetector);
  Action performSerialRequests=new PerformSerialGetAllRequests(pipelineData,repairReads ? Event.RESPONSES_RECEIVED : Event.COMPLETED,keys,failureDetector,innerStores,storeDef.getPreferredReads(),storeDef.getRequiredReads());
  Map<Event,Action> eventActions=new HashMap<Event,Action>();
  eventActions.put(Event.STARTED,configureNodes);
  eventActions.put(Event.CONFIGURED,performParallelRequests);
  eventActions.put(Event.RESPONSE_RECEIVED,acknowledgeResponse);
  if (repairReads) {
    Action readRepair=null;
    eventActions.put(Event.RESPONSES_RECEIVED,readRepair);
  }
  eventActions.put(Event.INSUFFICIENT_SUCCESSES,performSerialRequests);
  pipeline.setEventActions(eventActions);
  pipeline.addEvent(Event.STARTED);
  pipeline.processEvents(timeoutMs,TimeUnit.MILLISECONDS);
  if (pipelineData.getFatalError() != null)   throw pipelineData.getFatalError();
  for (  ByteArray key : keys) {
    MutableInt successCount=pipelineData.getSuccessCount(key);
    if (successCount.intValue() < storeDef.getRequiredReads())     throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads() + " reads required, but " + successCount+ " succeeded.",pipelineData.getFailures());
  }
  Map<ByteArray,List<Versioned<byte[]>>> results=new HashMap<ByteArray,List<Versioned<byte[]>>>();
  return results;
}
