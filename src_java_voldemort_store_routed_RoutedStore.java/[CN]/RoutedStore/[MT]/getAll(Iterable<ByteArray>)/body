{
  StoreUtils.assertValidKeys(keys);
  Map<ByteArray,List<Versioned<byte[]>>> result=StoreUtils.newEmptyHashMap(keys);
  Map<Node,List<ByteArray>> nodeToKeysMap=Maps.newHashMap();
  Map<ByteArray,List<Node>> keyToExtraNodesMap=Maps.newHashMap();
  for (  ByteArray key : keys) {
    List<Node> nodesForKey=routingStrategy.routeRequest(key.get());
    checkRequiredReads(nodesForKey);
    List<Node> preferredNodes=Lists.newArrayListWithCapacity(storeDef.getPreferredReads());
    List<Node> extraNodes=Lists.newArrayListWithCapacity(nodesForKey.size() - storeDef.getPreferredReads());
    for (int i=0; i < storeDef.getPreferredReads() && i < nodesForKey.size(); i++) {
      Node node=nodesForKey.get(i);
      if (isAvailable(node))       preferredNodes.add(node);
 else       extraNodes.add(node);
    }
    while (preferredNodes.size() < storeDef.getPreferredReads() && !extraNodes.isEmpty())     preferredNodes.add(extraNodes.remove(0));
    for (    Node node : preferredNodes) {
      List<ByteArray> nodeKeys=nodeToKeysMap.get(node);
      if (nodeKeys == null) {
        nodeKeys=Lists.newArrayList();
        nodeToKeysMap.put(node,nodeKeys);
      }
      nodeKeys.add(key);
    }
    if (!extraNodes.isEmpty()) {
      List<Node> nodes=keyToExtraNodesMap.get(key);
      if (nodes == null)       keyToExtraNodesMap.put(key,extraNodes);
      nodes.addAll(extraNodes);
    }
  }
  List<Callable<GetAllResult>> callables=Lists.newArrayList();
  for (  Map.Entry<Node,List<ByteArray>> entry : nodeToKeysMap.entrySet()) {
    final Node node=entry.getKey();
    final Collection<ByteArray> nodeKeys=entry.getValue();
    if (isAvailable(node))     callables.add(new GetAllCallable(node,nodeKeys));
  }
  List<Exception> failures=Lists.newArrayList();
  List<NodeValue<ByteArray,byte[]>> nodeValues=Lists.newArrayList();
  Map<ByteArray,MutableInt> keyToSuccessCount=Maps.newHashMap();
  for (  ByteArray key : keys)   keyToSuccessCount.put(key,new MutableInt(0));
  List<Future<GetAllResult>> futures;
  try {
    futures=executor.invokeAll(callables,timeoutMs * 3,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
    throw new InsufficientOperationalNodesException("getAll operation interrupted.",e);
  }
  for (  Future<GetAllResult> f : futures) {
    if (f.isCancelled()) {
      logger.warn("Get operation timed out after " + timeoutMs + " ms.");
      continue;
    }
    try {
      GetAllResult getResult=f.get();
      if (getResult.exception != null) {
        failures.add(getResult.exception);
        continue;
      }
      for (      ByteArray key : keys) {
        List<Versioned<byte[]>> retrieved=getResult.retrieved.get(key);
        MutableInt successCount=keyToSuccessCount.get(key);
        successCount.setValue(successCount.intValue() + 1);
        if (retrieved != null) {
          List<Versioned<byte[]>> existing=result.get(key);
          if (existing == null)           result.put(key,Lists.newArrayList(retrieved));
 else           existing.addAll(retrieved);
        }
      }
      nodeValues.addAll(getResult.nodeValues);
    }
 catch (    InterruptedException e) {
      throw new InsufficientOperationalNodesException("getAll operation interrupted.",e);
    }
catch (    ExecutionException e) {
      if (e.getCause() instanceof Error)       throw (Error)e.getCause();
 else       logger.error(e.getMessage(),e);
    }
  }
  for (  ByteArray key : keys) {
    MutableInt successCountWrapper=keyToSuccessCount.get(key);
    int successCount=successCountWrapper.intValue();
    if (successCount < storeDef.getPreferredReads()) {
      for (      Node node : keyToExtraNodesMap.get(key)) {
        try {
          List<Versioned<byte[]>> values=innerStores.get(node.getId()).get(key);
          List<Versioned<byte[]>> versioneds=result.get(key);
          if (versioneds == null)           result.put(key,Lists.newArrayList(values));
 else           versioneds.addAll(values);
          node.getStatus().setAvailable();
          if (++successCount >= storeDef.getPreferredReads())           break;
        }
 catch (        UnreachableStoreException e) {
          failures.add(e);
          markUnavailable(node,e);
        }
catch (        Exception e) {
          logger.warn("Error in GET_ALL on node " + node.getId() + "("+ node.getHost()+ ")",e);
          failures.add(e);
        }
      }
    }
    successCountWrapper.setValue(successCount);
  }
  for (  Map.Entry<ByteArray,List<Versioned<byte[]>>> entry : result.entrySet()) {
    if (repairReads && entry.getValue().size() > 1)     repairReads(nodeValues);
  }
  for (  Map.Entry<ByteArray,MutableInt> mapEntry : keyToSuccessCount.entrySet()) {
    int successCount=mapEntry.getValue().intValue();
    if (successCount < storeDef.getRequiredReads())     throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads() + " reads required, but " + successCount+ " succeeded.",failures);
  }
  return result;
}
