{
  StoreUtils.assertValidKey(key);
  final List<Node> nodes=availableNodes(routingStrategy.routeRequest(key.get()));
  checkRequiredReads(nodes);
  final List<Versioned<byte[]>> retrieved=Collections.synchronizedList(new ArrayList<Versioned<byte[]>>());
  final List<NodeValue<ByteArray,byte[]>> nodeValues=Collections.synchronizedList(new ArrayList<NodeValue<ByteArray,byte[]>>());
  final AtomicInteger successes=new AtomicInteger();
  final List<Exception> failures=Collections.synchronizedList(new LinkedList<Exception>());
  int attempts=Math.min(this.storeDef.getPreferredReads(),nodes.size());
  final CountDownLatch latch=new CountDownLatch(attempts);
  int nodeIndex=0;
  for (; nodeIndex < attempts; nodeIndex++) {
    final Node node=nodes.get(nodeIndex);
    this.executor.execute(new Runnable(){
      public void run(){
        try {
          List<Versioned<byte[]>> fetched=innerStores.get(node.getId()).get(key);
          retrieved.addAll(fetched);
          if (repairReads) {
            for (            Versioned<byte[]> f : fetched)             nodeValues.add(new NodeValue<ByteArray,byte[]>(node.getId(),key,f));
          }
          successes.incrementAndGet();
          node.getStatus().setAvailable();
        }
 catch (        UnreachableStoreException e) {
          failures.add(e);
          markUnavailable(node,e);
        }
catch (        Exception e) {
          logger.warn("Error in GET on node " + node.getId() + "("+ node.getHost()+ ")",e);
          failures.add(e);
        }
 finally {
          latch.countDown();
        }
      }
    }
);
  }
  try {
    boolean succeeded=latch.await(timeoutMs,TimeUnit.MILLISECONDS);
    if (!succeeded)     logger.warn("Get operation timed out after " + timeoutMs + " ms.");
  }
 catch (  InterruptedException e) {
    throw new InsufficientOperationalNodesException("Get operation interrupted!",e);
  }
  while (successes.get() < this.storeDef.getPreferredReads() && nodeIndex < nodes.size()) {
    Node node=nodes.get(nodeIndex);
    try {
      List<Versioned<byte[]>> fetched=innerStores.get(node.getId()).get(key);
      retrieved.addAll(fetched);
      if (repairReads) {
        for (        Versioned<byte[]> f : fetched)         nodeValues.add(new NodeValue<ByteArray,byte[]>(node.getId(),key,f));
      }
      successes.incrementAndGet();
      node.getStatus().setAvailable();
    }
 catch (    UnreachableStoreException e) {
      failures.add(e);
      markUnavailable(node,e);
    }
catch (    Exception e) {
      logger.warn("Error in GET on node " + node.getId() + "("+ node.getHost()+ ")",e);
      failures.add(e);
    }
    nodeIndex++;
  }
  if (logger.isTraceEnabled())   logger.trace("GET retrieved the following node values: " + formatNodeValues(nodeValues));
  if (repairReads && retrieved.size() > 1)   repairReads(nodeValues);
  if (successes.get() >= this.storeDef.getRequiredReads())   return retrieved;
 else   throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads() + " reads required, but " + successes.get()+ " succeeded.",failures);
}
