{
  populateStore(Sets.<Integer>newHashSet());
  Map<ByteArray,Version> versions=Maps.newHashMap();
  for (  ByteArray key : keyValues.keySet())   versions.put(key,store.get(key).get(0).getVersion());
  Set<Integer> failedNodes=getFailedNodes();
  Set<ByteArray> failedKeys=Sets.newHashSet();
  Random rand=new Random();
  for (  ByteArray key : keysToNodes.keySet()) {
    Iterable<Integer> nodes=keysToNodes.get(key);
    for (int i=0; i < REPLICATION_FACTOR; i++) {
      int node=Iterables.get(nodes,i);
      if (failedNodes.contains(node)) {
        failedKeys.add(key);
        break;
      }
    }
  }
  for (  ByteArray failedKey : failedKeys) {
    try {
      store.delete(failedKey,versions.get(failedKey));
    }
 catch (    Exception e) {
      if (logger.isTraceEnabled())       logger.trace(e,e);
    }
  }
  reviveNodes(failedNodes);
  for (  SlopPusherJob job : slopPusherJobs) {
    if (logger.isTraceEnabled())     logger.trace("Started slop pusher job " + job);
    job.run();
    if (logger.isTraceEnabled())     logger.trace("Finished slop pusher job " + job);
  }
  for (  ByteArray key : failedKeys) {
    List<Versioned<byte[]>> res=store.get(key);
    assertTrue("key should be deleted",res.size() == 0);
  }
}
