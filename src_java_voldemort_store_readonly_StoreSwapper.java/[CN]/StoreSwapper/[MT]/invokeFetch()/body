{
  Map<Integer,Future<String[]>> fetchFiles=new HashMap<Integer,Future<String[]>>();
  for (  final Node node : cluster.getNodes()) {
    fetchFiles.put(node.getId(),executor.submit(new Callable<String[]>(){
      public String[] call() throws Exception {
        String url=node.getHttpUrl() + "/" + readOnlyMgmtPath;
        PostMethod post=new PostMethod(url);
        post.addParameter("operation","fetch");
        String indexFile=basePath + "/" + node.getId()+ ".index";
        String dataFile=basePath + "/" + node.getId()+ ".data";
        post.addParameter("index",indexFile);
        post.addParameter("data",dataFile);
        logger.info("Invoking fetch for node " + node.getId() + " for "+ indexFile+ " and "+ dataFile);
        int responseCode=httpClient.executeMethod(post);
        String response=post.getResponseBodyAsString(30000);
        if (responseCode != 200)         throw new VoldemortException("Swap request on node " + node.getId() + " failed: "+ post.getStatusText());
        String[] files=response.split("\n");
        if (files.length != 2)         throw new VoldemortException("Expected two files, but found " + files.length + " in '"+ response+ "'.");
        logger.info("Fetch succeeded on node " + node.getId());
        return files;
      }
    }
));
  }
  List<String[]> results=new ArrayList<String[]>();
  for (int nodeId=0; nodeId < cluster.getNumberOfNodes(); nodeId++) {
    Future<String[]> val=fetchFiles.get(nodeId);
    try {
      results.add(val.get());
    }
 catch (    ExecutionException e) {
      throw new VoldemortException(e.getCause());
    }
catch (    InterruptedException e) {
      throw new VoldemortException(e);
    }
  }
  return results;
}
