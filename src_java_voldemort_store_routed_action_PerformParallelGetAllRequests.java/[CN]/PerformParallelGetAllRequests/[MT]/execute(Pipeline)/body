{
  int attempts=pipelineData.getNodeToKeysMap().size();
  final List<Response<Iterable<ByteArray>,Object>> responses=new ArrayList<Response<Iterable<ByteArray>,Object>>();
  final CountDownLatch latch=new CountDownLatch(attempts);
  final AtomicBoolean isComplete=new AtomicBoolean(false);
  final Object lock=new Object();
  if (logger.isTraceEnabled())   logger.trace("Attempting " + attempts + " "+ pipeline.getOperation().getSimpleName()+ " operations in parallel");
  for (  Map.Entry<Node,List<ByteArray>> entry : pipelineData.getNodeToKeysMap().entrySet()) {
    final Node node=entry.getKey();
    final Collection<ByteArray> keys=entry.getValue();
    NonblockingStoreCallback callback=new NonblockingStoreCallback(){
      public void requestComplete(      Object result,      long requestTime){
synchronized (lock) {
          if (isComplete.get())           return;
          if (logger.isTraceEnabled())           logger.trace(pipeline.getOperation().getSimpleName() + " response received (" + requestTime+ " ms.) from node "+ node.getId());
          responses.add(new Response<Iterable<ByteArray>,Object>(node,keys,result,requestTime));
          latch.countDown();
        }
      }
    }
;
    if (logger.isTraceEnabled())     logger.trace("Submitting " + pipeline.getOperation().getSimpleName() + " request on node "+ node.getId());
    NonblockingStore store=nonblockingStores.get(node.getId());
    store.submitGetAllRequest(keys,callback);
  }
  try {
    latch.await(timeoutMs,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
    if (logger.isEnabledFor(Level.WARN))     logger.warn(e,e);
  }
synchronized (lock) {
    isComplete.set(true);
  }
  for (  Response<Iterable<ByteArray>,Object> response : responses) {
    if (response.getValue() instanceof Exception) {
      Node node=response.getNode();
      Exception e=(Exception)response.getValue();
      long requestTime=response.getRequestTime();
      if (logger.isEnabledFor(Level.WARN))       logger.warn("Error in " + pipeline.getOperation().getSimpleName() + " on node "+ node.getId()+ "("+ node.getHost()+ ")",e);
      if (e instanceof UnreachableStoreException) {
        pipelineData.recordFailure(e);
        failureDetector.recordException(node,requestTime,(UnreachableStoreException)e);
      }
 else       if (e instanceof VoldemortApplicationException) {
        pipelineData.setFatalError((VoldemortApplicationException)e);
        pipeline.addEvent(Event.ERROR);
        return;
      }
 else {
        pipelineData.recordFailure(e);
      }
    }
 else {
      Map<ByteArray,List<Versioned<byte[]>>> values=(Map<ByteArray,List<Versioned<byte[]>>>)response.getValue();
      for (      ByteArray key : response.getKey()) {
        MutableInt successCount=pipelineData.getSuccessCount(key);
        successCount.increment();
        List<Versioned<byte[]>> retrieved=values.get(key);
        if (retrieved != null) {
          List<Versioned<byte[]>> existing=pipelineData.getResult().get(key);
          if (existing == null)           pipelineData.getResult().put(key,Lists.newArrayList(retrieved));
 else           existing.addAll(retrieved);
        }
      }
      pipelineData.getResponses().add(new Response<Iterable<ByteArray>,Map<ByteArray,List<Versioned<byte[]>>>>(response.getNode(),response.getKey(),values,response.getRequestTime()));
      failureDetector.recordSuccess(response.getNode(),response.getRequestTime());
    }
  }
  pipeline.addEvent(completeEvent);
}
