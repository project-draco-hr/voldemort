{
  int attempts=pipelineData.getNodeToKeysMap().size();
  final Map<Integer,Response<Iterable<ByteArray>,Object>> responses=new ConcurrentHashMap<Integer,Response<Iterable<ByteArray>,Object>>();
  final CountDownLatch attemptsLatch=new CountDownLatch(attempts);
  if (logger.isTraceEnabled())   logger.trace("Attempting " + attempts + " "+ pipeline.getOperation().getSimpleName()+ " operations in parallel");
  Map<ByteArray,byte[]> transforms=pipelineData.getTransforms();
  for (  Map.Entry<Node,List<ByteArray>> entry : pipelineData.getNodeToKeysMap().entrySet()) {
    final Node node=entry.getKey();
    final Collection<ByteArray> keys=entry.getValue();
    NonblockingStoreCallback callback=new Callback(pipeline,node,keys,responses,attemptsLatch);
    if (logger.isTraceEnabled())     logger.trace("Submitting " + pipeline.getOperation().getSimpleName() + " request on node "+ node.getId());
    NonblockingStore store=nonblockingStores.get(node.getId());
    store.submitGetAllRequest(keys,transforms,callback,timeoutMs);
  }
  try {
    attemptsLatch.await(timeoutMs,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
    if (logger.isEnabledFor(Level.WARN))     logger.warn(e,e);
  }
  for (  Response<Iterable<ByteArray>,Object> response : responses.values()) {
    if (response.getValue() instanceof Exception) {
      if (handleResponseError(response,pipeline,failureDetector))       return;
    }
 else {
      Map<ByteArray,List<Versioned<byte[]>>> values=Utils.uncheckedCast(response.getValue());
      for (      ByteArray key : response.getKey()) {
        MutableInt successCount=pipelineData.getSuccessCount(key);
        successCount.increment();
        List<Versioned<byte[]>> retrieved=values.get(key);
        if (retrieved != null) {
          List<Versioned<byte[]>> existing=pipelineData.getResult().get(key);
          if (existing == null)           pipelineData.getResult().put(key,Lists.newArrayList(retrieved));
 else           existing.addAll(retrieved);
        }
        HashSet<Integer> zoneResponses=null;
        if (pipelineData.getKeyToZoneResponse().containsKey(key)) {
          zoneResponses=pipelineData.getKeyToZoneResponse().get(key);
        }
 else {
          zoneResponses=new HashSet<Integer>();
          pipelineData.getKeyToZoneResponse().put(key,zoneResponses);
        }
        zoneResponses.add(response.getNode().getZoneId());
      }
      pipelineData.getResponses().add(new Response<Iterable<ByteArray>,Map<ByteArray,List<Versioned<byte[]>>>>(response.getNode(),response.getKey(),values,response.getRequestTime()));
      failureDetector.recordSuccess(response.getNode(),response.getRequestTime());
    }
  }
  pipeline.addEvent(completeEvent);
}
