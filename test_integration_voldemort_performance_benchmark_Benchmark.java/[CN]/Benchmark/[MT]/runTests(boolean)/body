{
  int localOpsCounts=0;
  String label=null;
  if (runBenchmark) {
    localOpsCounts=this.opsCount;
    label=new String("benchmark");
  }
 else {
    localOpsCounts=this.recordCount;
    label=new String("warmup");
  }
  Vector<Thread> threads=new Vector<Thread>();
  for (int index=0; index < this.numThreads; index++) {
    VoldemortWrapper db=new VoldemortWrapper(storeClient,this.verifyRead,this.ignoreNulls);
    Thread clientThread=new ClientThread(db,runBenchmark,this.workLoad,localOpsCounts / this.numThreads,this.perThreadThroughputPerMs,this.verbose);
    threads.add(clientThread);
  }
  long startRunBenchmark=System.currentTimeMillis();
  for (  Thread currentThread : threads) {
    currentThread.start();
  }
  StatusThread statusThread=null;
  if (this.statusIntervalSec > 0) {
    statusThread=new StatusThread(threads,this.statusIntervalSec,startRunBenchmark);
    statusThread.start();
  }
  for (  Thread currentThread : threads) {
    try {
      currentThread.join();
    }
 catch (    InterruptedException e) {
      if (this.verbose)       e.printStackTrace();
    }
  }
  long endRunBenchmark=System.currentTimeMillis();
  if (this.statusIntervalSec > 0) {
    statusThread.interrupt();
  }
  System.out.println("[" + label + "]\tRunTime(ms): "+ (endRunBenchmark - startRunBenchmark));
  double throughput=Time.MS_PER_SECOND * ((double)localOpsCounts) / ((double)(endRunBenchmark - startRunBenchmark));
  System.out.println("[" + label + "]\tThroughput(ops/sec): "+ throughput);
  if (runBenchmark) {
    Metrics.getInstance().printReport(System.out);
  }
  return (endRunBenchmark - startRunBenchmark);
}
