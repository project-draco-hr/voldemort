{
  Map<Integer,Future<String>> fetchDirs=new HashMap<Integer,Future<String>>();
  for (  final Node node : cluster.getNodes()) {
    fetchDirs.put(node.getId(),executor.submit(new Callable<String>(){
      public String call() throws Exception {
        String storeDir=basePath + "/node-" + node.getId();
        logger.info("Invoking fetch for node " + node.getId() + " for "+ storeDir);
        String response=adminClient.readonlyOps.fetchStore(node.getId(),storeName,storeDir,pushVersion,timeoutMs);
        if (response == null)         throw new VoldemortException("Fetch request on node " + node.getId() + " ("+ node.getHost()+ ") failed");
        logger.info("Fetch succeeded on node " + node.getId());
        return response.trim();
      }
    }
));
  }
  Map<Integer,Response> fetchResponseMap=Maps.newTreeMap();
  boolean fetchErrors=false;
  for (  final Node node : cluster.getNodes()) {
    Integer nodeId=node.getId();
    Future<String> val=fetchDirs.get(nodeId);
    try {
      String response=val.get();
      fetchResponseMap.put(nodeId,new Response(response));
    }
 catch (    Exception e) {
      fetchErrors=true;
      fetchResponseMap.put(nodeId,new Response(e));
    }
  }
  if (fetchErrors) {
    for (    Map.Entry<Integer,Response> entry : fetchResponseMap.entrySet()) {
      if (!entry.getValue().isSuccessful()) {
        logger.error("Error on node " + entry.getKey() + " during push : ",entry.getValue().getException());
      }
    }
    Iterator<FailedFetchStrategy> strategyIterator=failedFetchStrategyList.iterator();
    boolean swapIsPossible=false;
    FailedFetchStrategy strategy=null;
    while (strategyIterator.hasNext() && !swapIsPossible) {
      strategy=strategyIterator.next();
      try {
        swapIsPossible=strategy.dealWithIt(storeName,pushVersion,fetchResponseMap);
      }
 catch (      Exception e) {
        if (strategyIterator.hasNext()) {
          logger.error("Got an exception while trying to execute: " + strategy.toString() + ". Continuing with next strategy.",e);
        }
 else {
          logger.error("Got an exception while trying to execute the last remaining strategy: " + strategy.toString() + ". Swap will be aborted.",e);
        }
      }
    }
    if (swapIsPossible) {
    }
 else {
      throw new VoldemortException("Exception during push. Swap will be aborted.");
    }
  }
  return fetchResponseMap;
}
