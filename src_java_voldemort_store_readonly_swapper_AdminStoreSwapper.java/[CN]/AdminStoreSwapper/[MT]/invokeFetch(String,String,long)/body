{
  final Map<Integer,Future<String>> fetchDirs=new HashMap<Integer,Future<String>>();
  for (  final Node node : cluster.getNodes()) {
    fetchDirs.put(node.getId(),executor.submit(new Callable<String>(){
      public String call() throws Exception {
        String response=null;
        if (buildPrimaryReplicasOnly) {
          response=fetch(basePath);
        }
 else {
          String storeDir=basePath + "/" + ReadOnlyUtils.NODE_DIRECTORY_PREFIX+ node.getId();
          response=fetch(storeDir);
        }
        if (response == null)         throw new VoldemortException("Fetch request on " + node.briefToString() + " failed");
        logger.info("Fetch succeeded on " + node.briefToString());
        return response.trim();
      }
      private String fetch(      String storeDir){
        logger.info("Invoking fetch for " + node.briefToString() + " for "+ storeDir);
        return adminClient.readonlyOps.fetchStore(node.getId(),storeName,storeDir,pushVersion,timeoutMs);
      }
    }
));
  }
  Map<Node,Response> fetchResponseMap=Maps.newTreeMap();
  boolean fetchErrors=false;
  int numQuotaExceededException=0;
  boolean invalidBootstrapURLExceptions=false;
  for (  final Node node : cluster.getNodes()) {
    Future<String> val=fetchDirs.get(node.getId());
    try {
      String response=val.get();
      fetchResponseMap.put(node,new Response(response));
    }
 catch (    ExecutionException e) {
      fetchErrors=true;
      if (e.getCause() instanceof QuotaExceededException) {
        numQuotaExceededException++;
        fetchResponseMap.put(node,new Response((QuotaExceededException)e.getCause()));
      }
 else       if (e.getCause() instanceof InvalidBootstrapURLException) {
        invalidBootstrapURLExceptions=true;
      }
 else {
        fetchResponseMap.put(node,new Response(e));
      }
    }
catch (    Exception e) {
      fetchErrors=true;
      fetchResponseMap.put(node,new Response(e));
    }
  }
  if (invalidBootstrapURLExceptions) {
    throw new InvalidBootstrapURLException("Exceptions during push. Invalid bootstrap url. Please check your " + "cluster bootstrap URL");
  }
  if (fetchErrors) {
    for (    Map.Entry<Node,Response> entry : fetchResponseMap.entrySet()) {
      if (!entry.getValue().isSuccessful()) {
        logger.error("Error on " + entry.getKey().briefToString() + " during push : ",entry.getValue().getException());
      }
    }
    Iterator<FailedFetchStrategy> strategyIterator=failedFetchStrategyList.iterator();
    boolean swapIsPossible=false;
    FailedFetchStrategy strategy=null;
    while (strategyIterator.hasNext() && !swapIsPossible) {
      strategy=strategyIterator.next();
      try {
        logger.info("About to attempt: " + strategy.toString());
        swapIsPossible=strategy.dealWithIt(storeName,pushVersion,fetchResponseMap);
        logger.info("Finished executing: " + strategy.toString() + "; swapIsPossible: "+ swapIsPossible);
      }
 catch (      Exception e) {
        if (strategyIterator.hasNext()) {
          logger.error("Got an exception while trying to execute: " + strategy.toString() + ". Continuing with next strategy.",e);
        }
 else {
          logger.error("Got an exception while trying to execute the last remaining strategy: " + strategy.toString() + ". Swap will be aborted.",e);
        }
      }
    }
    if (swapIsPossible) {
    }
 else {
      String errorMessage="";
      if (numQuotaExceededException > 0) {
        errorMessage="Disk Quota exceeded. Swap will be aborted.";
      }
 else {
        errorMessage="Exception during push. Swap will be aborted.";
      }
      throw new VoldemortException(errorMessage);
    }
  }
  return fetchResponseMap;
}
