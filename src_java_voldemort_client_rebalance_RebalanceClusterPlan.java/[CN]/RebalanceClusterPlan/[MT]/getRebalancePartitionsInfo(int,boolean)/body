{
  final HashMap<Integer,HashMap<String,HashMap<Integer,List<Integer>>>> donorNodeToStoreToStealPartition=Maps.newHashMap();
  final HashMap<Integer,HashMap<String,HashMap<Integer,List<Integer>>>> donorNodeToStoreToDeletePartition=Maps.newHashMap();
  for (  StoreDefinition storeDef : storeDefs) {
    Map<Integer,Set<Pair<Integer,Integer>>> currentNodeIdToAllPartitionTuples=RebalanceUtils.getNodeIdToAllPartitions(targetCluster,storeDef,true);
    RebalanceUtils.combinePartitionTuples(currentAllStoresNodeIdToAllPartitionTuples,currentNodeIdToAllPartitionTuples);
    Map<Integer,Set<Pair<Integer,Integer>>> targetNodeIdToAllPartitionTuples=RebalanceUtils.getNodeIdToAllPartitions(finalCluster,storeDef,true);
    RebalanceUtils.combinePartitionTuples(targetAllStoresNodeIdToAllPartitionTuples,targetNodeIdToAllPartitionTuples);
    Map<Integer,Set<Pair<Integer,Integer>>> stealerNodeIdToStolenPartitionTuples=RebalanceUtils.getStolenPartitionTuples(targetCluster,finalCluster,storeDef);
    if (stealerNodeIdToStolenPartitionTuples.get(stealerNodeId) == null) {
      continue;
    }
    final Set<Pair<Integer,Integer>> haveToStealTuples=Sets.newHashSet(stealerNodeIdToStolenPartitionTuples.get(stealerNodeId));
    for (    Node donorNode : targetCluster.getNodes()) {
      if (donorNode.getId() == stealerNodeId)       continue;
      if (haveFinishedPartitions(haveToStealTuples)) {
        break;
      }
      final Set<Pair<Integer,Integer>> trackStealPartitionsTuples=new HashSet<Pair<Integer,Integer>>();
      final Set<Pair<Integer,Integer>> trackDeletePartitionsTuples=new HashSet<Pair<Integer,Integer>>();
      donatePartitionTuple(donorNode,haveToStealTuples,trackStealPartitionsTuples,currentNodeIdToAllPartitionTuples.get(donorNode.getId()));
      donateDeletePartitionTuple(donorNode,trackStealPartitionsTuples,trackDeletePartitionsTuples,stealerNodeIdToStolenPartitionTuples.get(donorNode.getId()),enableDeletePartition);
      if (trackStealPartitionsTuples.size() > 0) {
        addPartitionsToPlan(trackStealPartitionsTuples,donorNodeToStoreToStealPartition,donorNode.getId(),storeDef.getName());
      }
      if (trackDeletePartitionsTuples.size() > 0) {
        addPartitionsToPlan(trackDeletePartitionsTuples,donorNodeToStoreToDeletePartition,donorNode.getId(),storeDef.getName());
      }
    }
  }
  final List<RebalancePartitionsInfo> result=new ArrayList<RebalancePartitionsInfo>();
  for (  int donorNodeId : donorNodeToStoreToStealPartition.keySet()) {
    HashMap<String,HashMap<Integer,List<Integer>>> storeToStealPartition=donorNodeToStoreToStealPartition.get(donorNodeId);
    HashMap<String,HashMap<Integer,List<Integer>>> storeToDeletePartition=donorNodeToStoreToDeletePartition.containsKey(donorNodeId) ? donorNodeToStoreToDeletePartition.get(donorNodeId) : new HashMap<String,HashMap<Integer,List<Integer>>>();
    result.add(new RebalancePartitionsInfo(stealerNodeId,donorNodeId,storeToStealPartition,storeToDeletePartition,targetCluster,0));
  }
  return result;
}
