{
  final int donorId=donorNode.getId();
  final Set<Integer> donorAllPartitions=nodeIdToAllPartitions.get(donorId);
  final Iterator<Integer> iter=haveToStealReplicas.iterator();
  while (iter.hasNext()) {
    int replicaPartitionToSteal=iter.next();
    boolean deletedInFuture=false;
    for (    Node targetNode : targetCluster.getNodes()) {
      if (targetNode.getId() == donorId)       continue;
      Set<Integer> allDeletedPartitions=targetNodeIdToAllDeletedPartitions.get(targetNode.getId());
      Set<Integer> alreadyDeletedPartitions=alreadyDeletedNodeIdToPartions.get(targetNode.getId());
      if (alreadyDeletedPartitions != null && !alreadyDeletedPartitions.isEmpty())       allDeletedPartitions.removeAll(alreadyDeletedPartitions);
      if (allDeletedPartitions.contains(replicaPartitionToSteal)) {
        deletedInFuture=true;
      }
    }
    if (deletedInFuture)     continue;
    Set<Integer> donorDonatedPartitions=targetNodeIdToAllStolenPartitions.get(donorId);
    if (donorDonatedPartitions != null && donorDonatedPartitions.contains(replicaPartitionToSteal))     continue;
    Set<Integer> deletedPartitions=alreadyDeletedNodeIdToPartions.get(donorId);
    boolean isDeletedPartition=false;
    if (deletedPartitions != null && deletedPartitions.contains(replicaPartitionToSteal)) {
      isDeletedPartition=true;
    }
    if (donorAllPartitions.contains(replicaPartitionToSteal) && !isDeletedPartition) {
      trackStealPartitions.add(replicaPartitionToSteal);
      iter.remove();
    }
  }
}
