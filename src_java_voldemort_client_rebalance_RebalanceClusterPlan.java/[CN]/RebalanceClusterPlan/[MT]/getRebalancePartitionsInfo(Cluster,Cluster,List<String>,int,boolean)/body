{
  final List<RebalancePartitionsInfo> result=new ArrayList<RebalancePartitionsInfo>();
  final Set<Pair<Integer,Integer>> haveToStealPrimaries=RebalanceUtils.getStolenPrimaryPartitionTuples(currentCluster,targetCluster,stealerId);
  final Set<Pair<Integer,Integer>> haveToStealReplicas=RebalanceUtils.getStolenReplicaPartitionTuples(currentCluster,targetCluster,storeDefs,stealerId);
  final Set<Pair<Integer,Integer>> haveToDeletePartitions=getDeletedPartitions(stealerId);
  if (haveToStealPrimaries.size() == 0 && haveToStealReplicas.size() == 0 && haveToDeletePartitions.size() == 0) {
    return result;
  }
  for (  Node donorNode : currentCluster.getNodes()) {
    if (donorNode.getId() == stealerId)     continue;
    if (haveFinishedPartitions(haveToStealPrimaries) && haveFinishedPartitions(haveToStealReplicas) && haveFinishedPartitions(haveToDeletePartitions)) {
      break;
    }
    final Set<Pair<Integer,Integer>> trackStealMasterPartitionsTuples=new HashSet<Pair<Integer,Integer>>();
    final Set<Pair<Integer,Integer>> trackStealReplicaPartitionsTuples=new HashSet<Pair<Integer,Integer>>();
    final Set<Pair<Integer,Integer>> trackDeletePartitionsTuples=new HashSet<Pair<Integer,Integer>>();
    donatePrimary(donorNode,haveToStealPrimaries,trackStealMasterPartitionsTuples);
    donateReplicas(donorNode,haveToStealReplicas,trackStealReplicaPartitionsTuples);
    deleteDonatedPartitions(donorNode,trackDeletePartitionsTuples,enableDeletePartition,stealerId);
    if (trackStealMasterPartitionsTuples.size() > 0 || trackStealReplicaPartitionsTuples.size() > 0 || trackDeletePartitionsTuples.size() > 0) {
      result.add(new RebalancePartitionsInfo(stealerId,donorNode.getId(),new ArrayList<Integer>(getPartitions(trackStealMasterPartitionsTuples)),new ArrayList<Integer>(getPartitions(trackStealReplicaPartitionsTuples)),new ArrayList<Integer>(getPartitions(trackDeletePartitionsTuples)),storeNames,0));
    }
  }
  return result;
}
