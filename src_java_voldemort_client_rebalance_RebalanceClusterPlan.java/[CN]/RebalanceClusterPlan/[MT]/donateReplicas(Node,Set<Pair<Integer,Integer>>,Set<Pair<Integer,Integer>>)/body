{
  final int donorId=donorNode.getId();
  final Set<Pair<Integer,Integer>> donorAllPartitions=nodeIdToAllPartitions.get(donorId);
  final Iterator<Pair<Integer,Integer>> iter=haveToStealReplicas.iterator();
  while (iter.hasNext()) {
    Pair<Integer,Integer> replicaPartitionTupleToSteal=iter.next();
    boolean deletedInFuture=false;
    for (    Node targetNode : targetCluster.getNodes()) {
      if (targetNode.getId() == donorId)       continue;
      Set<Pair<Integer,Integer>> allDeletedPartitions=targetNodeIdToAllDeletedPartitions.get(targetNode.getId());
      Set<Pair<Integer,Integer>> alreadyDeletedPartitions=alreadyDeletedNodeIdToPartions.get(targetNode.getId());
      if (alreadyDeletedPartitions != null && !alreadyDeletedPartitions.isEmpty())       allDeletedPartitions.removeAll(alreadyDeletedPartitions);
      if (allDeletedPartitions.contains(replicaPartitionTupleToSteal)) {
        deletedInFuture=true;
      }
    }
    if (deletedInFuture)     continue;
    Set<Pair<Integer,Integer>> donorDonatedPartitions=targetNodeIdToAllStolenPartitions.get(donorId);
    if (donorDonatedPartitions != null && donorDonatedPartitions.contains(replicaPartitionTupleToSteal))     continue;
    Set<Pair<Integer,Integer>> deletedPartitions=alreadyDeletedNodeIdToPartions.get(donorId);
    boolean isDeletedPartition=false;
    if (deletedPartitions != null && deletedPartitions.contains(replicaPartitionTupleToSteal)) {
      isDeletedPartition=true;
    }
    if (donorAllPartitions.contains(replicaPartitionTupleToSteal) && !isDeletedPartition) {
      trackStealPartitions.add(replicaPartitionTupleToSteal);
      iter.remove();
    }
  }
}
