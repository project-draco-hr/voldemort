{
  this.targetCluster=targetCluster;
  this.finalCluster=finalCluster;
  this.storeDefs=storeDefs;
  RebalanceUtils.validateTargetFinalCluster(targetCluster,finalCluster);
  RebalanceUtils.validateClusterStores(targetCluster,storeDefs);
  RebalanceUtils.validateClusterStores(finalCluster,storeDefs);
  this.currentAllStoresNodeIdToAllPartitionTuples=Maps.newHashMap();
  this.targetAllStoresNodeIdToAllPartitionTuples=Maps.newHashMap();
  this.batchPlan=batchPlan();
  this.rebalanceTaskQueue=new ConcurrentLinkedQueue<RebalanceNodePlan>();
  HashMap<Integer,List<RebalancePartitionsInfo>> nodeToBatchPlan=new HashMap<Integer,List<RebalancePartitionsInfo>>();
  for (  RebalancePartitionsInfo info : batchPlan) {
    int nodeId=info.getDonorId();
    if (isStealerBased) {
      nodeId=info.getStealerId();
    }
    if (!nodeToBatchPlan.containsKey(nodeId)) {
      nodeToBatchPlan.put(nodeId,new ArrayList<RebalancePartitionsInfo>());
    }
    nodeToBatchPlan.get(nodeId).add(info);
  }
  for (  int nodeId : nodeToBatchPlan.keySet()) {
    RebalanceNodePlan rnp=new RebalanceNodePlan(nodeId,Lists.newArrayList(nodeToBatchPlan.get(nodeId)),isStealerBased);
    this.rebalanceTaskQueue.offer(rnp);
  }
}
