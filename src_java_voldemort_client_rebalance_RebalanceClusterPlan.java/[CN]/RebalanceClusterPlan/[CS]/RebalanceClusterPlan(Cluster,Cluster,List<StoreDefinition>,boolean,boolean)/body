{
  this.currentCluster=currentCluster;
  this.targetCluster=targetCluster;
  this.batchPlan=Lists.newArrayList();
  this.currentAllStoresNodeIdToAllPartitionTuples=Maps.newHashMap();
  this.targetAllStoresNodeIdToAllPartitionTuples=Maps.newHashMap();
  if (currentCluster.getNumberOfPartitions() != targetCluster.getNumberOfPartitions())   throw new VoldemortException("Total number of partitions should be equal [ Current cluster (" + currentCluster.getNumberOfPartitions() + ") not equal to Target cluster ("+ targetCluster.getNumberOfPartitions()+ ") ]");
  if (currentCluster.getNumberOfNodes() != targetCluster.getNumberOfNodes())   throw new VoldemortException("Total number of nodes should be equal [ Current cluster (" + currentCluster.getNumberOfNodes() + ") not equal to Target cluster ("+ targetCluster.getNumberOfNodes()+ ") ]");
  for (  Node node : targetCluster.getNodes()) {
    this.batchPlan.addAll(getRebalancePartitionsInfo(currentCluster,targetCluster,storeDefs,node.getId(),enabledDeletePartition));
  }
  prioritizeBatchPlan();
  this.rebalanceTaskQueue=new ConcurrentLinkedQueue<RebalanceNodePlan>();
  HashMap<Integer,List<RebalancePartitionsInfo>> nodeToBatchPlan=new HashMap<Integer,List<RebalancePartitionsInfo>>();
  for (  RebalancePartitionsInfo info : batchPlan) {
    int nodeId=info.getDonorId();
    if (isStealerBased) {
      nodeId=info.getStealerId();
    }
    if (!nodeToBatchPlan.containsKey(nodeId)) {
      nodeToBatchPlan.put(nodeId,new ArrayList<RebalancePartitionsInfo>());
    }
    nodeToBatchPlan.get(nodeId).add(info);
  }
  for (  int nodeId : nodeToBatchPlan.keySet()) {
    this.rebalanceTaskQueue.offer(new RebalanceNodePlan(nodeId,Lists.newArrayList(nodeToBatchPlan.get(nodeId)),isStealerBased));
  }
}
