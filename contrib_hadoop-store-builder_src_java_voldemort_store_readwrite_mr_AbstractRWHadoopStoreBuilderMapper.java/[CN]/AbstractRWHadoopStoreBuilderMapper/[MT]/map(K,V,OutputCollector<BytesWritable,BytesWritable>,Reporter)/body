{
  Object keyObject=makeKey(key,value);
  Object valueObject=makeValue(key,value);
  if (keyObject == null || valueObject == null)   return;
  byte[] keyBytes=keySerializer.toBytes(keyObject);
  byte[] valBytes=valueSerializer.toBytes(valueObject);
  if (keySerializerDefinition.hasCompression()) {
    keyBytes=keyCompressor.deflate(keyBytes);
  }
  if (valueSerializerDefinition.hasCompression()) {
    valBytes=valueCompressor.deflate(valBytes);
  }
  List<Node> nodeList=routingStrategy.routeRequest(keyBytes);
  versions.clear();
  if (vectorNodeId < 0) {
    versions.add(0,new ClockEntry((short)nodeList.get(0).getId(),vectorNodeVersion));
  }
 else {
    versions.add(0,new ClockEntry((short)vectorNodeId,vectorNodeVersion));
  }
  vectorClock=new VectorClock(versions,jobStartTime);
  byte[] vectorClockBytes=vectorClock.toBytes();
  byte[] outputValBytes=new byte[(3 * sizeInt) + keyBytes.length + valBytes.length+ vectorClockBytes.length];
  ByteUtils.writeInt(outputValBytes,keyBytes.length,0);
  System.arraycopy(keyBytes,0,outputValBytes,sizeInt,keyBytes.length);
  ByteUtils.writeInt(outputValBytes,valBytes.length,sizeInt + keyBytes.length);
  System.arraycopy(valBytes,0,outputValBytes,sizeInt + sizeInt + keyBytes.length,valBytes.length);
  ByteUtils.writeInt(outputValBytes,vectorClockBytes.length,(2 * sizeInt) + keyBytes.length + valBytes.length);
  System.arraycopy(vectorClockBytes,0,outputValBytes,(3 * sizeInt) + keyBytes.length + valBytes.length,vectorClockBytes.length);
  BytesWritable outputVal=new BytesWritable(outputValBytes);
  int chunkId=ReadOnlyUtils.chunk(md5er.digest(keyBytes),getNumChunks());
  for (  Node node : nodeList) {
    byte[] outputKeyBytes=new byte[sizeInt + sizeInt];
    ByteUtils.writeInt(outputKeyBytes,node.getId(),0);
    ByteUtils.writeInt(outputKeyBytes,chunkId,sizeInt);
    BytesWritable outputKey=new BytesWritable(outputKeyBytes);
    output.collect(outputKey,outputVal);
  }
  md5er.reset();
}
