{
  assert(ec2RebalancingTestConfig.getInstanceCount() == 2);
  final Cluster targetCluster=expandCluster(0,ServerTestUtils.getLocalCluster(2,getPorts(2),new int[][]{{},{0,1,2,3}}));
  final SocketStoreClientFactory factory=getStoreClientFactory();
  final StoreClient<String,String> storeClient=getStoreClient(factory);
  final CountDownLatch nodeKilled=new CountDownLatch(1);
  final CountDownLatch rebalanceStarted=new CountDownLatch(1);
  final CountDownLatch testsDone=new CountDownLatch(1);
  final AtomicBoolean restartedRebalancing=new AtomicBoolean(false);
  final AtomicBoolean entriesCorrect=new AtomicBoolean(false);
  try {
    ExecutorService executorService=Executors.newFixedThreadPool(5);
    populateData(originalCluster,Arrays.asList(0));
    if (logger.isInfoEnabled())     logger.info("Populated data, start the test.");
    executorService.submit(new Runnable(){
      public void run(){
        AdminClient adminClient=new AdminClient(getBootstrapUrl(originalCluster,0),new AdminClientConfig());
        RebalancePartitionsInfo rebalancePartitionsInfo=new RebalancePartitionsInfo(1,0,Arrays.asList(0,1,2,3),Arrays.asList(ec2RebalancingTestConfig.testStoreName),false,0);
        int reqId=adminClient.rebalanceNode(rebalancePartitionsInfo);
        if (logger.isInfoEnabled())         logger.info("Starting rebalancing: async request id = " + reqId);
        rebalanceStarted.countDown();
      }
    }
);
    executorService.submit(new Runnable(){
      public void run(){
        try {
          String hostname=originalCluster.getNodeById(1).getHost();
          if (logger.isInfoEnabled())           logger.info("Waiting to get rebalancing into a half-way state");
          rebalanceStarted.await();
          Thread.sleep(25);
          stopClusterNode(hostname,ec2RebalancingTestConfig);
          nodeKilled.countDown();
          if (logger.isInfoEnabled())           logger.info("Killed node 1");
          Thread.sleep(250);
          startClusterNode(hostname,ec2RebalancingTestConfig,1);
          if (logger.isInfoEnabled())           logger.info("Brought node 1 back up");
        }
 catch (        InterruptedException ie) {
          logger.error(ie);
          Thread.currentThread().interrupt();
        }
catch (        Exception e) {
          throw new IllegalStateException("unable to stop/start the host!",e);
        }
      }
    }
);
    executorService.submit(new Runnable(){
      public void run(){
        try {
          try {
            if (logger.isInfoEnabled())             logger.info("Waiting for the node to be brought down");
            nodeKilled.await();
            if (logger.isInfoEnabled())             logger.info("Waiting for five seconds for rebalancing to retry");
            Thread.sleep(10000);
            AdminClient adminClient=new AdminClient(getBootstrapUrl(originalCluster,0),new AdminClientConfig());
            Versioned<MetadataStore.VoldemortState> serverState=adminClient.getRemoteServerState(1);
            long start=System.currentTimeMillis();
            long delay=5000;
            long delayMax=1000 * 30;
            long timeout=5 * 1000 * 60;
            while (System.currentTimeMillis() < start + timeout && serverState.getValue() != MetadataStore.VoldemortState.REBALANCING_MASTER_SERVER) {
              Thread.sleep(delay);
              if (delay < delayMax)               delay*=2;
              serverState=adminClient.getRemoteServerState(1);
              if (logger.isInfoEnabled())               logger.info("Server state: " + serverState.getValue());
            }
            if (serverState.getValue() == MetadataStore.VoldemortState.REBALANCING_MASTER_SERVER) {
              restartedRebalancing.set(true);
              if (logger.isInfoEnabled())               logger.info("Recovered node began rebalancing, continuing with the test.");
              Thread.sleep(60 * 1000);
              try {
                for (                int nodeId : Arrays.asList(0,1)) {
                  List<Integer> availablePartitions=targetCluster.getNodeById(nodeId).getPartitionIds();
                  List<Integer> unavailablePartitions=getUnavailablePartitions(targetCluster,availablePartitions);
                  checkGetEntries(originalCluster.getNodeById(nodeId),targetCluster,unavailablePartitions,availablePartitions);
                }
                entriesCorrect.set(true);
              }
 catch (              AssertionFailedError afe) {
                logger.error(afe);
              }
            }
          }
 catch (          InterruptedException ie) {
            logger.error(ie);
            Thread.currentThread().interrupt();
          }
        }
  finally {
          factory.close();
          testsDone.countDown();
        }
      }
    }
);
    testsDone.await();
    assertTrue("node restarted rebalancing after recovering",restartedRebalancing.get());
    assertTrue("entries got set correctly",entriesCorrect.get());
    executorService.awaitTermination(15 * 60,TimeUnit.SECONDS);
  }
  finally {
    stopCluster(hostNames,ec2RebalancingTestConfig);
  }
}
