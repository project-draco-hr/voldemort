{
  assert(ec2RebalancingTestConfig.getInstanceCount() == 2);
  final Cluster targetCluster=expandCluster(0,ServerTestUtils.getLocalCluster(2,getPorts(2),new int[][]{{},{0,1,2,3}}));
  final SocketStoreClientFactory factory=getStoreClientFactory();
  final StoreClient<String,String> storeClient=getStoreClient(factory);
  final CountDownLatch startSignal=new CountDownLatch(1);
  final AtomicBoolean restartedRebalancing=new AtomicBoolean(false);
  final AtomicBoolean entriesCorrect=new AtomicBoolean(false);
  try {
    ExecutorService executorService=Executors.newFixedThreadPool(5);
    populateData(originalCluster,Arrays.asList(0));
    executorService.submit(new Runnable(){
      public void run(){
        RebalanceController rebalanceController=new RebalanceController(getBootstrapUrl(originalCluster,0),new RebalanceClientConfig());
        if (logger.isInfoEnabled())         logger.info("Starting rebalancing");
        rebalanceController.rebalance(targetCluster);
      }
    }
);
    executorService.submit(new Runnable(){
      public void run(){
        try {
          String hostname=originalCluster.getNodeById(1).getHost();
          if (logger.isInfoEnabled())           logger.info("Sleeping for a minute to get rebalancing into a half-way state");
          Thread.sleep(60 * 1000);
          stopClusterNode(hostname,ec2RebalancingTestConfig);
          startSignal.countDown();
          if (logger.isInfoEnabled())           logger.info("Killed node 1");
          Thread.sleep(5000);
          startClusterNode(hostname,ec2RebalancingTestConfig,1);
          if (logger.isInfoEnabled())           logger.info("Brought node 1 back up");
        }
 catch (        InterruptedException ie) {
          logger.error(ie);
          Thread.currentThread().interrupt();
        }
catch (        Exception e) {
          throw new IllegalStateException("unable to stop/start the host!",e);
        }
      }
    }
);
    executorService.submit(new Runnable(){
      public void run(){
        try {
          try {
            if (logger.isInfoEnabled())             logger.info("Waiting for the node to be brought down");
            startSignal.await();
            if (logger.isInfoEnabled())             logger.info("Waiting for five minutes for rebalancing to retry");
            Thread.sleep(5 * 60 * 1000);
            AdminClient adminClient=new AdminClient(getBootstrapUrl(originalCluster,0),new AdminClientConfig());
            Versioned<MetadataStore.VoldemortState> serverState=adminClient.getRemoteServerState(1);
            if (serverState.getValue() == MetadataStore.VoldemortState.REBALANCING_MASTER_SERVER) {
              restartedRebalancing.set(true);
              if (logger.isInfoEnabled())               logger.info("Recovered node began rebalancing, continuing with the test.");
              Thread.sleep(60 * 1000);
              try {
                for (                int nodeId : Arrays.asList(0,1)) {
                  List<Integer> availablePartitions=targetCluster.getNodeById(nodeId).getPartitionIds();
                  List<Integer> unavailablePartitions=getUnavailablePartitions(targetCluster,availablePartitions);
                  checkGetEntries(originalCluster.getNodeById(nodeId),targetCluster,unavailablePartitions,availablePartitions);
                }
                entriesCorrect.set(true);
              }
 catch (              AssertionFailedError afe) {
                logger.error(afe);
              }
            }
          }
 catch (          InterruptedException ie) {
            logger.error(ie);
            Thread.currentThread().interrupt();
          }
        }
  finally {
          factory.close();
        }
      }
    }
);
    executorService.shutdown();
    assertTrue("node restarted rebalancing after recovering",restartedRebalancing.get());
    assertTrue("entries got set correctly",entriesCorrect.get());
  }
  finally {
    stopCluster(hostNames,ec2RebalancingTestConfig);
  }
}
