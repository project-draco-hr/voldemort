{
  List<Node> nodes=new ArrayList<Node>(cluster.getNodes());
  Collections.shuffle(nodes,rand);
  Versioned<byte[]> versionedCopy=pipelineData.getVersionedCopy();
  List<Node> failedNodes=pipelineData.getFailedNodes();
  for (  Node failedNode : failedNodes) {
    int failedNodeId=failedNode.getId();
    if (versionedCopy == null) {
      VectorClock clock=(VectorClock)versioned.getVersion();
      versionedCopy=new Versioned<byte[]>(versioned.getValue(),clock.incremented(failedNodeId,time.getMilliseconds()));
    }
    if (logger.isTraceEnabled())     logger.trace("Performing hinted handoff for node " + failedNode + ", store "+ pipelineData.getStoreName()+ " key "+ key+ ", version "+ versionedCopy.getVersion());
    Slop slop=new Slop(pipelineData.getStoreName(),Slop.Operation.PUT,key,versionedCopy.getValue(),failedNodeId,new Date());
    Set<Node> used=new HashSet<Node>(nodes.size());
    boolean persisted=false;
    for (    Node node : nodes) {
      int nodeId=node.getId();
      Store<ByteArray,Slop> slopStore=slopStores.get(nodeId);
      if (!failedNodes.contains(node) && failureDetector.isAvailable(node)) {
        Utils.notNull(slopStore);
        long startNs=System.nanoTime();
        try {
          if (logger.isTraceEnabled())           logger.trace("Attempt to write " + slop.getKey() + " for "+ failedNode+ " to node "+ node);
          slopStore.put(slop.makeKey(),new Versioned<Slop>(slop,versionedCopy.getVersion()));
          persisted=true;
          failureDetector.recordSuccess(node,(System.nanoTime() - startNs) / Time.NS_PER_MS);
          used.add(node);
          if (logger.isTraceEnabled())           logger.trace("Finished hinted handoff for " + failedNode + " wrote slop to "+ node);
          break;
        }
 catch (        UnreachableStoreException e) {
          failureDetector.recordException(node,(System.nanoTime() - startNs) / Time.NS_PER_MS,e);
          logger.warn("Error during hinted handoff",e);
        }
      }
    }
    if (nodes.size() > used.size())     for (    Node usedNode : used)     nodes.remove(usedNode);
    Exception e=pipelineData.getFatalError();
    if (e != null) {
      if (persisted)       pipelineData.setFatalError(new UnreachableStoreException("Put operation failed on node " + failedNodeId + ", but has been persisted to slop storage for eventual replication.",e));
 else       pipelineData.setFatalError(new InsufficientOperationalNodesException("All slop servers are unavailable from node " + failedNodeId + ".",e));
    }
  }
  pipeline.addEvent(completeEvent);
}
