{
  ByteArray key=new ByteArray((byte)1);
  while (!Thread.currentThread().isInterrupted() && isRunning) {
    try {
      if (logger.isInfoEnabled()) {
        logger.info("Sleeping for " + getConfig().getNodeBannagePeriod() + " ms before checking node availability");
      }
      getConfig().getTime().sleep(getConfig().getNodeBannagePeriod());
    }
 catch (    InterruptedException e) {
      break;
    }
    Set<Node> unavailableNodesCopy=new HashSet<Node>();
synchronized (unavailableNodes) {
      unavailableNodesCopy.addAll(unavailableNodes);
    }
    for (    Node node : unavailableNodesCopy) {
      if (logger.isInfoEnabled())       logger.info("Checking previously unavailable node " + node);
      Store<ByteArray,byte[]> store=getConfig().getStore(node);
      if (store == null) {
        if (logger.isEnabledFor(Level.WARN))         logger.warn(node + " store is null; cannot determine node availability");
        continue;
      }
      try {
        store.get(key);
synchronized (unavailableNodes) {
          unavailableNodes.remove(node);
        }
        setAvailable(node);
        if (logger.isInfoEnabled())         logger.info(node + " now available");
      }
 catch (      UnreachableStoreException e) {
        if (logger.isEnabledFor(Level.WARN))         logger.warn(node + " still unavailable");
      }
catch (      Exception e) {
        if (logger.isEnabledFor(Level.ERROR))         logger.error(node + " unavailable due to error",e);
      }
    }
  }
}
