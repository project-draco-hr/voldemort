{
  List<NodeValue<ByteArray,byte[]>> nodeValues=Lists.newArrayListWithExpectedSize(pipelineData.getResponses().size());
  Map<Integer,Node> nodes=new HashMap<Integer,Node>();
  for (  Response<ByteArray,List<Versioned<byte[]>>> response : pipelineData.getResponses()) {
    List<Versioned<byte[]>> result=response.getValue();
    if (result.size() == 0) {
      nodeValues.add(new NodeValue<ByteArray,byte[]>(response.getNode().getId(),response.getKey(),new Versioned<byte[]>(null)));
    }
 else {
      for (      Versioned<byte[]> versioned : result)       nodeValues.add(new NodeValue<ByteArray,byte[]>(response.getNode().getId(),response.getKey(),versioned));
    }
    nodes.put(response.getNode().getId(),response.getNode());
  }
  if (nodeValues.size() > 1 && preferred > 1) {
    final List<NodeValue<ByteArray,byte[]>> toReadRepair=Lists.newArrayList();
    for (    NodeValue<ByteArray,byte[]> v : readRepairer.getRepairs(nodeValues)) {
      Versioned<byte[]> versioned=Versioned.value(v.getVersioned().getValue(),((VectorClock)v.getVersion()).clone());
      toReadRepair.add(new NodeValue<ByteArray,byte[]>(v.getNodeId(),v.getKey(),versioned));
    }
    for (    NodeValue<ByteArray,byte[]> v : toReadRepair) {
      try {
        if (logger.isDebugEnabled())         logger.debug("Doing read repair on node " + v.getNodeId() + " for key '"+ v.getKey()+ "' with version "+ v.getVersion()+ ".");
        Node node=nodes.get(v.getNodeId());
        NonblockingStore store=nonblockingStores.get(node.getId());
        NonblockingStoreCallback callback=new BasicResponseCallback<ByteArray>(pipeline,node,v.getKey());
        store.submitPutRequest(v.getKey(),v.getVersioned(),callback);
      }
 catch (      VoldemortApplicationException e) {
        if (logger.isDebugEnabled())         logger.debug("Read repair cancelled due to application level exception on node " + v.getNodeId() + " for key '"+ v.getKey()+ "' with version "+ v.getVersion()+ ": "+ e.getMessage());
      }
catch (      Exception e) {
        logger.debug("Read repair failed: ",e);
      }
    }
  }
  pipeline.addEvent(completeEvent);
}
