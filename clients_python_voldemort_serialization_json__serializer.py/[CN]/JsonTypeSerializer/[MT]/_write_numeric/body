def _write_numeric(self, output, n, typedef):
    '\n        Internal routine that writes numeric data. The individual _write_* methods are synthesized as\n        calls to this method.\n\n        >>> s = JsonTypeSerializer(\'"string"\')\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, 42, \'int8\')\n        >>> f.getvalue()\n        \'*\'\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, 42, \'int16\')\n        >>> f.getvalue()\n        \'\\x00*\'\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, 42, \'int32\')\n        >>> f.getvalue()\n        \'\\x00\\x00\\x00*\'\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, 42, \'int64\')\n        >>> f.getvalue()\n        \'\\x00\\x00\\x00\\x00\\x00\\x00\\x00*\'\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, 0.25, \'float32\')\n        >>> f.getvalue()\n        \'>\\x80\\x00\\x00\'\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, 0.25, \'float64\')\n        >>> f.getvalue()\n        \'?\\xd0\\x00\\x00\\x00\\x00\\x00\\x00\'\n\n        None is serialized to the minimum value for each type:\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, None, \'int8\')\n        >>> f.getvalue()\n        \'\\x80\'\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, None, \'int16\')\n        >>> f.getvalue()\n        \'\\x80\\x00\'\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, None, \'int32\')\n        >>> f.getvalue()\n        \'\\x80\\x00\\x00\\x00\'\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, None, \'int64\')\n        >>> f.getvalue()\n        \'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\'\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, None, \'float32\')\n        >>> f.getvalue()\n        \'\\x00\\x00\\x00\\x01\'\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, None, \'float64\')\n        >>> f.getvalue()\n        \'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\'\n\n        Basic typechecking is done:\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, 0.25, \'int16\')\n        Traceback (most recent call last):\n        ...\n        SerializationException: Invalid type: <type \'float\'> for typedef: int16\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, 42, \'float32\')\n        Traceback (most recent call last):\n        ...\n        SerializationException: Invalid type: <type \'int\'> for typedef: float32\n\n        Range checking is also done:\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, 500, \'int8\')\n        Traceback (most recent call last):\n        ...\n        SerializationException: Value 500 out of range for typedef: int8\n\n        >>> f = StringIO.StringIO()\n        >>> s._write_numeric(f, 1.0e-45, \'float32\')\n        Traceback (most recent call last):\n        ...\n        SerializationException: Value 1e-45 out of range for typedef: float32\n        '
    if ((not isinstance(typedef, str)) and (not isinstance(typedef, unicode))):
        raise SerializationException(('Typedef must be a str, got: %s' % type(typedef)))
    if (typedef not in set(['int8', 'int16', 'int32', 'int64', 'float32', 'float64'])):
        raise SerializationException(('Invalid typedef: %s' % typedef))
    if (n is None):
        n = MINS[typedef]
    else:
        if (not any((isinstance(n, t) for t in TYPES[typedef]))):
            raise SerializationException(('Invalid type: %s for typedef: %s' % (type(n), typedef)))
        if (not RANGE_FNS[typedef](n, typedef)):
            raise SerializationException(('Value %s out of range for typedef: %s' % (n, typedef)))
    output.write(struct.pack(FORMATS[typedef], n))
