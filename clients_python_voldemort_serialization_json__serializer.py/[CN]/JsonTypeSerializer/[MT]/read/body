def read(self, input):
    '\n        Reads a serialized object from the file-like object input:\n\n        >>> f = StringIO.StringIO(\'\\x00\\x00\\x00*\')\n        >>> s = JsonTypeSerializer(\'"int32"\')\n        >>> s.read(f)\n        42\n\n        >>> versioned = \'\\00\\x01>\\x80\\x00\\x00\\x00\\x03\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x03foo\'\n        >>> non_versioned = \'\\x01>\\x80\\x00\\x00\\x00\\x03\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x03foo\'\n\n        More complex types are also supported:\n        >>> s = JsonTypeSerializer(\'{ "a":"float32", "b":["int16"], "c":"string" }\')\n        >>> f = StringIO.StringIO(non_versioned)\n        >>> s.read(f) == {\'a\': 0.25, \'b\': [1, 2, 3], \'c\':u\'foo\'}\n        True\n\n        Non-versioned serializers can\'t read versioned binary representations:\n\n        >>> f = StringIO.StringIO(versioned)\n        >>> s.read(f)\n        Traceback (most recent call last):\n        ...\n        SerializationException: Unexpected end of input.\n\n        And vice-version, versioned serializers will only read versioned binary representations:\n\n        >>> s = JsonTypeSerializer(\'{ "a":"float32", "b":["int16"], "c":"string" }\', has_version=True)\n        >>> f = StringIO.StringIO(versioned)\n        >>> s.read(f) == {\'a\': 0.25, \'b\': [1, 2, 3], \'c\': u\'foo\'}\n        True\n\n        >>> f = StringIO.StringIO(non_versioned)\n        >>> s.read(f)\n        Traceback (most recent call last):\n        ...\n        KeyError: 1\n\n        The error messages from reading improperly versioned representations aren\'t super helpful...\n        '
    if self._has_version:
        version = self._read_int8(input)
        typedef = self._typedef[version]
    else:
        typedef = self._typedef
    return self._read(input, typedef)
