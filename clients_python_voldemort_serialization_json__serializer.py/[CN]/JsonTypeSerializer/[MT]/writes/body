def writes(self, obj):
    '\n        Returns a string representing the serialized binary representation of obj:\n\n        >>> s = JsonTypeSerializer(\'{ "a":"float32", "b":["int16"], "c":"string" }\')\n        >>> s.writes({\'a\': 0.25, \'b\':[1,2,3], \'c\':\'foo\'})\n        \'\\x01>\\x80\\x00\\x00\\x00\\x03\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x03foo\'\n\n        The representation of a versioned serializer will have the version number byte prefix:\n        >>> s = JsonTypeSerializer(\'{ "a":"float32", "b":["int16"], "c":"string" }\', has_version=True)\n        >>> s.writes({\'a\': 0.25, \'b\':[1,2,3], \'c\':\'foo\'})\n        \'\\x00\\x01>\\x80\\x00\\x00\\x00\\x03\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x03foo\'\n\n        reads() and writes() are more or less inverses of each other:\n\n        >>> s = JsonTypeSerializer(\'"int32"\')\n        >>> s.reads(s.writes(42))\n        42\n\n        Strings may be converted to unicodes:\n        >>> s = JsonTypeSerializer(\'"string"\')\n        >>> s.reads(s.writes(\'foo\'))\n        u\'foo\'\n\n        Dates may lose some precision:\n        >>> s = JsonTypeSerializer(\'"date"\')\n        >>> s.reads(s.writes(datetime.datetime(2010, 11, 24, 11, 50, 34, 237861)))\n        datetime.datetime(2010, 11, 24, 11, 50, 34, 237000)\n\n        Nested types also work:\n        >>> s = JsonTypeSerializer(\'{ "a":"float32", "b":["int16"], "c":"string" }\')\n        >>> s.reads(s.writes({\'a\': 0.25, \'b\':[1,2,3], \'c\':\'foo\'})) == {\'a\': 0.25, \'b\':[1,2,3], \'c\':u\'foo\'}\n        True\n        '
    sfile = StringIO.StringIO()
    self.write(sfile, obj)
    return sfile.getvalue()
