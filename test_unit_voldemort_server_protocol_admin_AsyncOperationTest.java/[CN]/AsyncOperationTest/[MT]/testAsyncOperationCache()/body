{
  Map<Integer,AsyncOperation> operations=Collections.synchronizedMap(new AsyncOperationCache(2));
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  AsyncOperation completeLater=new AsyncOperation(0,"test"){
    @Override public void stop(){
    }
    @Override public void operate(){
      try {
        Thread.sleep(1500);
        countDownLatch.countDown();
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }
;
  ExecutorService executorService=Executors.newFixedThreadPool(5);
  AsyncOperation completeNow=new AsyncOperation(1,"test 2"){
    @Override public void stop(){
    }
    @Override public void operate(){
    }
  }
;
  AsyncOperation completeSoon=new AsyncOperation(2,"test3"){
    @Override public void stop(){
    }
    @Override public void operate(){
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }
;
  executorService.submit(completeLater);
  executorService.submit(completeNow);
  executorService.submit(completeSoon);
  operations.put(0,completeLater);
  operations.put(1,completeNow);
  operations.put(2,completeSoon);
  assertTrue("Handles overflow okay",operations.containsKey(2));
  try {
    countDownLatch.await();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  for (int i=3; i < 10; i++) {
    AsyncOperation asyncOperation=new AsyncOperation(i,"test3"){
      @Override public void stop(){
      }
      @Override public void operate(){
        try {
          Thread.sleep(500);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      }
    }
;
    operations.put(i,asyncOperation);
  }
  assertFalse("Actually does LRU heuristics",operations.containsKey(0));
}
