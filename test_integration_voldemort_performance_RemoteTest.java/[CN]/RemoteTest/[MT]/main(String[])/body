{
  OptionParser parser=new OptionParser();
  parser.accepts("r","execute read operations");
  parser.accepts("w","execute write operations");
  parser.accepts("d","execute delete operations");
  parser.accepts("i","ignore null values");
  parser.accepts("v","verbose");
  parser.accepts("handshake","perform a handshake");
  parser.accepts("verify","verify values read");
  parser.accepts("request-file","execute specific requests in order").withRequiredArg();
  parser.accepts("start-key-index","starting point when using int keys. Default = 0").withRequiredArg().ofType(Integer.class);
  parser.accepts("value-size","size in bytes for random value.  Default = 1024").withRequiredArg().ofType(Integer.class);
  parser.accepts("iterations","number of times to repeat the test  Default = 1").withRequiredArg().ofType(Integer.class);
  parser.accepts("threads","max number concurrent worker threads  Default = " + MAX_WORKERS).withRequiredArg().ofType(Integer.class);
  OptionSet options=parser.parse(args);
  List<String> nonOptions=options.nonOptionArguments();
  if (nonOptions.size() != 3) {
    printUsage(System.err,parser);
  }
  String url=nonOptions.get(0);
  String storeName=nonOptions.get(1);
  int numRequests=Integer.parseInt(nonOptions.get(2));
  String ops="";
  List<Integer> keys=null;
  Integer startNum=CmdUtils.valueOf(options,"start-key-index",0);
  Integer valueSize=CmdUtils.valueOf(options,"value-size",1024);
  Integer numIterations=CmdUtils.valueOf(options,"iterations",1);
  Integer numThreads=CmdUtils.valueOf(options,"threads",MAX_WORKERS);
  final boolean verifyValues=options.has("verify");
  final boolean verbose=options.has("v");
  if (options.has("request-file")) {
    keys=loadKeys((String)options.valueOf("request-file"));
  }
  if (options.has("r")) {
    ops+="r";
  }
  if (options.has("w")) {
    ops+="w";
  }
  if (options.has("d")) {
    ops+="d";
  }
  if (ops.length() == 0) {
    ops="rwd";
  }
  System.out.println("operations : " + ops);
  System.out.println("value size : " + valueSize);
  System.out.println("start index : " + startNum);
  System.out.println("iterations : " + numIterations);
  System.out.println("threads : " + numThreads);
  System.out.println("Bootstraping cluster data.");
  ClientConfig clientConfig=new ClientConfig().setMaxThreads(numThreads).setMaxTotalConnections(numThreads).setMaxConnectionsPerNode(numThreads).setBootstrapUrls(url).setConnectionTimeout(60,TimeUnit.SECONDS).setSocketTimeout(60,TimeUnit.SECONDS).setSocketBufferSize(4 * 1024);
  StoreClientFactory factory=new SocketStoreClientFactory(clientConfig);
  final StoreClient<Object,Object> store=factory.getStoreClient(storeName);
  AdminClient adminClient=new AdminClient(url,new AdminClientConfig());
  List<StoreDefinition> storeDefinitionList=adminClient.getRemoteStoreDefList(0).getValue();
  StoreDefinition storeDef=null;
  for (  StoreDefinition storeDefinition : storeDefinitionList) {
    if (storeName.equals(storeDefinition.getName())) {
      storeDef=storeDefinition;
    }
  }
  Class<?> keyType=null;
  SerializerDefinition serializerDefinition=storeDef.getKeySerializer();
  if (serializerDefinition != null) {
    if ("string".equals(serializerDefinition.getName())) {
      keyType=String.class;
    }
 else     if ("json".equals(serializerDefinition.getName())) {
      if (serializerDefinition.getCurrentSchemaInfo().contains("int")) {
        keyType=Integer.class;
      }
 else       if (serializerDefinition.getCurrentSchemaInfo().contains("string")) {
        keyType=String.class;
      }
    }
 else     if ("identity".equals(serializerDefinition.getName())) {
      keyType=byte[].class;
    }
 else {
      throw new Exception("Can't determine key type for key serializer " + serializerDefinition.getName());
    }
  }
  final String value=TestUtils.randomLetters(valueSize);
  ExecutorService service=Executors.newFixedThreadPool(numThreads);
  if (options.has("handshake")) {
    final Object key=getKeyProvider(keyType,startNum,keys).next();
    store.delete(key);
    store.put(key,new Versioned<String>(value));
    store.delete(key);
  }
  for (int loopCount=0; loopCount < numIterations; loopCount++) {
    System.out.println("======================= iteration = " + loopCount + " ======================================");
    if (ops.contains("d")) {
      System.out.println("Beginning delete test.");
      final AtomicInteger successes=new AtomicInteger(0);
      final KeyProvider<?> keyProvider0=getKeyProvider(keyType,startNum,keys);
      final CountDownLatch latch0=new CountDownLatch(numRequests);
      long start=System.currentTimeMillis();
      for (int i=0; i < numRequests; i++) {
        service.execute(new Runnable(){
          public void run(){
            try {
              store.delete(keyProvider0.next());
              successes.getAndIncrement();
            }
 catch (            Exception e) {
              e.printStackTrace();
            }
 finally {
              latch0.countDown();
            }
          }
        }
);
      }
      latch0.await();
      long deleteTime=System.currentTimeMillis() - start;
      System.out.println("Throughput: " + (numRequests / (float)deleteTime * 1000) + " deletes/sec.");
      System.out.println(successes.get() + " things deleted.");
    }
    if (ops.contains("w")) {
      final AtomicInteger numWrites=new AtomicInteger(0);
      System.out.println("Beginning write test.");
      final KeyProvider<?> keyProvider1=getKeyProvider(keyType,startNum,keys);
      final CountDownLatch latch1=new CountDownLatch(numRequests);
      long start=System.currentTimeMillis();
      for (int i=0; i < numRequests; i++) {
        service.execute(new Runnable(){
          public void run(){
            try {
              Object key=keyProvider1.next();
              store.put(key,value);
              numWrites.incrementAndGet();
            }
 catch (            Exception e) {
              if (verbose) {
                e.printStackTrace();
              }
            }
 finally {
              latch1.countDown();
            }
          }
        }
);
      }
      latch1.await();
      long writeTime=System.currentTimeMillis() - start;
      System.out.println("Throughput: " + (numWrites.get() / (float)writeTime * 1000) + " writes/sec.");
    }
    if (ops.contains("r")) {
      final boolean ignoreNulls=options.has("i");
      final AtomicInteger numReads=new AtomicInteger(0);
      System.out.println("Beginning read test.");
      final KeyProvider<?> keyProvider2=getKeyProvider(keyType,startNum,keys);
      final CountDownLatch latch2=new CountDownLatch(numRequests);
      long start=System.currentTimeMillis();
      keyProvider2.next();
      for (int i=0; i < numRequests; i++) {
        service.execute(new Runnable(){
          public void run(){
            try {
              Object key=keyProvider2.next();
              Versioned<Object> v=store.get(key);
              numReads.incrementAndGet();
              if (v == null && !ignoreNulls) {
                throw new Exception("value returned is null for key " + key);
              }
              if (verifyValues) {
                if (!value.equals(v.getValue())) {
                  throw new Exception("value returned isn't same as set value for key " + key);
                }
              }
            }
 catch (            Exception e) {
              if (verbose) {
                e.printStackTrace();
              }
            }
 finally {
              latch2.countDown();
            }
          }
        }
);
      }
      latch2.await();
      long readTime=System.currentTimeMillis() - start;
      System.out.println("Throughput: " + (numReads.get() / (float)readTime * 1000.0) + " reads/sec.");
    }
  }
  System.exit(0);
}
