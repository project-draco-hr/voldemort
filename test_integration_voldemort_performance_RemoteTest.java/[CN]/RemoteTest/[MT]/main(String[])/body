{
  OptionParser parser=new OptionParser();
  parser.accepts("r","execute read operations").withOptionalArg();
  parser.accepts("w","execute write operations").withOptionalArg();
  parser.accepts("d","execute delete operations").withOptionalArg();
  parser.accepts("randomize","randomize operations via keys").withOptionalArg();
  parser.accepts("request-file","execute specific requests in order").withOptionalArg();
  parser.accepts("start-key-index","starting point when using int keys").withOptionalArg().ofType(Integer.class);
  parser.accepts("value-size","size in bytes for random value").withOptionalArg().ofType(Integer.class);
  OptionSet options=parser.parse(args);
  List<String> nonOptions=options.nonOptionArguments();
  if (nonOptions.size() != 3) {
    printUsage(System.err,parser);
  }
  String url=nonOptions.get(0);
  String storeName=nonOptions.get(1);
  int numRequests=Integer.parseInt(nonOptions.get(2));
  String ops="";
  List<String> keys=null;
  Integer startNum=CmdUtils.valueOf(options,"start-key-index",0);
  Integer valueSize=CmdUtils.valueOf(options,"value-size",1024);
  if (options.has("request-file")) {
    keys=loadKeys((String)options.valueOf("request-file"));
  }
  if (options.has("r")) {
    ops+="r";
  }
  if (options.has("w")) {
    ops+="w";
  }
  if (options.has("d")) {
    ops+="d";
  }
  if (ops.length() == 0) {
    ops="rwd";
  }
  System.err.println("Bootstraping cluster data.");
  StoreClientFactory factory=new SocketStoreClientFactory(new ClientConfig().setMaxThreads(20).setMaxConnectionsPerNode(MAX_WORKERS).setBootstrapUrls(url));
  final StoreClient<String,String> store=factory.getStoreClient(storeName);
  final String value=new String(TestUtils.randomBytes(valueSize));
  ExecutorService service=Executors.newFixedThreadPool(MAX_WORKERS);
  if (ops.contains("d")) {
    System.err.println("Beginning delete test.");
    final AtomicInteger successes=new AtomicInteger(0);
    final KeyProvider keyProvider0=new KeyProvider(startNum,keys);
    final CountDownLatch latch0=new CountDownLatch(numRequests);
    long start=System.currentTimeMillis();
    for (int i=0; i < numRequests; i++) {
      service.execute(new Runnable(){
        public void run(){
          try {
            store.delete(keyProvider0.next());
            successes.getAndIncrement();
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
 finally {
            latch0.countDown();
          }
        }
      }
);
    }
    latch0.await();
    long deleteTime=System.currentTimeMillis() - start;
    System.out.println("Throughput: " + (numRequests / (float)deleteTime * 1000) + " deletes/sec.");
    System.out.println(successes.get() + " things deleted.");
  }
  if (ops.contains("w")) {
    System.err.println("Beginning write test.");
    final KeyProvider keyProvider1=new KeyProvider(startNum,keys);
    final CountDownLatch latch1=new CountDownLatch(numRequests);
    long start=System.currentTimeMillis();
    for (int i=0; i < numRequests; i++) {
      service.execute(new Runnable(){
        public void run(){
          try {
            store.put(keyProvider1.next(),new Versioned<String>(value));
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
 finally {
            latch1.countDown();
          }
        }
      }
);
    }
    latch1.await();
    long writeTime=System.currentTimeMillis() - start;
    System.out.println("Throughput: " + (numRequests / (float)writeTime * 1000) + " writes/sec.");
  }
  if (ops.contains("r")) {
    System.err.println("Beginning read test.");
    final KeyProvider keyProvider2=new KeyProvider(startNum,keys);
    final CountDownLatch latch2=new CountDownLatch(numRequests);
    long start=System.currentTimeMillis();
    for (int i=0; i < numRequests; i++) {
      service.execute(new Runnable(){
        public void run(){
          try {
            store.get(keyProvider2.next());
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
 finally {
            latch2.countDown();
          }
        }
      }
);
    }
    latch2.await();
    long readTime=System.currentTimeMillis() - start;
    System.out.println("Throughput: " + (numRequests / (float)readTime * 1000.0) + " reads/sec.");
  }
  System.exit(0);
}
