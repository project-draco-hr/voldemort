{
  Map<Integer,Future<String>> fetchDirs=new HashMap<Integer,Future<String>>();
  for (  final Node node : cluster.getNodes()) {
    fetchDirs.put(node.getId(),executor.submit(new Callable<String>(){
      public String call() throws Exception {
        String url=node.getHttpUrl() + "/" + readOnlyMgmtPath;
        HttpPost post=new HttpPost(url);
        List<NameValuePair> params=new ArrayList<NameValuePair>();
        params.add(new BasicNameValuePair("operation","fetch"));
        String storeDir=basePath + "/node-" + node.getId();
        params.add(new BasicNameValuePair("dir",storeDir));
        params.add(new BasicNameValuePair("store",storeName));
        if (pushVersion > 0)         params.add(new BasicNameValuePair("pushVersion",Long.toString(pushVersion)));
        post.setEntity(new UrlEncodedFormEntity(params));
        logger.info("Invoking fetch for node " + node.getId() + " for "+ storeDir);
        HttpResponse httpResponse=null;
        try {
          httpResponse=httpClient.execute(post);
          int responseCode=httpResponse.getStatusLine().getStatusCode();
          InputStream is=httpResponse.getEntity().getContent();
          String response=VoldemortIOUtils.toString(is,30000);
          if (responseCode != HttpURLConnection.HTTP_OK)           throw new VoldemortException("Fetch request on node " + node.getId() + " ("+ url+ ") failed: "+ httpResponse.getStatusLine().getReasonPhrase());
          logger.info("Fetch succeeded on node " + node.getId());
          return response.trim();
        }
  finally {
          VoldemortIOUtils.closeQuietly(httpResponse);
        }
      }
    }
));
  }
  TreeMap<Integer,String> results=Maps.newTreeMap();
  HashMap<Integer,Exception> exceptions=Maps.newHashMap();
  for (int nodeId=0; nodeId < cluster.getNumberOfNodes(); nodeId++) {
    Future<String> val=fetchDirs.get(nodeId);
    try {
      results.put(nodeId,val.get());
    }
 catch (    Exception e) {
      exceptions.put(nodeId,new VoldemortException(e));
    }
  }
  if (!exceptions.isEmpty()) {
    if (deleteFailedFetch) {
      for (      int successfulNodeId : results.keySet()) {
        HttpResponse httpResponse=null;
        try {
          String url=cluster.getNodeById(successfulNodeId).getHttpUrl() + "/" + readOnlyMgmtPath;
          HttpPost post=new HttpPost(url);
          List<NameValuePair> params=new ArrayList<NameValuePair>();
          params.add(new BasicNameValuePair("operation","failed-fetch"));
          params.add(new BasicNameValuePair("dir",results.get(successfulNodeId)));
          params.add(new BasicNameValuePair("store",storeName));
          post.setEntity(new UrlEncodedFormEntity(params));
          logger.info("Deleting fetched data from node " + successfulNodeId);
          httpResponse=httpClient.execute(post);
          int responseCode=httpResponse.getStatusLine().getStatusCode();
          String response=httpResponse.getStatusLine().getReasonPhrase();
          if (responseCode == 200) {
            logger.info("Deleted successfully on node " + successfulNodeId);
          }
 else {
            throw new VoldemortException(response);
          }
        }
 catch (        Exception e) {
          logger.error("Exception thrown during delete operation on node " + successfulNodeId + " : ",e);
        }
 finally {
          VoldemortIOUtils.closeQuietly(httpResponse);
        }
      }
    }
    for (    int failedNodeId : exceptions.keySet()) {
      logger.error("Error on node " + failedNodeId + " during push : ",exceptions.get(failedNodeId));
    }
    throw new VoldemortException("Exception during pushes to nodes " + Joiner.on(",").join(exceptions.keySet()) + " failed");
  }
  return Lists.newArrayList(results.values());
}
