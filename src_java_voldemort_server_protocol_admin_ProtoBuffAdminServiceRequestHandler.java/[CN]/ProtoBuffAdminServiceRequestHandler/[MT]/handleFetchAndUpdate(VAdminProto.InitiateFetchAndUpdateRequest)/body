{
  final int nodeId=request.getNodeId();
  final List<Integer> partitions=request.getPartitionsList();
  final VoldemortFilter filter=request.hasFilter() ? getFilterFromRequest(request.getFilter()) : new DefaultVoldemortFilter();
  final String storeName=request.getStore();
  int requestId=asyncRunner.getUniqueRequestId();
  VAdminProto.AsyncOperationStatusResponse.Builder response=VAdminProto.AsyncOperationStatusResponse.newBuilder().setRequestId(requestId).setComplete(false).setDescription("Fetch and update").setStatus("started");
  try {
    asyncRunner.submitOperation(requestId,new AsyncOperation(requestId,"Fetch and Update"){
      @Override public void operate(){
        AdminClient adminClient=RebalanceUtils.createTempAdminClient(voldemortConfig,metadataStore.getCluster());
        try {
          StorageEngine<ByteArray,byte[]> storageEngine=getStorageEngine(storeName);
          Iterator<Pair<ByteArray,Versioned<byte[]>>> entriesIterator=adminClient.fetchPartitionEntries(nodeId,storeName,partitions,filter);
          updateStatus("Initated fetchPartitionEntries");
          EventThrottler throttler=new EventThrottler(voldemortConfig.getStreamMaxWriteBytesPerSec());
          for (long i=0; entriesIterator.hasNext(); i++) {
            Pair<ByteArray,Versioned<byte[]>> entry=entriesIterator.next();
            storageEngine.put(entry.getFirst(),entry.getSecond());
            throttler.maybeThrottle(entrySize(entry));
            if ((i % 1000) == 0) {
              updateStatus(i + " entries processed");
            }
          }
        }
  finally {
          adminClient.stop();
        }
      }
    }
);
  }
 catch (  VoldemortException e) {
    response.setError(ProtoUtils.encodeError(errorCodeMapper,e));
    logger.error("handleFetchAndUpdate failed for request(" + request.toString() + ")",e);
  }
  return response.build();
}
