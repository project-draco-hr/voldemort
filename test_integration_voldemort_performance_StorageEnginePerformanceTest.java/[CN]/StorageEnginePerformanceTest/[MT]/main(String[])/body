{
  OptionParser parser=new OptionParser();
  parser.accepts("help","print usage information");
  parser.accepts("requests","[REQUIRED] number of requests to execute").withRequiredArg().ofType(Integer.class);
  parser.accepts("num-values","[REQUIRED] number of values in the store").withRequiredArg().ofType(Integer.class);
  parser.accepts("data-dir","Data directory for storage data").withRequiredArg().describedAs("directory");
  parser.accepts("threads","number of threads").withRequiredArg().ofType(Integer.class);
  parser.accepts("storage-configuration-class","[REQUIRED] class of the storage engine configuration to use [e.g. voldemort.store.bdb.BdbStorageConfiguration]").withRequiredArg().describedAs("class_name");
  parser.accepts("props","Properties file with configuration for the engine");
  parser.accepts("value-size","The size of the values in the store").withRequiredArg().describedAs("size").ofType(Integer.class);
  parser.accepts("cache-width","Percentage of requests to save as possible re-requests").withRequiredArg();
  parser.accepts("cache-hit-ratio","Percentage of requests coming from the last cache-width requests").withRequiredArg().ofType(Double.class);
  OptionSet options=parser.parse(args);
  if (options.has("help")) {
    parser.printHelpOn(System.out);
    System.exit(0);
  }
  CmdUtils.croakIfMissing(parser,options,"requests");
  final int numThreads=CmdUtils.valueOf(options,"threads",10);
  final int numRequests=(Integer)options.valueOf("requests");
  final int numValues=(Integer)options.valueOf("num-values");
  final int valueSize=CmdUtils.valueOf(options,"value-size",1024);
  final int cacheWidth=CmdUtils.valueOf(options,"cache-width",100000);
  final double cacheHitRatio=CmdUtils.valueOf(options,"cache-hit-ratio",0.5);
  final String propsFile=(String)options.valueOf("props");
  final String storageEngineClass=CmdUtils.valueOf(options,"storage-configuration-class",BdbStorageConfiguration.class.getName()).trim();
  File dataDir=null;
  if (options.has("data-dir"))   dataDir=new File((String)options.valueOf("data-dir"));
 else   dataDir=TestUtils.createTempDir();
  Props props=new Props();
  if (propsFile != null)   props=new Props(new File(propsFile));
  props.put("node.id",0);
  props.put("data.dir",dataDir.getAbsolutePath());
  props.put("voldemort.home",System.getProperty("user.dir"));
  VoldemortConfig config=new VoldemortConfig(props);
  StorageConfiguration storageConfig=(StorageConfiguration)ReflectUtils.callConstructor(ReflectUtils.loadClass(storageEngineClass),new Object[]{config});
  StorageEngine<ByteArray,byte[]> engine=storageConfig.getStore("test");
  @SuppressWarnings("unchecked") final Store<String,byte[]> store=new SerializingStore(engine,new StringSerializer(),new IdentitySerializer());
  final byte[] value=new byte[valueSize];
  new Random().nextBytes(value);
  for (int i=0; i < numValues; i++)   store.put(Integer.toString(i),Versioned.value(value));
  int[] recents=new int[cacheWidth];
  CachedPerformanceTest writeTest=new CachedPerformanceTest(new PerformanceTest(){
    @Override public void doOperation(    int index){
      store.put(Integer.toString(index),Versioned.value(value));
    }
  }
,recents,numValues,cacheHitRatio);
  writeTest.run(numRequests,numThreads);
  writeTest.printStats();
  CachedPerformanceTest readTest=new CachedPerformanceTest(new PerformanceTest(){
    @Override public void doOperation(    int index){
      store.get(Integer.toString(index));
    }
  }
,recents,numValues,cacheHitRatio);
  readTest.run(numRequests,numThreads);
  readTest.printStats();
}
