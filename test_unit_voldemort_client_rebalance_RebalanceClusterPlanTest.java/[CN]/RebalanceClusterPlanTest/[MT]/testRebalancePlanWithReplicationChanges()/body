{
  int numServers=4;
  int ports[]=ServerTestUtils.findFreePorts(3 * numServers);
  currentCluster=ServerTestUtils.getLocalCluster(numServers,ports,new int[][]{{0,1,2,3},{4,5,6},{7,8,9},{}});
  targetCluster=ServerTestUtils.getLocalCluster(numServers,ports,new int[][]{{0,2,3},{4,6},{7,8,9},{1,5}});
  List<RebalancePartitionsInfo> orderedRebalancePartitionInfoList=getExecutableTasks(currentCluster,targetCluster,storeDefList);
  assertEquals("There should have exactly 3 rebalancing node",3,this.getUniqueNodeCount(orderedRebalancePartitionInfoList,false));
  assertEquals("There should have exactly 5 rebalancing partition info",5,orderedRebalancePartitionInfoList.size());
  assertEquals("Stealer 3 should have 3 entry",3,this.getStealerNodePartitionInfoCount(3,orderedRebalancePartitionInfoList));
  assertEquals("Stealer 0 should have 1 entry",1,this.getStealerNodePartitionInfoCount(0,orderedRebalancePartitionInfoList));
  assertEquals("Stealer 1 should have 1 entry",1,this.getStealerNodePartitionInfoCount(1,orderedRebalancePartitionInfoList));
  HashMap<String,HashMap<Integer,List<Integer>>> storeToPartitionsToMove[]=new HashMap[5];
  for (int numPlan=0; numPlan < 5; numPlan++) {
    storeToPartitionsToMove[numPlan]=new HashMap<String,HashMap<Integer,List<Integer>>>();
  }
  for (  StoreDefinition storeDef : storeDefList) {
    if (storeDef.getReplicationFactor() == 2) {
      HashMap<Integer,List<Integer>> partitions=Maps.newHashMap();
      partitions.put(0,Lists.newArrayList(1));
      storeToPartitionsToMove[0].put(storeDef.getName(),partitions);
      partitions=Maps.newHashMap();
      partitions.put(0,Lists.newArrayList(5));
      partitions.put(1,Lists.newArrayList(0));
      storeToPartitionsToMove[1].put(storeDef.getName(),partitions);
      partitions=Maps.newHashMap();
      partitions.put(1,Lists.newArrayList(4));
      storeToPartitionsToMove[2].put(storeDef.getName(),partitions);
      partitions=Maps.newHashMap();
      partitions.put(1,Lists.newArrayList(1));
      storeToPartitionsToMove[3].put(storeDef.getName(),partitions);
      partitions=Maps.newHashMap();
      partitions.put(1,Lists.newArrayList(5));
      storeToPartitionsToMove[4].put(storeDef.getName(),partitions);
    }
 else     if (storeDef.getReplicationFactor() == 1) {
      HashMap<Integer,List<Integer>> partitions=Maps.newHashMap();
      partitions.put(0,Lists.newArrayList(1));
      storeToPartitionsToMove[0].put(storeDef.getName(),partitions);
      partitions=Maps.newHashMap();
      partitions.put(0,Lists.newArrayList(5));
      storeToPartitionsToMove[1].put(storeDef.getName(),partitions);
    }
 else {
      throw new VoldemortException("Change in store definitions file found");
    }
  }
  checkAllRebalanceInfoPresent(getStealerNodePartitionInfoList(3,orderedRebalancePartitionInfoList),Arrays.asList(new RebalancePartitionsInfo(3,0,storeToPartitionsToMove[0],currentCluster),new RebalancePartitionsInfo(3,1,storeToPartitionsToMove[1],currentCluster),new RebalancePartitionsInfo(3,2,storeToPartitionsToMove[2],currentCluster)));
  checkAllRebalanceInfoPresent(getStealerNodePartitionInfoList(0,orderedRebalancePartitionInfoList),Arrays.asList(new RebalancePartitionsInfo(0,1,storeToPartitionsToMove[3],currentCluster)));
  checkAllRebalanceInfoPresent(getStealerNodePartitionInfoList(1,orderedRebalancePartitionInfoList),Arrays.asList(new RebalancePartitionsInfo(1,2,storeToPartitionsToMove[4],currentCluster)));
}
