{
  if (!acquireRebalancingPermit()) {
    RebalancePartitionsInfo info=metadataStore.getRebalancingStealInfo();
    throw new AlreadyRebalancingException("Node " + metadataStore.getCluster().getNodeById(info.getStealerId()) + " is already rebalancing from "+ info.getDonorId()+ " rebalanceInfo:"+ info);
  }
  checkCurrentState(metadataStore,stealInfo);
  setRebalancingState(metadataStore,stealInfo);
  int requestId=asyncRunner.getUniqueRequestId();
  asyncRunner.submitOperation(requestId,new AsyncOperation(requestId,stealInfo.toString()){
    private int migratePartitionsAsyncId=-1;
    private String currentStore=null;
    AdminClient adminClient=null;
    volatile boolean forceStop=false;
    @Override public void operate() throws Exception {
      adminClient=RebalanceUtils.createTempAdminClient(voldemortConfig,metadataStore.getCluster());
      List<Exception> failures=new ArrayList<Exception>();
      try {
        logger.info("Rebalancer: rebalance " + stealInfo + " starting.");
        List<String> tempUnbalancedStoreList=new ArrayList<String>(stealInfo.getUnbalancedStoreList());
        for (        String storeName : ImmutableList.copyOf(stealInfo.getUnbalancedStoreList())) {
          if (forceStop) {
            logger.info("Stopping rebalancing Operation cleanly as stop() was called.");
            metadataStore.cleanAllRebalancingState();
            return;
          }
          try {
            rebalanceStore(storeName,adminClient,stealInfo);
            tempUnbalancedStoreList.remove(storeName);
            stealInfo.setUnbalancedStoreList(tempUnbalancedStoreList);
          }
 catch (          Exception e) {
            logger.error("rebalanceSubTask:" + stealInfo + " failed for store:"+ storeName,e);
            failures.add(e);
          }
        }
        if (stealInfo.getUnbalancedStoreList().isEmpty()) {
          logger.info("Rebalancer: rebalance " + stealInfo + " completed successfully.");
          metadataStore.cleanAllRebalancingState();
        }
 else {
          throw new VoldemortRebalancingException("Rebalancer: Failed to rebalance completely, unbalanced stores:" + stealInfo.getUnbalancedStoreList() + " rebalanceInfo:"+ stealInfo,failures);
        }
      }
  finally {
        releaseRebalancingPermit();
        adminClient.stop();
        adminClient=null;
        migratePartitionsAsyncId=-1;
      }
    }
    @Override public void stop(){
      updateStatus("stop() called on rebalance operation !!");
      if (null != adminClient && -1 != migratePartitionsAsyncId) {
        adminClient.stopAsyncRequest(metadataStore.getNodeId(),migratePartitionsAsyncId);
      }
      forceStop=true;
    }
    private void rebalanceStore(    String storeName,    AdminClient adminClient,    RebalancePartitionsInfo stealInfo) throws Exception {
      updateStatus("starting partitions migration for store:" + storeName);
      currentStore=storeName;
      migratePartitionsAsyncId=adminClient.migratePartitions(stealInfo.getDonorId(),metadataStore.getNodeId(),storeName,stealInfo.getPartitionList(),null);
      adminClient.waitForCompletion(metadataStore.getNodeId(),migratePartitionsAsyncId,voldemortConfig.getAdminSocketTimeout(),TimeUnit.SECONDS);
      if (stealInfo.isDeleteDonorPartitions()) {
        logger.warn("Deleting data from donorNode after rebalancing !!");
        adminClient.deletePartitions(stealInfo.getDonorId(),storeName,stealInfo.getPartitionList(),null);
        logger.info("Deleted partitions " + stealInfo.getPartitionList() + " from donorNode:"+ stealInfo.getDonorId());
      }
      updateStatus("partitions migration for store:" + storeName + " completed.");
      migratePartitionsAsyncId=-1;
      currentStore=null;
    }
    @Override @JmxGetter(name="asyncTaskStatus") public AsyncOperationStatus getStatus(){
      if (-1 != migratePartitionsAsyncId && null != currentStore)       try {
        updateStatus("partitions migration for store:" + currentStore + " status:"+ asyncRunner.getStatus(migratePartitionsAsyncId));
      }
 catch (      Exception e) {
      }
      return super.getStatus();
    }
  }
);
  return requestId;
}
