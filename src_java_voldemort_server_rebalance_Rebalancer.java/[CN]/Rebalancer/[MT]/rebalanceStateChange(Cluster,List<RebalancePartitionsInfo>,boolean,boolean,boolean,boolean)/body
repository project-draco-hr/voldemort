{
  Cluster currentCluster=metadataStore.getCluster();
  logger.info("Server doing rebalance state change with options [ cluster metadata change - " + changeClusterMetadata + " ], [ changing rebalancing state - "+ changeRebalanceState+ " ], [ changing swapping RO - "+ swapRO+ " ], [ rollback - "+ rollback+ " ]");
  List<RebalancePartitionsInfo> completedRebalancePartitionsInfo=Lists.newArrayList();
  List<String> swappedStoreNames=Lists.newArrayList();
  boolean completedClusterChange=false;
  boolean completedRebalanceSourceClusterChange=false;
  Cluster previousRebalancingSourceCluster=null;
  try {
    if (changeClusterMetadata) {
      logger.info("Switching metadata from " + currentCluster + " to "+ cluster);
      changeCluster(MetadataStore.CLUSTER_KEY,cluster);
      completedClusterChange=true;
    }
    if (swapRO) {
      swapROStores(swappedStoreNames,false);
    }
    if (changeRebalanceState) {
      try {
        previousRebalancingSourceCluster=metadataStore.getRebalancingSourceCluster();
        if (!rollback) {
          changeCluster(MetadataStore.REBALANCING_SOURCE_CLUSTER_XML,currentCluster);
          completedRebalanceSourceClusterChange=true;
          for (          RebalancePartitionsInfo info : rebalancePartitionsInfo) {
            metadataStore.addRebalancingState(info);
            completedRebalancePartitionsInfo.add(info);
          }
        }
 else {
          changeCluster(MetadataStore.REBALANCING_SOURCE_CLUSTER_XML,null);
          completedRebalanceSourceClusterChange=true;
          for (          RebalancePartitionsInfo info : rebalancePartitionsInfo) {
            metadataStore.deleteRebalancingState(info);
            completedRebalancePartitionsInfo.add(info);
          }
        }
      }
 catch (      Exception e) {
        throw new VoldemortException(e);
      }
    }
  }
 catch (  VoldemortException e) {
    logger.error("Got exception while changing state, now rolling back changes",e);
    if (completedClusterChange) {
      try {
        logger.info("Rolling back cluster.xml to " + currentCluster);
        changeCluster(MetadataStore.CLUSTER_KEY,currentCluster);
      }
 catch (      Exception exception) {
        logger.error("Error while rolling back cluster metadata to " + currentCluster,exception);
      }
    }
    if (swappedStoreNames.size() > 0) {
      try {
        swapROStores(swappedStoreNames,true);
      }
 catch (      Exception exception) {
        logger.error("Error while swapping back to old state ",exception);
      }
    }
    if (completedRebalancePartitionsInfo.size() > 0) {
      if (!rollback) {
        for (        RebalancePartitionsInfo info : completedRebalancePartitionsInfo) {
          try {
            metadataStore.deleteRebalancingState(info);
          }
 catch (          Exception exception) {
            logger.error("Error while deleting back rebalance info during error rollback " + info,exception);
          }
        }
      }
 else {
        for (        RebalancePartitionsInfo info : completedRebalancePartitionsInfo) {
          try {
            metadataStore.addRebalancingState(info);
          }
 catch (          Exception exception) {
            logger.error("Error while adding back rebalance info during error rollback " + info,exception);
          }
        }
      }
    }
    if (completedRebalanceSourceClusterChange) {
      logger.info("Reverting the REBALANCING_SOURCE_CLUSTER_XML back to " + previousRebalancingSourceCluster);
      changeCluster(MetadataStore.REBALANCING_SOURCE_CLUSTER_XML,previousRebalancingSourceCluster);
    }
    throw e;
  }
}
