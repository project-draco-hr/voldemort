{
  logger.debug("rebalancer run() called.");
  VoldemortState voldemortState;
  RebalancerState rebalancerState;
  metadataStore.readLock.lock();
  try {
    voldemortState=metadataStore.getServerState();
    rebalancerState=metadataStore.getRebalancerState();
  }
 catch (  Exception e) {
    logger.error("Error determining state",e);
    return;
  }
 finally {
    metadataStore.readLock.unlock();
  }
  final ConcurrentHashMap<Integer,Map<String,String>> nodeIdsToStoreDirs=new ConcurrentHashMap<Integer,Map<String,String>>();
  final List<Exception> failures=new ArrayList<Exception>();
  if (VoldemortState.REBALANCING_MASTER_SERVER.equals(voldemortState) && acquireRebalancingPermit(metadataStore.getNodeId())) {
    releaseRebalancingPermit(metadataStore.getNodeId());
    for (    final RebalancePartitionsInfoLiveCycle stealInfoLiveCycle : rebalancerState.getAll()) {
      final RebalancePartitionsInfo stealInfo=stealInfoLiveCycle.getRebalancePartitionsInfo();
      if (acquireRebalancingPermit(stealInfo.getDonorId())) {
        releaseRebalancingPermit(stealInfo.getDonorId());
        try {
          logger.warn("Rebalance server found incomplete rebalancing attempt, restarting rebalancing task " + stealInfo);
          if (stealInfo.getAttempt() < voldemortConfig.getMaxRebalancingAttempt()) {
            attemptRebalance(stealInfoLiveCycle);
            nodeIdsToStoreDirs.put(stealInfo.getDonorId(),stealInfo.getDonorNodeROStoreToDir());
            nodeIdsToStoreDirs.put(stealInfo.getStealerId(),stealInfo.getStealerNodeROStoreToDir());
          }
 else {
            logger.warn("Rebalancing for rebalancing task " + stealInfo + " failed multiple times (max. attemps:"+ voldemortConfig.getMaxRebalancingAttempt()+ "), Aborting more trials.");
            metadataStore.cleanRebalancingState(stealInfo);
          }
        }
 catch (        Exception e) {
          logger.error("RebalanceService rebalancing attempt " + stealInfo + " failed with exception - "+ e.getMessage(),e);
          failures.add(e);
        }
      }
    }
    if (failures.size() == 0 && nodeIdsToStoreDirs.size() > 0) {
      ExecutorService swapExecutors=RebalanceUtils.createExecutors(nodeIdsToStoreDirs.size());
      for (      final Integer nodeId : nodeIdsToStoreDirs.keySet()) {
        swapExecutors.submit(new Runnable(){
          public void run(){
            Map<String,String> storeDirs=nodeIdsToStoreDirs.get(nodeId);
            AdminClient adminClient=RebalanceUtils.createTempAdminClient(voldemortConfig,metadataStore.getCluster(),4,2);
            try {
              logger.info("Swapping read-only stores on node " + nodeId);
              adminClient.swapStoresAndCleanState(nodeId,storeDirs);
              logger.info("Successfully swapped on node " + nodeId);
            }
 catch (            Exception e) {
              logger.error("Failed swapping on node " + nodeId,e);
            }
 finally {
              adminClient.stop();
            }
          }
        }
);
      }
      try {
        RebalanceUtils.executorShutDown(swapExecutors,voldemortConfig.getRebalancingTimeout());
      }
 catch (      Exception e) {
        logger.error("Interrupted swapping executor - " + e.getMessage(),e);
        return;
      }
    }
  }
}
