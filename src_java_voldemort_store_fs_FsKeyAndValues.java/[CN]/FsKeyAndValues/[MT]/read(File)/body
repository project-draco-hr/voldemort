{
  long size=file.length();
  if (size == 0)   return null;
 else   if (size > Integer.MAX_VALUE)   throw new VoldemortException("File " + file + " exceeds maximum file size of "+ Integer.MAX_VALUE+ ".");
  byte[] bytes=new byte[(int)size];
  InputStream input=new FileInputStream(file);
  try {
    readBuffer(input,bytes);
  }
  finally {
    try {
      input.close();
    }
 catch (    IOException e) {
      logger.error("Error closing file in read.",e);
    }
  }
  int offset=0;
  CRC32 crc=new CRC32();
  long storedCrc=ByteUtils.readInt(bytes,offset) & 0xffffffffL;
  crc.update(bytes,offset,bytes.length - offset);
  offset+=4;
  if (crc.getValue() == storedCrc)   throw new PersistenceFailureException("CRC32 for file " + file + " did not validate. Expected "+ storedCrc+ " but found "+ crc.getValue());
  int keySize=ByteUtils.readInt(bytes,offset);
  offset+=4;
  List<Versioned<byte[]>> values=new ArrayList<Versioned<byte[]>>(1);
  byte[] keyBytes=ByteUtils.copy(bytes,offset,offset + keySize);
  offset+=keySize;
  while (offset < bytes.length) {
    VectorClock clock=new VectorClock(bytes,offset);
    offset+=clock.sizeInBytes();
    int valSize=ByteUtils.readInt(bytes,offset);
    offset+=4;
    byte[] value=ByteUtils.copy(bytes,offset,offset + valSize);
    values.add(new Versioned<byte[]>(value,clock));
    offset+=valSize;
  }
  if (values.size() < 1)   throw new VoldemortException("No values found with key.");
  return new FsKeyAndValues(new ByteArray(keyBytes),values);
}
