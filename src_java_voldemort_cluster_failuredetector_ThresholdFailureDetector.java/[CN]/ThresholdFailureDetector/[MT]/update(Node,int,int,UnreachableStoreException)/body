{
  ThresholdNodeStatus nodeStatus=(ThresholdNodeStatus)getNodeStatus(node);
  boolean needsNotifyAvailable=false;
  boolean needsNotifyUnavailable=false;
  long threshold=0;
  boolean isAvailable=false;
synchronized (nodeStatus) {
    nodeStatus.setLastChecked(getConfig().getTime().getMilliseconds());
    if (nodeStatus.lastChecked >= nodeStatus.startMillis + getConfig().getThresholdInterval()) {
      needsNotifyAvailable=!nodeStatus.isAvailable;
      nodeStatus.isAvailable=true;
      nodeStatus.startMillis=nodeStatus.lastChecked;
      nodeStatus.success=successDelta;
      nodeStatus.total=totalDelta;
    }
 else {
      nodeStatus.success+=successDelta;
      nodeStatus.total+=totalDelta;
    }
    int thresholdCountMinimum=getConfig().getThresholdCountMinimum();
    if (nodeStatus.total >= thresholdCountMinimum) {
      threshold=nodeStatus.total >= thresholdCountMinimum ? (nodeStatus.success * 100) / nodeStatus.total : 100;
      boolean previouslyAvailable=nodeStatus.isAvailable;
      nodeStatus.isAvailable=threshold >= getConfig().getThreshold();
      if (nodeStatus.isAvailable && !previouslyAvailable)       needsNotifyAvailable=true;
 else       if (!nodeStatus.isAvailable && previouslyAvailable)       needsNotifyUnavailable=true;
    }
    isAvailable=nodeStatus.isAvailable;
  }
  if (needsNotifyAvailable) {
    if (logger.isInfoEnabled())     logger.info("Threshold for node " + node.getId() + " at "+ node.getHost()+ " now "+ threshold+ "%; marking as available");
    notifyAvailable(node);
  }
 else   if (needsNotifyUnavailable) {
    if (logger.isEnabledFor(Level.WARN))     logger.warn("Threshold for node " + node.getId() + " at "+ node.getHost()+ " now "+ threshold+ "%; marking as unavailable");
    notifyUnavailable(node);
  }
  return isAvailable;
}
