{
  NodeStatus nodeStatus=getNodeStatus(node);
  boolean needsNotifyAvailable=false;
  boolean needsNotifyUnavailable=false;
  long threshold=0;
  boolean isAvailable=false;
synchronized (nodeStatus) {
    nodeStatus.setLastChecked(getConfig().getTime().getMilliseconds());
    if (nodeStatus.getLastChecked() >= nodeStatus.getStartMillis() + getConfig().getThresholdInterval()) {
      needsNotifyAvailable=!nodeStatus.isAvailable();
      nodeStatus.setAvailable(true);
      nodeStatus.setStartMillis(nodeStatus.getLastChecked());
      nodeStatus.setSuccess(successDelta);
      nodeStatus.setTotal(totalDelta);
    }
 else {
      nodeStatus.incrementSuccess(successDelta);
      nodeStatus.incrementTotal(totalDelta);
    }
    int thresholdCountMinimum=getConfig().getThresholdCountMinimum();
    if (nodeStatus.getTotal() >= thresholdCountMinimum) {
      threshold=nodeStatus.getTotal() >= thresholdCountMinimum ? (nodeStatus.getSuccess() * 100) / nodeStatus.getTotal() : 100;
      boolean previouslyAvailable=nodeStatus.isAvailable();
      nodeStatus.setAvailable(threshold >= getConfig().getThreshold());
      if (nodeStatus.isAvailable() && !previouslyAvailable)       needsNotifyAvailable=true;
 else       if (!nodeStatus.isAvailable() && previouslyAvailable)       needsNotifyUnavailable=true;
    }
    isAvailable=nodeStatus.isAvailable();
  }
  if (needsNotifyAvailable) {
    if (logger.isInfoEnabled())     logger.info("Threshold for node " + node.getId() + " at "+ node.getHost()+ " now "+ threshold+ "%; marking as available");
    notifyAvailable(node);
  }
 else   if (needsNotifyUnavailable) {
    if (logger.isEnabledFor(Level.WARN))     logger.warn("Threshold for node " + node.getId() + " at "+ node.getHost()+ " now "+ threshold+ "%; marking as unavailable");
    notifyUnavailable(node);
  }
  return isAvailable;
}
