{
  if (e != null) {
    if (logger.isEnabledFor(Level.WARN))     logger.warn(e,e);
  }
  NodeData nd=getNodeData(node);
  boolean needsNotifyAvailable=false;
  boolean needsNotifyUnavailable=false;
  long threshold=0;
  boolean isAvailable=false;
synchronized (nd) {
    nd.lastChecked=getConfig().getTime().getMilliseconds();
    if (nd.lastChecked >= nd.startMillis + getConfig().getThresholdInterval()) {
      needsNotifyAvailable=!nd.isAvailable;
      nd.isAvailable=true;
      nd.startMillis=nd.lastChecked;
      nd.success=successDelta;
      nd.total=totalDelta;
    }
 else {
      nd.success+=successDelta;
      nd.total+=totalDelta;
    }
    int thresholdCountMinimum=getConfig().getThresholdCountMinimum();
    if (nd.total >= thresholdCountMinimum) {
      threshold=nd.total >= thresholdCountMinimum ? (nd.success * 100) / nd.total : 100;
      boolean previouslyAvailable=nd.isAvailable;
      nd.isAvailable=threshold >= getConfig().getThreshold();
      if (nd.isAvailable && !previouslyAvailable)       needsNotifyAvailable=true;
 else       if (!nd.isAvailable && previouslyAvailable)       needsNotifyUnavailable=true;
    }
    isAvailable=nd.isAvailable;
  }
  if (needsNotifyAvailable) {
    if (logger.isInfoEnabled())     logger.info("Threshold for node " + node.getId() + " at "+ node.getHost()+ " now "+ threshold+ "%; marking as available");
    notifyAvailable(node);
  }
 else   if (needsNotifyUnavailable) {
    if (logger.isEnabledFor(Level.WARN))     logger.warn("Threshold for node " + node.getId() + " at "+ node.getHost()+ " now "+ threshold+ "%; marking as unavailable");
    notifyUnavailable(node);
  }
  return isAvailable;
}
