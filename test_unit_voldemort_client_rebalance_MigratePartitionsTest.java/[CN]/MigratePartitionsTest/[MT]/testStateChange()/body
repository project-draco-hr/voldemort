{
  voldemortServer[NUM_NODES - 1].getMetadataStore().put(MetadataStore.SERVER_STATE_KEY,VoldemortState.GRANDFATHERING_SERVER);
  MigratePartitions tool=new MigratePartitions(consistentRoutingCluster,zoneRoutingCluster,Lists.newArrayList(beforeStoreDef),Lists.newArrayList(afterStoreDef),adminClient,voldemortConfig,null,true);
  try {
    tool.migrate();
    fail("Should have failed due to one node being in grandfathering state already");
  }
 catch (  Exception e) {
  }
  for (int nodeId=0; nodeId < NUM_NODES - 1; nodeId++) {
    Assert.assertEquals(voldemortServer[nodeId].getMetadataStore().getServerState().toString(),MetadataStore.VoldemortState.NORMAL_SERVER.toString());
  }
  Assert.assertEquals(voldemortServer[NUM_NODES - 1].getMetadataStore().getServerState().toString(),MetadataStore.VoldemortState.GRANDFATHERING_SERVER.toString());
  voldemortServer[NUM_NODES - 1].getMetadataStore().put(MetadataStore.SERVER_STATE_KEY,VoldemortState.NORMAL_SERVER);
  HashMap<Integer,VectorClock> serverVersions=Maps.newHashMap();
  for (int nodeId=0; nodeId < NUM_NODES; nodeId++) {
    VectorClock currentClock=(VectorClock)voldemortServer[nodeId].getMetadataStore().get(MetadataStore.SERVER_STATE_KEY,null).get(0).getVersion();
    serverVersions.put(nodeId,currentClock);
  }
  tool=new MigratePartitions(consistentRoutingCluster,zoneRoutingCluster,Lists.newArrayList(beforeStoreDef),Lists.newArrayList(afterStoreDef),adminClient,voldemortConfig,null,true);
  tool.migrate();
  for (int nodeId=0; nodeId < NUM_NODES; nodeId++) {
    VectorClock currentClock=(VectorClock)voldemortServer[nodeId].getMetadataStore().get(MetadataStore.SERVER_STATE_KEY,null).get(0).getVersion();
    Assert.assertEquals(serverVersions.get(nodeId).getMaxVersion() + 2,currentClock.getMaxVersion());
  }
}
