{
  RebalancePartitionsInfo info=new RebalancePartitionsInfo(NUM_NODES - 1,0,Lists.newArrayList(0),new ArrayList<Integer>(),new ArrayList<Integer>(),new ArrayList<String>(),new HashMap<String,String>(),new HashMap<String,String>(),0);
  voldemortServer[0].getMetadataStore().put(MetadataStore.SERVER_STATE_KEY,VoldemortState.GRANDFATHERING_SERVER);
  voldemortServer[0].getMetadataStore().put(MetadataStore.GRANDFATHERING_INFO,new GrandfatherState(Lists.newArrayList(info)));
  Map<ByteArray,byte[]> entryMap=ServerTestUtils.createRandomKeyValuePairs(TEST_VALUES_SIZE);
  Store<ByteArray,byte[],byte[]> store=voldemortServer[0].getStoreRepository().getLocalStore("consistent_to_zone_store");
  Map<ByteArray,byte[]> entriesMigrating=Maps.newHashMap();
  for (  Entry<ByteArray,byte[]> entry : entryMap.entrySet()) {
    List<Integer> partitions=routingStrategy.getPartitionList(entry.getKey().get());
    if (hasOverLap(partitions,consistentRoutingCluster.getNodeById(0).getPartitionIds())) {
      VectorClock vectorClock=new VectorClock();
      vectorClock.incrementVersion(0,System.currentTimeMillis());
      store.put(entry.getKey(),Versioned.value(entry.getValue(),vectorClock),null);
    }
    if (partitions.contains(0))     entriesMigrating.put(entry.getKey(),entry.getValue());
  }
  StorageEngine<ByteArray,Slop,byte[]> slopEngine=voldemortServer[0].getStoreRepository().getSlopStore().asSlopStore();
  Thread.sleep(1000);
  checkSlopStore(slopEngine,entriesMigrating,Slop.Operation.PUT);
  info=new RebalancePartitionsInfo(NUM_NODES - 1,0,consistentRoutingCluster.getNodeById(0).getPartitionIds(),new ArrayList<Integer>(),new ArrayList<Integer>(),new ArrayList<String>(),new HashMap<String,String>(),new HashMap<String,String>(),0);
  voldemortServer[0].getMetadataStore().put(MetadataStore.GRANDFATHERING_INFO,new GrandfatherState(Lists.newArrayList(info)));
  entriesMigrating=Maps.newHashMap();
  for (  Entry<ByteArray,byte[]> entry : entryMap.entrySet()) {
    List<Integer> partitions=routingStrategy.getPartitionList(entry.getKey().get());
    if (hasOverLap(partitions,consistentRoutingCluster.getNodeById(0).getPartitionIds())) {
      VectorClock vectorClock=new VectorClock();
      vectorClock.incrementVersion(0,System.currentTimeMillis());
      try {
        store.put(entry.getKey(),Versioned.value(entry.getValue(),vectorClock),null);
      }
 catch (      ObsoleteVersionException e) {
      }
      entriesMigrating.put(entry.getKey(),entry.getValue());
    }
  }
  Thread.sleep(1000);
  checkSlopStore(slopEngine,entriesMigrating,Slop.Operation.PUT);
}
