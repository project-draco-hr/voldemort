{
  if (donorNodePlans.size() == 0) {
    logger.info("Nothing to move around");
    return;
  }
  logger.info("Changing state of donor nodes " + donorNodePlans.keySet());
  int i=0;
  for (  Map.Entry<Integer,RebalanceNodePlan> entry : stealerNodePlans.entrySet()) {
    i+=entry.getValue().getRebalanceTaskList().size();
  }
  final int total=i * storeNames.size();
  final AtomicInteger completed=new AtomicInteger(0);
  final long startTime=System.currentTimeMillis();
  try {
    changeToGrandfather();
    final CountDownLatch latch=new CountDownLatch(stealerNodeIds.size());
    for (    final int stealerNodeId : stealerNodeIds) {
      executor.submit(new Runnable(){
        public void run(){
          try {
            RebalanceNodePlan nodePlan=stealerNodePlans.get(stealerNodeId);
            if (nodePlan == null) {
              logger.info("No plan for stealer node id " + stealerNodeId);
              return;
            }
            List<RebalancePartitionsInfo> partitionInfo=nodePlan.getRebalanceTaskList();
            List<MigratePartitionsTask> taskList=Lists.newArrayList();
            HashMap<Integer,Integer> nodeIdToRequestId=Maps.newHashMap();
            logger.info("Working on stealer node id " + stealerNodeId);
            for (            String storeName : storeNames) {
              logger.info("- Working on store " + storeName);
              for (              RebalancePartitionsInfo r : partitionInfo) {
                MigratePartitionsTask task=new MigratePartitionsTask(r.getDonorId(),stealerNodeId,storeName,r.getPartitionList());
                taskList.add(task);
              }
            }
            Collections.shuffle(taskList);
            for (            MigratePartitionsTask task : taskList) {
              logger.info("-- Started migration task " + task);
              if (!simulation)               nodeIdToRequestId.put(task.getDonorId(),adminClient.migratePartitions(task.getDonorId(),task.getStealerNodeId(),task.getStoreName(),task.getPartitionList(),null));
            }
            Set<Integer> pending=Sets.newHashSet(nodeIdToRequestId.keySet());
            while (!pending.isEmpty()) {
              for (              int nodeId : nodeIdToRequestId.keySet()) {
                AsyncOperationStatus status=adminClient.getAsyncRequestStatus(stealerNodeId,nodeIdToRequestId.get(nodeId));
                logger.info("Status from node " + nodeId + " ("+ status.getDescription()+ ") - "+ status.getStatus());
                if (status.isComplete()) {
                  if (pending.contains(nodeId)) {
                    logger.info("-- Completed migration from " + nodeId + " to "+ +stealerNodeId);
                    pending.remove(nodeId);
                    logger.info("Finished " + completed.incrementAndGet() + " out of "+ total+ " tasks");
                    long msPerMigration=(System.currentTimeMillis() - startTime) / completed.get();
                    long etaSeconds=(total - completed.get()) * msPerMigration / Time.MS_PER_SECOND;
                    logger.info("Current velocity " + msPerMigration / Time.MS_PER_SECOND + " seconds for each task");
                    logger.info("Time until finished " + etaSeconds + " seconds");
                  }
                  if (pending.isEmpty())                   break;
                }
                try {
                  Thread.sleep(30000);
                }
 catch (                InterruptedException e) {
                  logger.error(e,e);
                  throw new VoldemortException(e);
                }
              }
            }
            logger.info("Finished migrating to " + stealerNodeId);
            logger.info("===============================================");
          }
  finally {
            latch.countDown();
          }
        }
      }
);
    }
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  finally {
    if (donorStates != null && transitionToNormal) {
      changeToNormal();
    }
    executor.shutdown();
  }
}
