{
  StorageEngine<ByteArray,byte[],byte[]> storageEngine=storeRepository.getStorageEngine(storeName);
  StoreDefinition storeDef=metadataStore.getStoreDef(storeName);
  List<DonorBasedRebalancePusherSlave> storePushSlaves=Lists.newArrayList();
  ExecutorService pushSlavesExecutor=Executors.newCachedThreadPool(new ThreadFactory(){
    @Override public Thread newThread(    Runnable r){
      Thread thread=new Thread(r);
      thread.setName(r.getClass().getName());
      return thread;
    }
  }
);
  updatePushSlavePool.put(storeName,new Pair<ExecutorService,List<DonorBasedRebalancePusherSlave>>(pushSlavesExecutor,storePushSlaves));
  if (isReadOnlyStore) {
    throw new VoldemortException("Donor-based rebalancing for read-only store is currently not supported!");
  }
 else {
    HashMap<Integer,SynchronousQueue<Pair<ByteArray,Versioned<byte[]>>>> nodeToQueue=Maps.newHashMap();
    if (stealerNodeToMappingTuples.size() <= 0) {
      return;
    }
    for (    Pair<Integer,HashMap<Integer,List<Integer>>> tuple : stealerNodeToMappingTuples) {
      final SynchronousQueue<Pair<ByteArray,Versioned<byte[]>>> queue=new SynchronousQueue<Pair<ByteArray,Versioned<byte[]>>>();
      nodeToQueue.put(tuple.getFirst(),queue);
      String jobName="DonorBasedRebalancePusherSlave for store " + storeName + " on node "+ tuple.getFirst();
      DonorBasedRebalancePusherSlave updatePushSlave=new DonorBasedRebalancePusherSlave(tuple.getFirst(),queue,storeName,adminClient);
      storePushSlaves.add(updatePushSlave);
      pushSlavesExecutor.execute(updatePushSlave);
      logger.info("Started a thread for " + jobName);
    }
    if (usePartitionScan && storageEngine.isPartitionScanSupported()) {
      fetchEntriesForStealersPartitionScan(storageEngine,stealerNodeToMappingTuples,storeDef,nodeToQueue,storeName);
    }
 else {
      fetchEntriesForStealers(storageEngine,stealerNodeToMappingTuples,storeDef,nodeToQueue,storeName);
    }
  }
}
