{
  StorageEngine<ByteArray,byte[],byte[]> storageEngine=storeRepository.getStorageEngine(storeName);
  StoreDefinition storeDef=metadataStore.getStoreDef(storeName);
  List<DonorBasedRebalancePusherSlave> storePushSlaves=Lists.newArrayList();
  ExecutorService pushSlavesExecutor=Executors.newCachedThreadPool(new ThreadFactory(){
    public Thread newThread(    Runnable r){
      Thread thread=new Thread(r);
      thread.setName(r.getClass().getName());
      return thread;
    }
  }
);
  updatePushSlavePool.put(storeName,new Pair<ExecutorService,List<DonorBasedRebalancePusherSlave>>(pushSlavesExecutor,storePushSlaves));
  if (isReadOnlyStore) {
    throw new VoldemortException("Donor-based rebalancing for read-only store is currently not supported!");
  }
 else {
    HashMap<Integer,SynchronousQueue<Pair<ByteArray,Versioned<byte[]>>>> nodeToQueue=Maps.newHashMap();
    Set<Pair<Integer,HashMap<Integer,List<Integer>>>> optimizedStealerNodeToMappingTuples=Sets.newHashSet();
    if (voldemortConfig.getRebalancingOptimization() && !storageEngine.isPartitionAware()) {
      for (      Pair<Integer,HashMap<Integer,List<Integer>>> entry : stealerNodeToMappingTuples) {
        HashMap<Integer,List<Integer>> optimizedReplicaToPartition=RebalanceUtils.getOptimizedReplicaToPartitionList(entry.getFirst(),initialCluster,storeDef,entry.getSecond());
        if (optimizedReplicaToPartition.size() > 0) {
          optimizedStealerNodeToMappingTuples.add(Pair.create(entry.getFirst(),optimizedReplicaToPartition));
        }
      }
    }
 else {
      optimizedStealerNodeToMappingTuples.addAll(stealerNodeToMappingTuples);
    }
    if (optimizedStealerNodeToMappingTuples.size() <= 0) {
      return;
    }
    for (    Pair<Integer,HashMap<Integer,List<Integer>>> tuple : stealerNodeToMappingTuples) {
      final SynchronousQueue<Pair<ByteArray,Versioned<byte[]>>> queue=new SynchronousQueue<Pair<ByteArray,Versioned<byte[]>>>();
      nodeToQueue.put(tuple.getFirst(),queue);
      String jobName="DonorBasedRebalancePusherSlave for store " + storeName + " on node "+ tuple.getFirst();
      DonorBasedRebalancePusherSlave updatePushSlave=new DonorBasedRebalancePusherSlave(tuple.getFirst(),queue,storeName,adminClient);
      storePushSlaves.add(updatePushSlave);
      pushSlavesExecutor.execute(updatePushSlave);
      logger.info("Started a thread for " + jobName);
    }
    if (usePartitionScan && storageEngine.isPartitionScanSupported())     fetchEntriesForStealersPartitionScan(storageEngine,optimizedStealerNodeToMappingTuples,storeDef,nodeToQueue,storeName);
 else     fetchEntriesForStealers(storageEngine,optimizedStealerNodeToMappingTuples,storeDef,nodeToQueue,storeName);
  }
}
