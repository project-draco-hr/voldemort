{
  StorageEngine<ByteArray,byte[],byte[]> storageEngine=storeRepository.getStorageEngine(storeName);
  StoreDefinition storeDef=metadataStore.getStoreDef(storeName);
  if (isReadOnlyStore) {
    throw new VoldemortException("Donor-based rebalancing for read-only store is currently not supported!");
  }
 else {
    HashMap<Integer,SynchronousQueue<Pair<ByteArray,Versioned<byte[]>>>> nodeToQueue=Maps.newHashMap();
    Set<Pair<Integer,HashMap<Integer,List<Integer>>>> optimizedStealerNodeToMappingTuples=Sets.newHashSet();
    if (voldemortConfig.getRebalancingOptimization() && !storageEngine.isPartitionAware()) {
      for (      Pair<Integer,HashMap<Integer,List<Integer>>> entry : stealerNodeToMappingTuples) {
        HashMap<Integer,List<Integer>> optimizedReplicaToPartition=RebalanceUtils.getOptimizedReplicaToPartitionList(entry.getFirst(),initialCluster,storeDef,entry.getSecond());
        if (optimizedReplicaToPartition.size() > 0) {
          optimizedStealerNodeToMappingTuples.add(Pair.create(entry.getFirst(),optimizedReplicaToPartition));
        }
      }
    }
 else {
      optimizedStealerNodeToMappingTuples.addAll(stealerNodeToMappingTuples);
    }
    if (optimizedStealerNodeToMappingTuples.size() <= 0) {
      return;
    }
    for (    Pair<Integer,HashMap<Integer,List<Integer>>> tuple : stealerNodeToMappingTuples) {
      final SynchronousQueue<Pair<ByteArray,Versioned<byte[]>>> queue=new SynchronousQueue<Pair<ByteArray,Versioned<byte[]>>>();
      nodeToQueue.put(tuple.getFirst(),queue);
      DonorBasedRebalancePusherSlave updatePushSlave=new DonorBasedRebalancePusherSlave(0,"test",tuple.getFirst(),queue,storeName,adminClient);
      updatePushSlavePool.add(updatePushSlave);
      pushSlavesExecutor.execute(updatePushSlave);
    }
    ClosableIterator<ByteArray> keys=storageEngine.keys();
    while (running.get() && keys.hasNext()) {
      ByteArray key=keys.next();
      List<Integer> nodeIds=RebalanceUtils.checkKeyBelongsToPartition(key.get(),optimizedStealerNodeToMappingTuples,initialCluster,storeDef);
      if (nodeIds.size() > 0) {
        List<Versioned<byte[]>> values=storageEngine.get(key,null);
        for (        Versioned<byte[]> value : values) {
          for (          int nodeId : nodeIds) {
            try {
              nodeToQueue.get(nodeId).put(Pair.create(key,value));
            }
 catch (            InterruptedException e) {
              e.printStackTrace();
            }
          }
        }
      }
    }
    terminateAllSlaves(updatePushSlavePool);
  }
}
