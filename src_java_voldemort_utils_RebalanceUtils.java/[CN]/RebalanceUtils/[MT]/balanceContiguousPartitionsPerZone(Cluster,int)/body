{
  System.out.println("Balance number of contiguous partitions within a zone.");
  List<Node> allNodes=Lists.newArrayList();
  HashMap<Integer,List<Integer>> nodesPerZone=Maps.newHashMap();
  HashMap<Integer,List<Integer>> partitionsPerZone=Maps.newHashMap();
  for (  Node node : targetCluster.getNodes()) {
    allNodes.add(updateNode(node,Lists.newArrayList(node.getPartitionIds())));
    if (nodesPerZone.containsKey(node.getZoneId())) {
      List<Integer> currentNodeList=nodesPerZone.get(node.getZoneId());
      List<Integer> mutableNodeList=new ArrayList<Integer>();
      mutableNodeList.addAll(currentNodeList);
      mutableNodeList.add(node.getId());
      nodesPerZone.put(node.getZoneId(),mutableNodeList);
    }
 else {
      List<Integer> nodeList=new ArrayList<Integer>();
      nodeList.add(node.getId());
      nodesPerZone.put(node.getZoneId(),nodeList);
    }
    if (partitionsPerZone.containsKey(node.getZoneId())) {
      List<Integer> currentPartitions=partitionsPerZone.get(node.getZoneId());
      List<Integer> mutableCurrentPartitions=new ArrayList<Integer>();
      mutableCurrentPartitions.addAll(currentPartitions);
      mutableCurrentPartitions.addAll(node.getPartitionIds());
      partitionsPerZone.put(node.getZoneId(),mutableCurrentPartitions);
    }
 else {
      partitionsPerZone.put(node.getZoneId(),node.getPartitionIds());
    }
  }
  System.out.println("numPartitionsPerZone");
  for (  int zone : partitionsPerZone.keySet()) {
    System.out.println(zone + " : " + partitionsPerZone.get(zone).size());
  }
  System.out.println("numNodesPerZone");
  for (  int zone : nodesPerZone.keySet()) {
    System.out.println(zone + " : " + nodesPerZone.get(zone).size());
  }
  HashMap<Integer,List<Integer>> partitionsToRemoveFromZone=Maps.newHashMap();
  System.out.println("Contiguous partitions");
  for (  Integer zoneId : partitionsPerZone.keySet()) {
    System.out.println("\tZone: " + zoneId);
    List<Integer> partitions=partitionsPerZone.get(zoneId);
    java.util.Collections.sort(partitions);
    List<Integer> partitionsToRemoveFromThisZone=new ArrayList<Integer>();
    List<Integer> contiguousPartitions=new ArrayList<Integer>();
    int contiguousCount=0;
    int lastPartitionId=partitions.get(0);
    for (int i=1; i < partitions.size(); ++i) {
      if (partitions.get(i) == lastPartitionId + 1) {
        contiguousCount++;
        contiguousPartitions.add(partitions.get(i));
      }
 else {
        if (contiguousCount > maxContiguousPartitionsPerZone) {
          System.out.println("\tContiguous partitions: " + contiguousPartitions);
          int lenContig=contiguousPartitions.size();
          int offset=lenContig % (maxContiguousPartitionsPerZone + 1);
          if (offset == 0) {
            offset=maxContiguousPartitionsPerZone / 2;
          }
          if (offset == 0) {
            offset=1;
          }
          while (offset < lenContig) {
            partitionsToRemoveFromThisZone.add(contiguousPartitions.get(offset));
            offset+=maxContiguousPartitionsPerZone + 1;
          }
        }
        contiguousPartitions.clear();
        contiguousCount=0;
      }
      lastPartitionId=partitions.get(i);
    }
    partitionsToRemoveFromZone.put(zoneId,partitionsToRemoveFromThisZone);
    System.out.println("\t\tPartitions to remove: " + partitionsToRemoveFromThisZone);
  }
  Cluster returnCluster=updateCluster(targetCluster,allNodes);
  int totalPrimaryPartitionsMoved=0;
  Random r=new Random();
  Set<Integer> zoneIds=nodesPerZone.keySet();
  for (  int zoneId : zoneIds) {
    for (    int partitionId : partitionsToRemoveFromZone.get(zoneId)) {
      List<Integer> otherZoneIds=new ArrayList<Integer>();
      for (      int otherZoneId : zoneIds) {
        if (otherZoneId != zoneId) {
          otherZoneIds.add(otherZoneId);
        }
      }
      int whichOtherZoneId=otherZoneIds.get(r.nextInt(otherZoneIds.size()));
      int whichNodeOffset=r.nextInt(nodesPerZone.get(whichOtherZoneId).size());
      int whichNodeId=nodesPerZone.get(whichOtherZoneId).get(whichNodeOffset);
      returnCluster=createUpdatedCluster(returnCluster,whichNodeId,Lists.newArrayList(partitionId));
      totalPrimaryPartitionsMoved++;
    }
  }
  return Pair.create(returnCluster,totalPrimaryPartitionsMoved);
}
