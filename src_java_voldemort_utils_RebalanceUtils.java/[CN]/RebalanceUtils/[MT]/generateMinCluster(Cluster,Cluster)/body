{
  int currentNumPartitions=currentCluster.getNumberOfPartitions();
  int currentNumNodes=currentCluster.getNumberOfNodes();
  int targetNumNodes=targetCluster.getNumberOfNodes();
  List<Integer> newNodeIds=Lists.newArrayList();
  List<Integer> donorNodeIds=Lists.newArrayList();
  List<Node> allNodes=Lists.newArrayList();
  for (  Node node : targetCluster.getNodes()) {
    if (node.getPartitionIds().isEmpty()) {
      newNodeIds.add(node.getId());
    }
 else {
      donorNodeIds.add(node.getId());
    }
    allNodes.add(updateNode(node,Lists.newArrayList(node.getPartitionIds())));
  }
  Cluster returnCluster=updateCluster(targetCluster,allNodes);
  if (currentNumNodes == targetNumNodes) {
    return returnCluster;
  }
  int targetNumPartitionPerNode=(int)Math.floor(currentNumPartitions * 1.0 / targetNumNodes);
  for (  int newNodeId : newNodeIds) {
    int partitionsToSteal=targetNumPartitionPerNode;
    for (int index=0; index < donorNodeIds.size(); index++) {
      int donorNodeId=donorNodeIds.get(index);
      if (partitionsToSteal <= 0)       break;
      int partitionsToDonate=Math.max((int)Math.floor(partitionsToSteal / (donorNodeIds.size() - index)),1);
      if (returnCluster.getNodeById(donorNodeId).getNumberOfPartitions() <= partitionsToDonate) {
        continue;
      }
      List<Integer> donorPartitions=Lists.newArrayList(returnCluster.getNodeById(donorNodeId).getPartitionIds());
      Collections.shuffle(donorPartitions);
      List<Integer> donorPartitionsToMove=donorPartitions.subList(0,partitionsToDonate);
      returnCluster=createUpdatedCluster(returnCluster,returnCluster.getNodeById(newNodeId),returnCluster.getNodeById(donorNodeId),donorPartitionsToMove);
      partitionsToSteal-=partitionsToDonate;
    }
  }
  return returnCluster;
}
