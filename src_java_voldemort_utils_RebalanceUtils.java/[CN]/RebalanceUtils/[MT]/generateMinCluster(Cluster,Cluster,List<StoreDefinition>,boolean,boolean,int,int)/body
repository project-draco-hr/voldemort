{
  List<Integer> newNodeIds=Lists.newArrayList();
  List<Integer> donorNodeIds=Lists.newArrayList();
  List<Node> allNodes=Lists.newArrayList();
  HashMap<Integer,Integer> numPartitionsPerZone=Maps.newHashMap();
  HashMap<Integer,List<Integer>> partitionsPerZone=Maps.newHashMap();
  HashMap<Integer,List<Integer>> nodesPerZone=Maps.newHashMap();
  HashMap<Integer,Integer> numNodesPerZone=Maps.newHashMap();
  HashMap<Integer,Integer> numDonorNodesPerZone=Maps.newHashMap();
  HashMap<Integer,Integer> numStealerNodesPerZone=Maps.newHashMap();
  for (  Node node : targetCluster.getNodes()) {
    if (node.getPartitionIds().isEmpty()) {
      newNodeIds.add(node.getId());
      if (numStealerNodesPerZone.containsKey(node.getZoneId())) {
        int currentNumStealerNodesInZone=numNodesPerZone.get(node.getZoneId());
        currentNumStealerNodesInZone+=1;
        numStealerNodesPerZone.put(node.getZoneId(),currentNumStealerNodesInZone);
      }
 else {
        numStealerNodesPerZone.put(node.getZoneId(),1);
      }
    }
 else {
      donorNodeIds.add(node.getId());
      if (numDonorNodesPerZone.containsKey(node.getZoneId())) {
        int currentNumDonorNodesInZone=numNodesPerZone.get(node.getZoneId());
        currentNumDonorNodesInZone+=1;
        numDonorNodesPerZone.put(node.getZoneId(),currentNumDonorNodesInZone);
      }
 else {
        numDonorNodesPerZone.put(node.getZoneId(),1);
      }
    }
    allNodes.add(updateNode(node,Lists.newArrayList(node.getPartitionIds())));
    if (numPartitionsPerZone.containsKey(node.getZoneId())) {
      int currentNumPartitionsInZone=numPartitionsPerZone.get(node.getZoneId());
      currentNumPartitionsInZone+=node.getNumberOfPartitions();
      numPartitionsPerZone.put(node.getZoneId(),currentNumPartitionsInZone);
    }
 else {
      numPartitionsPerZone.put(node.getZoneId(),node.getNumberOfPartitions());
    }
    if (numNodesPerZone.containsKey(node.getZoneId())) {
      int currentNumNodesInZone=numNodesPerZone.get(node.getZoneId());
      currentNumNodesInZone+=1;
      numNodesPerZone.put(node.getZoneId(),currentNumNodesInZone);
    }
 else {
      numNodesPerZone.put(node.getZoneId(),1);
    }
    if (maxContiguousPartitionsPerZone >= 0) {
      if (partitionsPerZone.containsKey(node.getZoneId())) {
        List<Integer> currentPartitions=partitionsPerZone.get(node.getZoneId());
        List<Integer> mutableCurrentPartitions=new ArrayList<Integer>();
        mutableCurrentPartitions.addAll(currentPartitions);
        mutableCurrentPartitions.addAll(node.getPartitionIds());
        partitionsPerZone.put(node.getZoneId(),mutableCurrentPartitions);
      }
 else {
        partitionsPerZone.put(node.getZoneId(),node.getPartitionIds());
      }
      if (nodesPerZone.containsKey(node.getZoneId())) {
        List<Integer> currentNodeList=nodesPerZone.get(node.getZoneId());
        List<Integer> mutableNodeList=new ArrayList<Integer>();
        mutableNodeList.addAll(currentNodeList);
        mutableNodeList.add(node.getId());
        nodesPerZone.put(node.getZoneId(),mutableNodeList);
      }
 else {
        List<Integer> nodeList=new ArrayList<Integer>();
        nodeList.add(node.getId());
        nodesPerZone.put(node.getZoneId(),nodeList);
      }
    }
  }
  System.out.println("numPartitionsPerZone");
  for (  int zone : numPartitionsPerZone.keySet()) {
    System.out.println(zone + " : " + numPartitionsPerZone.get(zone));
  }
  System.out.println("numNodesPerZone");
  for (  int zone : numNodesPerZone.keySet()) {
    System.out.println(zone + " : " + numNodesPerZone.get(zone));
  }
  System.out.println("numDonorNodesPerZone");
  for (  int zone : numDonorNodesPerZone.keySet()) {
    System.out.println(zone + " : " + numDonorNodesPerZone.get(zone));
  }
  System.out.println("numStealerNodesPerZone");
  for (  int zone : numStealerNodesPerZone.keySet()) {
    System.out.println(zone + " : " + numStealerNodesPerZone.get(zone));
  }
  HashMap<Integer,List<Integer>> partitionsToRemoveFromZone=Maps.newHashMap();
  if (maxContiguousPartitionsPerZone >= 0) {
    for (    Integer zoneId : partitionsPerZone.keySet()) {
      List<Integer> partitions=partitionsPerZone.get(zoneId);
      java.util.Collections.sort(partitions);
      List<Integer> partitionsToRemoveFromThisZone=new ArrayList<Integer>();
      int contiguousCount=0;
      int lastPartitionId=partitions.get(0);
      for (int i=1; i < partitions.size(); ++i) {
        if (partitions.get(i) == lastPartitionId + 1) {
          contiguousCount++;
          if (contiguousCount == maxContiguousPartitionsPerZone) {
            partitionsToRemoveFromThisZone.add(partitions.get(i));
            contiguousCount=0;
          }
        }
 else {
          contiguousCount=0;
        }
        lastPartitionId=partitions.get(i);
      }
      partitionsToRemoveFromZone.put(zoneId,partitionsToRemoveFromThisZone);
      System.out.println("Partitions to remove from zone " + zoneId);
      System.out.println("\t" + partitionsToRemoveFromThisZone);
    }
  }
  Cluster returnCluster=updateCluster(targetCluster,allNodes);
  int totalPrimaryPartitionsMoved=0;
  if (maxContiguousPartitionsPerZone >= 0) {
    Random r=new Random();
    Set<Integer> zoneIds=numNodesPerZone.keySet();
    for (    int zoneId : zoneIds) {
      for (      int partitionId : partitionsToRemoveFromZone.get(zoneId)) {
        List<Integer> otherZoneIds=new ArrayList<Integer>();
        for (        int otherZoneId : zoneIds) {
          if (otherZoneId != zoneId) {
            otherZoneIds.add(otherZoneId);
          }
        }
        int whichOtherZoneId=otherZoneIds.get(r.nextInt(otherZoneIds.size()));
        int whichNodeOffset=r.nextInt(nodesPerZone.get(whichOtherZoneId).size());
        int whichNodeId=nodesPerZone.get(whichOtherZoneId).get(whichNodeOffset);
        returnCluster=createUpdatedCluster(returnCluster,whichNodeId,Lists.newArrayList(partitionId));
        totalPrimaryPartitionsMoved++;
      }
    }
    return Pair.create(returnCluster,totalPrimaryPartitionsMoved);
  }
  HashMap<Integer,List<Integer>> numPartitionsPerNodePerZone=Maps.newHashMap();
  for (  Integer zoneId : numNodesPerZone.keySet()) {
    int numNodesInZone=numNodesPerZone.get(zoneId);
    int numPartitionsInZone=numPartitionsPerZone.get(zoneId);
    int floorPartitionsPerNodeInZone=numPartitionsInZone / numNodesInZone;
    int numNodesInZoneWithCeil=numPartitionsInZone - (numNodesInZone * floorPartitionsPerNodeInZone);
    ArrayList<Integer> partitionsOnNode=new ArrayList<Integer>(numNodesInZone);
    for (int i=0; i < numNodesInZoneWithCeil; i++) {
      partitionsOnNode.add(i,floorPartitionsPerNodeInZone + 1);
    }
    for (int i=numNodesInZoneWithCeil; i < numNodesInZone; i++) {
      partitionsOnNode.add(i,floorPartitionsPerNodeInZone);
    }
    numPartitionsPerNodePerZone.put(zoneId,partitionsOnNode);
  }
  if (varyNumPartitionsPerNode > 0) {
    Random r=new Random();
    for (    Integer zoneId : numPartitionsPerNodePerZone.keySet()) {
      int totalRandom=0;
      for (int i=0; i < numPartitionsPerNodePerZone.get(zoneId).size(); i++) {
        int current=numPartitionsPerNodePerZone.get(zoneId).get(i);
        int randomVal=r.nextInt(varyNumPartitionsPerNode * 2 + 1);
        randomVal=Math.max(-current + 1,randomVal - varyNumPartitionsPerNode);
        numPartitionsPerNodePerZone.get(zoneId).set(i,current + randomVal);
        totalRandom+=randomVal;
      }
      while (totalRandom > 0) {
        int id=r.nextInt(numPartitionsPerNodePerZone.get(zoneId).size());
        int current=numPartitionsPerNodePerZone.get(zoneId).get(id);
        if (current > 1) {
          numPartitionsPerNodePerZone.get(zoneId).set(id,current - 1);
          totalRandom--;
        }
      }
      while (totalRandom < 0) {
        int id=r.nextInt(numPartitionsPerNodePerZone.get(zoneId).size());
        int current=numPartitionsPerNodePerZone.get(zoneId).get(id);
        numPartitionsPerNodePerZone.get(zoneId).set(id,current + 1);
        totalRandom++;
      }
    }
  }
  List<Node> donorNodes=Lists.newArrayList();
  List<Node> stealerNodes=Lists.newArrayList();
  HashMap<Integer,Integer> numPartitionsOnNode=Maps.newHashMap();
  HashMap<Integer,Integer> numNodesAssignedInZone=Maps.newHashMap();
  for (  Integer zoneId : numPartitionsPerNodePerZone.keySet()) {
    numNodesAssignedInZone.put(zoneId,0);
  }
  for (  Node node : allNodes) {
    int zoneId=node.getZoneId();
    int offset=numNodesAssignedInZone.get(zoneId);
    numNodesAssignedInZone.put(zoneId,offset + 1);
    int numPartitions=numPartitionsPerNodePerZone.get(zoneId).get(offset);
    numPartitionsOnNode.put(node.getId(),numPartitions);
    if (numPartitions < node.getNumberOfPartitions()) {
      donorNodes.add(node);
    }
 else     if (numPartitions > node.getNumberOfPartitions()) {
      stealerNodes.add(node);
    }
  }
  for (  Node node : donorNodes) {
    System.out.println("Donor Node: " + node.getId() + ", zoneId "+ node.getZoneId()+ ", numPartitions "+ node.getNumberOfPartitions()+ ", target number of partitions "+ numPartitionsOnNode.get(node.getId()));
  }
  for (  Node node : stealerNodes) {
    System.out.println("Stealer Node: " + node.getId() + ", zoneId "+ node.getZoneId()+ ", numPartitions "+ node.getNumberOfPartitions()+ ", target number of partitions "+ numPartitionsOnNode.get(node.getId()));
  }
  for (  Node stealerNode : stealerNodes) {
    int partitionsToSteal=numPartitionsOnNode.get(stealerNode.getId()) - stealerNode.getNumberOfPartitions();
    System.out.println("Node (" + stealerNode.getId() + ") in zone ("+ stealerNode.getZoneId()+ ") has partitionsToSteal of "+ partitionsToSteal);
    while (partitionsToSteal > 0) {
      for (      Node donorNode : donorNodes) {
        Node currentDonorNode=returnCluster.getNodeById(donorNode.getId());
        if (keepPrimaryPartitionsInSameZone && (currentDonorNode.getZoneId() != stealerNode.getZoneId())) {
          continue;
        }
        if (currentDonorNode.getNumberOfPartitions() == numPartitionsOnNode.get(currentDonorNode.getId())) {
          continue;
        }
        List<Integer> donorPartitions=Lists.newArrayList(currentDonorNode.getPartitionIds());
        Collections.shuffle(donorPartitions,new Random(System.currentTimeMillis()));
        for (        int donorPartition : donorPartitions) {
          Cluster intermediateCluster=createUpdatedCluster(returnCluster,stealerNode.getId(),Lists.newArrayList(donorPartition));
          int crossZoneMoves=0;
          if (!permitCrossZoneMoves) {
            long startTimeNs=System.nanoTime();
            crossZoneMoves=RebalanceUtils.getCrossZoneMoves(intermediateCluster,new RebalanceClusterPlan(returnCluster,intermediateCluster,storeDefs,true));
            System.out.println("getCrossZoneMoves took " + (System.nanoTime() - startTimeNs) + " ns.");
          }
          if (crossZoneMoves == 0) {
            returnCluster=intermediateCluster;
            totalPrimaryPartitionsMoved++;
            partitionsToSteal--;
            System.out.println("Stealer node " + stealerNode.getId() + ", donor node "+ currentDonorNode.getId()+ ", partition stolen "+ donorPartition);
            break;
          }
 else {
            System.out.println("Stealer node " + stealerNode.getId() + ", donor node "+ currentDonorNode.getId()+ ", attempted to steal partition "+ donorPartition+ " however,  getCrossZoneMoves did NOT return 0!");
          }
        }
        if (partitionsToSteal == 0)         break;
      }
    }
  }
  return Pair.create(returnCluster,totalPrimaryPartitionsMoved);
}
