{
  System.out.println("Balance number of partitions per node within a zone.");
  List<Node> allNodes=Lists.newArrayList();
  HashMap<Integer,Integer> numPartitionsPerZone=Maps.newHashMap();
  HashMap<Integer,Integer> numNodesPerZone=Maps.newHashMap();
  for (  Node node : targetCluster.getNodes()) {
    allNodes.add(updateNode(node,Lists.newArrayList(node.getPartitionIds())));
    if (numPartitionsPerZone.containsKey(node.getZoneId())) {
      int currentNumPartitionsInZone=numPartitionsPerZone.get(node.getZoneId());
      currentNumPartitionsInZone+=node.getNumberOfPartitions();
      numPartitionsPerZone.put(node.getZoneId(),currentNumPartitionsInZone);
    }
 else {
      numPartitionsPerZone.put(node.getZoneId(),node.getNumberOfPartitions());
    }
    if (numNodesPerZone.containsKey(node.getZoneId())) {
      int currentNumNodesInZone=numNodesPerZone.get(node.getZoneId());
      currentNumNodesInZone+=1;
      numNodesPerZone.put(node.getZoneId(),currentNumNodesInZone);
    }
 else {
      numNodesPerZone.put(node.getZoneId(),1);
    }
  }
  System.out.println("numPartitionsPerZone");
  for (  int zone : numPartitionsPerZone.keySet()) {
    System.out.println(zone + " : " + numPartitionsPerZone.get(zone));
  }
  System.out.println("numNodesPerZone");
  for (  int zone : numNodesPerZone.keySet()) {
    System.out.println(zone + " : " + numNodesPerZone.get(zone));
  }
  HashMap<Integer,List<Integer>> numPartitionsPerNodePerZone=Maps.newHashMap();
  for (  Integer zoneId : numNodesPerZone.keySet()) {
    int numNodesInZone=numNodesPerZone.get(zoneId);
    int numPartitionsInZone=numPartitionsPerZone.get(zoneId);
    int floorPartitionsPerNodeInZone=numPartitionsInZone / numNodesInZone;
    int numNodesInZoneWithCeil=numPartitionsInZone - (numNodesInZone * floorPartitionsPerNodeInZone);
    ArrayList<Integer> partitionsOnNode=new ArrayList<Integer>(numNodesInZone);
    for (int i=0; i < numNodesInZoneWithCeil; i++) {
      partitionsOnNode.add(i,floorPartitionsPerNodeInZone + 1);
    }
    for (int i=numNodesInZoneWithCeil; i < numNodesInZone; i++) {
      partitionsOnNode.add(i,floorPartitionsPerNodeInZone);
    }
    numPartitionsPerNodePerZone.put(zoneId,partitionsOnNode);
  }
  if (varyNumPartitionsPerNode > 0) {
    Random r=new Random();
    for (    Integer zoneId : numPartitionsPerNodePerZone.keySet()) {
      int totalRandom=0;
      for (int i=0; i < numPartitionsPerNodePerZone.get(zoneId).size(); i++) {
        int current=numPartitionsPerNodePerZone.get(zoneId).get(i);
        int randomVal=r.nextInt(varyNumPartitionsPerNode * 2 + 1);
        randomVal=Math.max(-current + 1,randomVal - varyNumPartitionsPerNode);
        numPartitionsPerNodePerZone.get(zoneId).set(i,current + randomVal);
        totalRandom+=randomVal;
      }
      while (totalRandom > 0) {
        int id=r.nextInt(numPartitionsPerNodePerZone.get(zoneId).size());
        int current=numPartitionsPerNodePerZone.get(zoneId).get(id);
        if (current > 1) {
          numPartitionsPerNodePerZone.get(zoneId).set(id,current - 1);
          totalRandom--;
        }
      }
      while (totalRandom < 0) {
        int id=r.nextInt(numPartitionsPerNodePerZone.get(zoneId).size());
        int current=numPartitionsPerNodePerZone.get(zoneId).get(id);
        numPartitionsPerNodePerZone.get(zoneId).set(id,current + 1);
        totalRandom++;
      }
    }
  }
  List<Node> donorNodes=Lists.newArrayList();
  List<Node> stealerNodes=Lists.newArrayList();
  HashMap<Integer,Integer> numPartitionsOnNode=Maps.newHashMap();
  HashMap<Integer,Integer> numNodesAssignedInZone=Maps.newHashMap();
  for (  Integer zoneId : numPartitionsPerNodePerZone.keySet()) {
    numNodesAssignedInZone.put(zoneId,0);
  }
  for (  Node node : allNodes) {
    int zoneId=node.getZoneId();
    int offset=numNodesAssignedInZone.get(zoneId);
    numNodesAssignedInZone.put(zoneId,offset + 1);
    int numPartitions=numPartitionsPerNodePerZone.get(zoneId).get(offset);
    numPartitionsOnNode.put(node.getId(),numPartitions);
    if (numPartitions < node.getNumberOfPartitions()) {
      donorNodes.add(node);
    }
 else     if (numPartitions > node.getNumberOfPartitions()) {
      stealerNodes.add(node);
    }
  }
  for (  Node node : donorNodes) {
    System.out.println("Donor Node: " + node.getId() + ", zoneId "+ node.getZoneId()+ ", numPartitions "+ node.getNumberOfPartitions()+ ", target number of partitions "+ numPartitionsOnNode.get(node.getId()));
  }
  for (  Node node : stealerNodes) {
    System.out.println("Stealer Node: " + node.getId() + ", zoneId "+ node.getZoneId()+ ", numPartitions "+ node.getNumberOfPartitions()+ ", target number of partitions "+ numPartitionsOnNode.get(node.getId()));
  }
  Cluster returnCluster=updateCluster(targetCluster,allNodes);
  int totalPrimaryPartitionsMoved=0;
  for (  Node stealerNode : stealerNodes) {
    int partitionsToSteal=numPartitionsOnNode.get(stealerNode.getId()) - stealerNode.getNumberOfPartitions();
    System.out.println("Node (" + stealerNode.getId() + ") in zone ("+ stealerNode.getZoneId()+ ") has partitionsToSteal of "+ partitionsToSteal);
    while (partitionsToSteal > 0) {
      for (      Node donorNode : donorNodes) {
        Node currentDonorNode=returnCluster.getNodeById(donorNode.getId());
        if (keepPrimaryPartitionsInSameZone && (currentDonorNode.getZoneId() != stealerNode.getZoneId())) {
          continue;
        }
        if (currentDonorNode.getNumberOfPartitions() == numPartitionsOnNode.get(currentDonorNode.getId())) {
          continue;
        }
        List<Integer> donorPartitions=Lists.newArrayList(currentDonorNode.getPartitionIds());
        Collections.shuffle(donorPartitions,new Random(System.currentTimeMillis()));
        for (        int donorPartition : donorPartitions) {
          Cluster intermediateCluster=createUpdatedCluster(returnCluster,stealerNode.getId(),Lists.newArrayList(donorPartition));
          int crossZoneMoves=0;
          if (!permitCrossZoneMoves) {
            long startTimeNs=System.nanoTime();
            crossZoneMoves=RebalanceUtils.getCrossZoneMoves(intermediateCluster,new RebalanceClusterPlan(returnCluster,intermediateCluster,storeDefs,true));
            System.out.println("getCrossZoneMoves took " + (System.nanoTime() - startTimeNs) + " ns.");
          }
          if (crossZoneMoves == 0) {
            returnCluster=intermediateCluster;
            totalPrimaryPartitionsMoved++;
            partitionsToSteal--;
            System.out.println("Stealer node " + stealerNode.getId() + ", donor node "+ currentDonorNode.getId()+ ", partition stolen "+ donorPartition);
            break;
          }
 else {
            System.out.println("Stealer node " + stealerNode.getId() + ", donor node "+ currentDonorNode.getId()+ ", attempted to steal partition "+ donorPartition+ " however,  getCrossZoneMoves did NOT return 0!");
          }
        }
        if (partitionsToSteal == 0)         break;
      }
    }
  }
  return Pair.create(returnCluster,totalPrimaryPartitionsMoved);
}
