{
  HashMap<Integer,Cluster> currentClusters=Maps.newHashMap();
  Versioned<Cluster> latestCluster=new Versioned<Cluster>(cluster);
  ArrayList<Versioned<Cluster>> clusterList=new ArrayList<Versioned<Cluster>>();
  clusterList.add(latestCluster);
  for (  Node node : cluster.getNodes()) {
    try {
      Versioned<Cluster> versionedCluster=adminClient.getRemoteCluster(node.getId());
      VectorClock newClock=(VectorClock)versionedCluster.getVersion();
      currentClusters.put(node.getId(),versionedCluster.getValue());
      if (null != newClock && !clusterList.contains(versionedCluster)) {
        checkNotConcurrent(clusterList,newClock);
        clusterList.add(versionedCluster);
        Occurred occurred=newClock.compare(latestCluster.getVersion());
        if (Occurred.AFTER.equals(occurred))         latestCluster=versionedCluster;
      }
    }
 catch (    Exception e) {
      throw new VoldemortException("Failed to get cluster version from node " + node.getId(),e);
    }
  }
  VectorClock latestClock=((VectorClock)latestCluster.getVersion()).incremented(0,System.currentTimeMillis());
  Set<Integer> completedNodeIds=Sets.newHashSet();
  try {
    for (    Node node : cluster.getNodes()) {
      logger.info("Updating cluster definition on remote node " + node);
      adminClient.updateRemoteCluster(node.getId(),cluster,latestClock);
      logger.info("Updated cluster definition " + cluster + " on remote node "+ node.getId());
      completedNodeIds.add(node.getId());
    }
  }
 catch (  VoldemortException e) {
    for (    Integer completedNodeId : completedNodeIds) {
      try {
        adminClient.updateRemoteCluster(completedNodeId,currentClusters.get(completedNodeId),latestClock);
      }
 catch (      VoldemortException exception) {
        logger.error("Could not revert cluster metadata back on node " + completedNodeId);
      }
    }
    throw e;
  }
}
