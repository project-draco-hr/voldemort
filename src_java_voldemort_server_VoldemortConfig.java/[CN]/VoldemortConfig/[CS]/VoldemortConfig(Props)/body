{
  try {
    this.nodeId=props.getInt("node.id");
  }
 catch (  UndefinedPropertyException e) {
    this.nodeId=getIntEnvVariable(VOLDEMORT_NODE_ID_VAR_NAME);
  }
  this.voldemortHome=props.getString("voldemort.home");
  this.dataDirectory=props.getString("data.directory",this.voldemortHome + File.separator + "data");
  this.metadataDirectory=props.getString("metadata.directory",voldemortHome + File.separator + "config");
  this.bdbCacheSize=props.getBytes("bdb.cache.size",200 * 1024 * 1024);
  this.bdbWriteTransactions=props.getBoolean("bdb.write.transactions",false);
  this.bdbFlushTransactions=props.getBoolean("bdb.flush.transactions",false);
  this.bdbDataDirectory=props.getString("bdb.data.directory",this.dataDirectory + File.separator + "bdb");
  this.bdbMaxLogFileSize=props.getBytes("bdb.max.logfile.size",60 * 1024 * 1024);
  this.bdbBtreeFanout=props.getInt("bdb.btree.fanout",512);
  this.bdbCheckpointBytes=props.getLong("bdb.checkpoint.interval.bytes",200 * 1024 * 1024);
  this.bdbCheckpointMs=props.getLong("bdb.checkpoint.interval.ms",30 * Time.MS_PER_SECOND);
  this.bdbOneEnvPerStore=props.getBoolean("bdb.one.env.per.store",false);
  this.bdbCleanerMinFileUtilization=props.getInt("bdb.cleaner.min.file.utilization",5);
  this.bdbCleanerMinUtilization=props.getInt("bdb.cleaner.minUtilization",50);
  this.bdbCleanerThreads=props.getInt("bdb.cleaner.threads",1);
  this.bdbCleanerBytesInterval=props.getLong("bdb.cleaner.interval.bytes",this.bdbMaxLogFileSize);
  this.bdbCleanerLookAheadCacheSize=props.getInt("bdb.cleaner.lookahead.cache.size",8192);
  this.bdbLockTimeoutMs=props.getLong("bdb.lock.timeout.ms",500);
  this.bdbLockNLockTables=props.getInt("bdb.lock.nLockTables",1);
  this.bdbLogFaultReadSize=props.getInt("bdb.log.fault.read.size",2048);
  this.bdbLogIteratorReadSize=props.getInt("bdb.log.iterator.read.size",8192);
  this.bdbFairLatches=props.getBoolean("bdb.fair.latches",false);
  this.bdbCheckpointerHighPriority=props.getBoolean("bdb.checkpointer.high.priority",false);
  this.bdbCleanerMaxBatchFiles=props.getInt("bdb.cleaner.max.batch.files",0);
  this.bdbReadUncommitted=props.getBoolean("bdb.lock.read_uncommitted",true);
  this.bdbStatsCacheTtlMs=props.getLong("bdb.stats.cache.ttl.ms",5 * Time.MS_PER_SECOND);
  this.bdbExposeSpaceUtilization=props.getBoolean("bdb.expose.space.utilization",true);
  this.bdbMinimumSharedCache=props.getLong("bdb.minimum.shared.cache",0);
  this.bdbCleanerLazyMigration=props.getBoolean("bdb.cleaner.lazy.migration",true);
  this.bdbCacheModeEvictLN=props.getBoolean("bdb.cache.evictln",false);
  this.bdbMinimizeScanImpact=props.getBoolean("bdb.minimize.scan.impact",false);
  this.bdbPrefixKeysWithPartitionId=props.getBoolean("bdb.prefix.keys.with.partitionid",true);
  this.bdbLevelBasedEviction=props.getBoolean("bdb.evict.by.level",false);
  this.bdbProactiveBackgroundMigration=props.getBoolean("bdb.proactive.background.migration",false);
  this.readOnlyBackups=props.getInt("readonly.backups",1);
  this.readOnlySearchStrategy=props.getString("readonly.search.strategy",BinarySearchStrategy.class.getName());
  this.readOnlyStorageDir=props.getString("readonly.data.directory",this.dataDirectory + File.separator + "read-only");
  this.readOnlyDeleteBackupTimeMs=props.getInt("readonly.delete.backup.ms",0);
  this.maxBytesPerSecond=props.getBytes("fetcher.max.bytes.per.sec",0);
  this.minBytesPerSecond=props.getBytes("fetcher.min.bytes.per.sec",0);
  this.reportingIntervalBytes=props.getBytes("fetcher.reporting.interval.bytes",REPORTING_INTERVAL_BYTES);
  this.fetcherBufferSize=(int)props.getBytes("hdfs.fetcher.buffer.size",DEFAULT_BUFFER_SIZE);
  this.readOnlyKeytabPath=props.getString("readonly.keytab.path",this.metadataDirectory + VoldemortConfig.DEFAULT_KEYTAB_PATH);
  this.readOnlyKerberosUser=props.getString("readonly.kerberos.user",VoldemortConfig.DEFAULT_KERBEROS_PRINCIPAL);
  this.setHadoopConfigPath(props.getString("readonly.hadoop.config.path",this.metadataDirectory + "/hadoop-conf"));
  this.setUseMlock(props.getBoolean("readonly.mlock.index",true));
  this.mysqlUsername=props.getString("mysql.user","root");
  this.mysqlPassword=props.getString("mysql.password","");
  this.mysqlHost=props.getString("mysql.host","localhost");
  this.mysqlPort=props.getInt("mysql.port",3306);
  this.mysqlDatabaseName=props.getString("mysql.database","voldemort");
  this.testingSlowQueueingDelays=new OpTimeMap(0);
  this.testingSlowQueueingDelays.setOpTime(VoldemortOpCode.GET_OP_CODE,props.getInt("testing.slow.queueing.get.ms",0));
  this.testingSlowQueueingDelays.setOpTime(VoldemortOpCode.GET_ALL_OP_CODE,props.getInt("testing.slow.queueing.getall.ms",0));
  this.testingSlowQueueingDelays.setOpTime(VoldemortOpCode.GET_VERSION_OP_CODE,props.getInt("testing.slow.queueing.getversions.ms",0));
  this.testingSlowQueueingDelays.setOpTime(VoldemortOpCode.PUT_OP_CODE,props.getInt("testing.slow.queueing.put.ms",0));
  this.testingSlowQueueingDelays.setOpTime(VoldemortOpCode.DELETE_OP_CODE,props.getInt("testing.slow.queueing.delete.ms",0));
  this.testingSlowConcurrentDelays=new OpTimeMap(0);
  this.testingSlowConcurrentDelays.setOpTime(VoldemortOpCode.GET_OP_CODE,props.getInt("testing.slow.concurrent.get.ms",0));
  this.testingSlowConcurrentDelays.setOpTime(VoldemortOpCode.GET_ALL_OP_CODE,props.getInt("testing.slow.concurrent.getall.ms",0));
  this.testingSlowConcurrentDelays.setOpTime(VoldemortOpCode.GET_VERSION_OP_CODE,props.getInt("testing.slow.concurrent.getversions.ms",0));
  this.testingSlowConcurrentDelays.setOpTime(VoldemortOpCode.PUT_OP_CODE,props.getInt("testing.slow.concurrent.put.ms",0));
  this.testingSlowConcurrentDelays.setOpTime(VoldemortOpCode.DELETE_OP_CODE,props.getInt("testing.slow.concurrent.delete.ms",0));
  this.maxThreads=props.getInt("max.threads",100);
  this.coreThreads=props.getInt("core.threads",Math.max(1,maxThreads / 2));
  this.adminMaxThreads=props.getInt("admin.max.threads",20);
  this.adminCoreThreads=props.getInt("admin.core.threads",Math.max(1,adminMaxThreads / 2));
  this.adminStreamBufferSize=(int)props.getBytes("admin.streams.buffer.size",10 * 1000 * 1000);
  this.adminConnectionTimeout=props.getInt("admin.client.connection.timeout.sec",60);
  this.adminSocketTimeout=props.getInt("admin.client.socket.timeout.sec",24 * 60 * 60);
  this.streamMaxReadBytesPerSec=props.getBytes("stream.read.byte.per.sec",10 * 1000 * 1000);
  this.streamMaxWriteBytesPerSec=props.getBytes("stream.write.byte.per.sec",10 * 1000 * 1000);
  this.socketTimeoutMs=props.getInt("socket.timeout.ms",5000);
  this.socketBufferSize=(int)props.getBytes("socket.buffer.size",64 * 1024);
  this.socketKeepAlive=props.getBoolean("socket.keepalive",false);
  this.useNioConnector=props.getBoolean("enable.nio.connector",true);
  this.nioConnectorSelectors=props.getInt("nio.connector.selectors",Math.max(8,Runtime.getRuntime().availableProcessors()));
  this.nioAdminConnectorSelectors=props.getInt("nio.admin.connector.selectors",Math.max(8,Runtime.getRuntime().availableProcessors()));
  this.nioAcceptorBacklog=props.getInt("nio.acceptor.backlog",-1);
  this.clientSelectors=props.getInt("client.selectors",4);
  this.clientMaxConnectionsPerNode=props.getInt("client.max.connections.per.node",50);
  this.clientConnectionTimeoutMs=props.getInt("client.connection.timeout.ms",500);
  this.clientRoutingTimeoutMs=props.getInt("client.routing.timeout.ms",15000);
  this.clientTimeoutConfig=new TimeoutConfig(this.clientRoutingTimeoutMs,false);
  this.clientTimeoutConfig.setOperationTimeout(VoldemortOpCode.GET_OP_CODE,props.getInt("client.routing.get.timeout.ms",this.clientRoutingTimeoutMs));
  this.clientTimeoutConfig.setOperationTimeout(VoldemortOpCode.GET_ALL_OP_CODE,props.getInt("client.routing.getall.timeout.ms",this.clientRoutingTimeoutMs));
  this.clientTimeoutConfig.setOperationTimeout(VoldemortOpCode.PUT_OP_CODE,props.getInt("client.routing.put.timeout.ms",this.clientRoutingTimeoutMs));
  this.clientTimeoutConfig.setOperationTimeout(VoldemortOpCode.GET_VERSION_OP_CODE,props.getLong("client.routing.getversions.timeout.ms",this.clientTimeoutConfig.getOperationTimeout(VoldemortOpCode.PUT_OP_CODE)));
  this.clientTimeoutConfig.setOperationTimeout(VoldemortOpCode.DELETE_OP_CODE,props.getInt("client.routing.delete.timeout.ms",this.clientRoutingTimeoutMs));
  this.clientTimeoutConfig.setPartialGetAllAllowed(props.getBoolean("client.routing.allow.partial.getall",false));
  this.clientMaxThreads=props.getInt("client.max.threads",500);
  this.clientThreadIdleMs=props.getInt("client.thread.idle.ms",100000);
  this.clientMaxQueuedRequests=props.getInt("client.max.queued.requests",1000);
  this.enableHttpServer=props.getBoolean("http.enable",true);
  this.enableSocketServer=props.getBoolean("socket.enable",true);
  this.enableAdminServer=props.getBoolean("admin.enable",true);
  this.enableJmx=props.getBoolean("jmx.enable",true);
  this.enablePipelineRoutedStore=props.getBoolean("enable.pipeline.routed.store",true);
  this.enableSlop=props.getBoolean("slop.enable",true);
  this.enableSlopPusherJob=props.getBoolean("slop.pusher.enable",true);
  this.slopMaxWriteBytesPerSec=props.getBytes("slop.write.byte.per.sec",10 * 1000 * 1000);
  this.enableVerboseLogging=props.getBoolean("enable.verbose.logging",true);
  this.enableStatTracking=props.getBoolean("enable.stat.tracking",true);
  this.enableServerRouting=props.getBoolean("enable.server.routing",true);
  this.enableMetadataChecking=props.getBoolean("enable.metadata.checking",true);
  this.enableGossip=props.getBoolean("enable.gossip",false);
  this.enableRebalanceService=props.getBoolean("enable.rebalancing",true);
  this.enableRepair=props.getBoolean("enable.repair",true);
  this.enableJmxClusterName=props.getBoolean("enable.jmx.clustername",false);
  this.gossipInterval=props.getInt("gossip.interval.ms",30 * 1000);
  this.slopMaxWriteBytesPerSec=props.getBytes("slop.write.byte.per.sec",10 * 1000 * 1000);
  this.slopMaxReadBytesPerSec=props.getBytes("slop.read.byte.per.sec",10 * 1000 * 1000);
  this.slopStoreType=props.getString("slop.store.engine",BdbStorageConfiguration.TYPE_NAME);
  this.slopFrequencyMs=props.getLong("slop.frequency.ms",5 * 60 * 1000);
  this.repairStartMs=props.getLong("repair.start.ms",24 * 60 * 60* 1000);
  this.slopBatchSize=props.getInt("slop.batch.size",100);
  this.pusherType=props.getString("pusher.type",StreamingSlopPusherJob.TYPE_NAME);
  this.slopZonesDownToTerminate=props.getInt("slop.zones.terminate",0);
  this.schedulerThreads=props.getInt("scheduler.threads",6);
  this.mayInterruptService=props.getBoolean("service.interruptible",true);
  this.numScanPermits=props.getInt("num.scan.permits",1);
  this.storageConfigurations=props.getList("storage.configs",ImmutableList.of(BdbStorageConfiguration.class.getName(),MysqlStorageConfiguration.class.getName(),InMemoryStorageConfiguration.class.getName(),CacheStorageConfiguration.class.getName(),ReadOnlyStorageConfiguration.class.getName()));
  this.retentionCleanupFirstStartTimeInHour=props.getInt("retention.cleanup.first.start.hour",0);
  this.retentionCleanupFirstStartDayOfWeek=props.getInt("retention.cleanup.first.start.day",Utils.getDayOfTheWeekFromNow(1));
  this.retentionCleanupScheduledPeriodInHour=props.getInt("retention.cleanup.period.hours",24);
  this.retentionCleanupPinStartTime=props.getBoolean("retention.cleanup.pin.start.time",true);
  this.enforceRetentionPolicyOnRead=props.getBoolean("enforce.retention.policy.on.read",false);
  this.deleteExpiredValuesOnRead=props.getBoolean("delete.expired.values.on.read",false);
  this.allProps=props;
  String requestFormatName=props.getString("request.format",RequestFormatType.VOLDEMORT_V1.getCode());
  this.requestFormatType=RequestFormatType.fromCode(requestFormatName);
  this.maxRebalancingAttempt=props.getInt("max.rebalancing.attempts",3);
  this.rebalancingTimeoutSec=props.getLong("rebalancing.timeout.seconds",10 * 24 * 60* 60);
  this.maxParallelStoresRebalancing=props.getInt("max.parallel.stores.rebalancing",3);
  this.rebalancingOptimization=props.getBoolean("rebalancing.optimization",true);
  this.usePartitionScanForRebalance=props.getBoolean("use.partition.scan.for.rebalance",true);
  this.failureDetectorImplementation=props.getString("failuredetector.implementation",FailureDetectorConfig.DEFAULT_IMPLEMENTATION_CLASS_NAME);
  if (props.containsKey("client.node.bannage.ms") && !props.containsKey("failuredetector.bannage.period")) {
    props.put("failuredetector.bannage.period",props.get("client.node.bannage.ms"));
  }
  this.failureDetectorBannagePeriod=props.getLong("failuredetector.bannage.period",FailureDetectorConfig.DEFAULT_BANNAGE_PERIOD);
  this.failureDetectorThreshold=props.getInt("failuredetector.threshold",FailureDetectorConfig.DEFAULT_THRESHOLD);
  this.failureDetectorThresholdCountMinimum=props.getInt("failuredetector.threshold.countminimum",FailureDetectorConfig.DEFAULT_THRESHOLD_COUNT_MINIMUM);
  this.failureDetectorThresholdInterval=props.getLong("failuredetector.threshold.interval",FailureDetectorConfig.DEFAULT_THRESHOLD_INTERVAL);
  this.failureDetectorAsyncRecoveryInterval=props.getLong("failuredetector.asyncrecovery.interval",FailureDetectorConfig.DEFAULT_ASYNC_RECOVERY_INTERVAL);
  this.failureDetectorCatastrophicErrorTypes=props.getList("failuredetector.catastrophic.error.types",FailureDetectorConfig.DEFAULT_CATASTROPHIC_ERROR_TYPES);
  this.failureDetectorRequestLengthThreshold=props.getLong("failuredetector.request.length.threshold",getSocketTimeoutMs());
  this.enableNetworkClassLoader=props.getBoolean("enable.network.classloader",false);
  validateParams();
}
