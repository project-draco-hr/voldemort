{
  this.request=request;
  StoreDefinition storeDef=metadataStore.getStoreDef(request.getStore());
  boolean isReadOnly=storeDef.getType().compareTo(ReadOnlyStorageConfiguration.TYPE_NAME) == 0;
  if (!isReadOnly) {
    throw new VoldemortException("Should be fetching partition files only for read-only stores");
  }
  ReadOnlyStorageEngine storageEngine=AdminServiceRequestHandler.getReadOnlyStorageEngine(metadataStore,storeRepository,request.getStore());
  HashMap<Integer,List<Integer>> localReplicaToPartitionList=ProtoUtils.decodePartitionTuple(request.getReplicaToPartitionList());
  this.replicaToPartitionList=Lists.newArrayList();
  for (int replicaType=0; replicaType < storeDef.getReplicationFactor(); replicaType++) {
    if (localReplicaToPartitionList.containsKey(replicaType)) {
      List<Integer> partitionList=localReplicaToPartitionList.get(replicaType);
      for (Iterator<Integer> it=partitionList.iterator(); it.hasNext(); ) {
        this.replicaToPartitionList.add(new Pair<Integer,Integer>(replicaType,it.next()));
      }
    }
  }
  this.blockSize=voldemortConfig.getAllProps().getLong("partition.buffer.size.bytes",voldemortConfig.getAdminSocketBufferSize());
  this.storeDir=new File(storageEngine.getCurrentDirPath());
  this.throttler=new EventThrottler(voldemortConfig.getStreamMaxReadBytesPerSec());
  this.stats=stats;
  this.handle=stats.makeHandle(StreamStats.Operation.FETCH_FILE,RebalanceUtils.flattenPartitionTuples(new HashSet<Pair<Integer,Integer>>(replicaToPartitionList)));
  this.partitionIterator=Collections.unmodifiableList(replicaToPartitionList).iterator();
  this.fetchStatus=FetchStatus.next_partition;
  this.currentChunkId=0;
  this.indexFile=null;
  this.dataFile=null;
  this.chunkedFileWriter=null;
}
