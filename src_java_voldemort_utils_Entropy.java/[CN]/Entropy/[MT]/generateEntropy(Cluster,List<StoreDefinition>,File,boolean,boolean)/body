{
  AdminClient adminClient=null;
  try {
    adminClient=new AdminClient(cluster,new AdminClientConfig().setMaxConnectionsPerNode(storeDefs.size()));
    if (opType) {
      System.out.println("Running entropy calculator");
    }
 else {
      System.out.println("Generating keys for future entropy calculation");
      Utils.mkdirs(storeDir);
    }
    for (    StoreDefinition storeDef : storeDefs) {
      File storesKeyFile=new File(storeDir,storeDef.getName());
      if (AdminClient.restoreStoreEngineBlackList.contains(storeDef.getType())) {
        System.out.println("Ignoring store " + storeDef.getName());
        continue;
      }
 else {
        System.out.println("Working on store " + storeDef.getName());
      }
      RoutingStrategy strategy=new RoutingStrategyFactory().updateRoutingStrategy(storeDef,cluster);
      if (!opType) {
        if (storesKeyFile.exists()) {
          System.err.println("Key files for " + storeDef.getName() + " already exists");
          continue;
        }
        FileOutputStream writer=null;
        try {
          writer=new FileOutputStream(storesKeyFile);
          Iterator<ByteArray> keys=null;
          if (nodeId == -1) {
            int numKeysPerNode=(int)Math.floor(numKeys / cluster.getNumberOfNodes());
            for (            Node node : cluster.getNodes()) {
              keys=adminClient.fetchKeys(node.getId(),storeDef.getName(),cluster.getNodeById(node.getId()).getPartitionIds(),null,false);
              for (long keyId=0; keyId < numKeysPerNode && keys.hasNext(); keyId++) {
                ByteArray key=keys.next();
                if (RebalanceUtils.getNodeIds(strategy.routeRequest(key.get())).contains(node.getId())) {
                  writer.write(key.length());
                  writer.write(key.get());
                }
              }
            }
          }
 else {
            List<Integer> partitions=cluster.getNodeById(nodeId).getPartitionIds();
            Map<Integer,Integer> partitionMap=new HashMap<Integer,Integer>();
            int numKeysPerPartition=(int)Math.floor(numKeys / partitions.size());
            int numKeysStored=0;
            for (            int partitionId : partitions) {
              partitionMap.put(partitionId,0);
            }
            keys=adminClient.fetchKeys(nodeId,storeDef.getName(),partitions,null,false);
            while (keys.hasNext() && numKeysStored < numKeys) {
              ByteArray key=keys.next();
              if (RebalanceUtils.getNodeIds(strategy.routeRequest(key.get())).contains(nodeId)) {
                int targetPartition=strategy.getPartitionList(key.get()).get(0);
                int partitionCount=partitionMap.get(targetPartition);
                if (partitionCount == numKeysPerPartition)                 continue;
                writer.write(key.length());
                writer.write(key.get());
                partitionMap.put(targetPartition,partitionCount + 1);
                numKeysStored++;
              }
            }
            System.out.println("Total partitions filled : " + partitions.size());
            for (            int partitionId : partitions) {
              System.out.println("Count in partition #" + partitionId + " = "+ partitionMap.get(partitionId));
            }
          }
        }
  finally {
          if (writer != null)           writer.close();
        }
      }
 else {
        if (negativeTest && nodeId == -1)         return;
        if (!(storesKeyFile.exists() && storesKeyFile.canRead())) {
          System.err.println("Could not find " + storeDef.getName() + " file to check");
          continue;
        }
        FileInputStream reader=null;
        SocketStoreFactory socketStoreFactory=new ClientRequestExecutorPool(2,10000,100000,32 * 1024);
        HashMap<Integer,Store<ByteArray,byte[],byte[]>> socketStoresPerNode=Maps.newHashMap();
        for (        Node node : cluster.getNodes()) {
          socketStoresPerNode.put(node.getId(),socketStoreFactory.create(storeDef.getName(),node.getHost(),node.getSocketPort(),RequestFormatType.PROTOCOL_BUFFERS,RequestRoutingType.IGNORE_CHECKS));
        }
        long deletedKeys=0L;
        long foundKeys=0L;
        long totalKeys=0L;
        try {
          reader=new FileInputStream(storesKeyFile);
          while (reader.available() != 0) {
            int size=reader.read();
            if (size <= 0) {
              break;
            }
            byte[] key=new byte[size];
            reader.read(key);
            List<Node> responsibleNodes=strategy.routeRequest(key);
            if (!negativeTest) {
              boolean missingKey=false;
              for (              Node node : responsibleNodes) {
                List<Versioned<byte[]>> value=socketStoresPerNode.get(node.getId()).get(new ByteArray(key),null);
                if (value == null || value.size() == 0) {
                  missingKey=true;
                }
              }
              if (!missingKey)               foundKeys++;
              totalKeys++;
            }
 else {
              if (!responsibleNodes.contains(cluster.getNodeById(nodeId))) {
                List<Versioned<byte[]>> value=socketStoresPerNode.get(nodeId).get(new ByteArray(key),null);
                if (value == null || value.size() == 0) {
                  deletedKeys++;
                }
                totalKeys++;
              }
            }
          }
          if (!negativeTest) {
            System.out.println("Found = " + foundKeys + " Total = "+ totalKeys);
            if (foundKeys > 0 && totalKeys > 0) {
              System.out.println("%age found - " + 100.0 * (double)foundKeys / totalKeys);
            }
          }
 else {
            System.out.println("Deleted = " + deletedKeys + " Total = "+ totalKeys);
            if (deletedKeys > 0 && totalKeys > 0) {
              System.out.println("%age deleted - " + 100.0 * (double)deletedKeys / totalKeys);
            }
          }
        }
  finally {
          if (reader != null)           reader.close();
          for (          Store<ByteArray,byte[],byte[]> store : socketStoresPerNode.values()) {
            store.close();
          }
        }
      }
    }
  }
  finally {
    if (adminClient != null)     adminClient.stop();
  }
}
