{
  List<Integer> singlePartition=new ArrayList<Integer>();
  singlePartition.add(partitionId);
  if (verbose) {
    System.out.println("Connecting to bootstrap server: " + url);
  }
  AdminClient adminClient=new AdminClient(url,new AdminClientConfig(),0);
  Cluster cluster=adminClient.getAdminClientCluster();
  Versioned<List<StoreDefinition>> storeDefinitions=adminClient.getRemoteStoreDefList(0);
  List<StoreDefinition> StoreDefitions=storeDefinitions.getValue();
  StoreDefinition storeDefinition=null;
  for (  StoreDefinition def : StoreDefitions) {
    if (def.getName().equals(storeName)) {
      storeDefinition=def;
      break;
    }
  }
  if (storeDefinition == null) {
    throw new Exception("No such store found: " + storeName);
  }
  RetentionChecker retentionChecker;
  int retentionDays=0;
  if (storeDefinition.getRetentionDays() != null) {
    retentionDays=storeDefinition.getRetentionDays().intValue();
  }
  retentionChecker=new RetentionChecker(retentionDays);
  SortedMap<Integer,Node> partitionToNodeMap=new TreeMap<Integer,Node>();
  Collection<Node> nodes=cluster.getNodes();
  for (  Node n : nodes) {
    for (    Integer partition : n.getPartitionIds()) {
      if (partitionToNodeMap.containsKey(partition))       throw new IllegalArgumentException("Duplicate partition id " + partition + " in cluster configuration "+ nodes);
      partitionToNodeMap.put(partition,n);
    }
  }
  List<Integer> partitionList=new RoutingStrategyFactory().updateRoutingStrategy(storeDefinition,cluster).getReplicatingPartitionList(partitionId);
  List<Integer> nodeIdList=new ArrayList<Integer>(partitionList.size());
  for (  int partition : partitionList) {
    Integer nodeId=partitionToNodeMap.get(partition).getId();
    nodeIdList.add(nodeId);
  }
  Map<Integer,Set<Integer>> zoneToNodeIds=new HashMap<Integer,Set<Integer>>();
  for (  Integer nodeId : nodeIdList) {
    Integer zoneId=cluster.getNodeById(nodeId).getZoneId();
    if (!zoneToNodeIds.containsKey(zoneId)) {
      zoneToNodeIds.put(zoneId,new HashSet<Integer>());
    }
    zoneToNodeIds.get(zoneId).add(nodeId);
  }
  if (verbose) {
    StringBuilder configInfo=new StringBuilder();
    configInfo.append("TYPE,Store,PartitionId,Node,ZoneId\n");
    for (    Integer nodeId : nodeIdList) {
      configInfo.append("CONFIG,");
      configInfo.append(storeName + ",");
      configInfo.append(partitionId + ",");
      configInfo.append(nodeId + ",");
      configInfo.append(cluster.getNodeById(nodeId).getZoneId() + "\n");
    }
    System.out.println(configInfo);
  }
  Map<Integer,Iterator<Pair<ByteArray,Versioned<byte[]>>>> nodeEntriesMap;
  nodeEntriesMap=new HashMap<Integer,Iterator<Pair<ByteArray,Versioned<byte[]>>>>();
  for (  Integer nodeId : nodeIdList) {
    Iterator<Pair<ByteArray,Versioned<byte[]>>> entries;
    entries=adminClient.fetchEntries(nodeId,storeName,singlePartition,null,false);
    nodeEntriesMap.put(nodeId,entries);
  }
  Map<ByteArray,Map<Version,Set<Integer>>> keyVersionNodeSetMap;
  Map<ByteArray,Set<Iterator<Pair<ByteArray,Versioned<byte[]>>>>> fullyFetchedKeys;
  Map<Iterator<Pair<ByteArray,Versioned<byte[]>>>,ByteArray> lastFetchedKey;
  keyVersionNodeSetMap=new HashMap<ByteArray,Map<Version,Set<Integer>>>();
  fullyFetchedKeys=new HashMap<ByteArray,Set<Iterator<Pair<ByteArray,Versioned<byte[]>>>>>();
  lastFetchedKey=new HashMap<Iterator<Pair<ByteArray,Versioned<byte[]>>>,ByteArray>();
  long numRecordsScanned=0;
  long numRecordsScannedLast=0;
  long lastReportTimeMs=0;
  long reportPeriodMs=5000;
  long expiredRecords=0;
  long preQualifiedKeys=0;
  boolean anyNodeHasNext;
  do {
    anyNodeHasNext=false;
    for (    Map.Entry<Integer,Iterator<Pair<ByteArray,Versioned<byte[]>>>> nodeEntriesMapEntry : nodeEntriesMap.entrySet()) {
      Integer nodeId=nodeEntriesMapEntry.getKey();
      Iterator<Pair<ByteArray,Versioned<byte[]>>> nodeEntries=nodeEntriesMapEntry.getValue();
      if (nodeEntries.hasNext()) {
        anyNodeHasNext=true;
        numRecordsScanned++;
        Pair<ByteArray,Versioned<byte[]>> nodeEntry=nodeEntries.next();
        ByteArray key=nodeEntry.getFirst();
        Version version=nodeEntry.getSecond().getVersion();
        if (retentionChecker.isExpired(version)) {
          expiredRecords++;
          continue;
        }
 else {
          if (lastFetchedKey.containsKey(nodeEntries)) {
            ByteArray lastKey=lastFetchedKey.get(nodeEntries);
            if (key != lastKey) {
              if (!fullyFetchedKeys.containsKey(lastKey)) {
                fullyFetchedKeys.put(lastKey,new HashSet<Iterator<Pair<ByteArray,Versioned<byte[]>>>>());
              }
              Set<Iterator<Pair<ByteArray,Versioned<byte[]>>>> lastKeyIterSet=fullyFetchedKeys.get(lastKey);
              lastKeyIterSet.add(nodeEntries);
              if (lastKeyIterSet.size() == nodeIdList.size()) {
                ConsistencyLevel level=determineConsistency(keyVersionNodeSetMap.get(lastKey),storeDefinition);
                if (level == ConsistencyLevel.FULL || level == ConsistencyLevel.LATEST_CONSISTENT) {
                  keyVersionNodeSetMap.remove(lastKey);
                  preQualifiedKeys++;
                }
                fullyFetchedKeys.remove(lastKey);
              }
            }
          }
          lastFetchedKey.put(nodeEntries,key);
          if (!keyVersionNodeSetMap.containsKey(key)) {
            keyVersionNodeSetMap.put(key,new HashMap<Version,Set<Integer>>());
          }
          Map<Version,Set<Integer>> versionNodeSetMap=keyVersionNodeSetMap.get(key);
          if (!versionNodeSetMap.containsKey(version)) {
            Iterator<Version> iter=versionNodeSetMap.keySet().iterator();
            if (iter.hasNext()) {
              Version existingVersion=iter.next();
              if (version.compare(existingVersion) == Occurred.AFTER) {
                versionNodeSetMap=new HashMap<Version,Set<Integer>>();
                keyVersionNodeSetMap.put(key,versionNodeSetMap);
              }
 else               if (existingVersion.compare(version) == Occurred.AFTER) {
                continue;
              }
 else               if (existingVersion.compare(version) == Occurred.CONCURRENTLY) {
              }
 else {
                System.err.print("[ERROR]Two versions are not after each other nor currently(key, v1, v2)");
                System.err.print(key + ", " + existingVersion+ ", "+ version);
              }
            }
            versionNodeSetMap.put(version,new HashSet<Integer>());
          }
          Set<Integer> nodeSet=versionNodeSetMap.get(version);
          nodeSet.add(nodeId);
        }
      }
    }
    if (verbose && System.currentTimeMillis() > lastReportTimeMs + reportPeriodMs) {
      long currentTimeMs=System.currentTimeMillis();
      System.out.println("Progress Report");
      System.out.println("===============");
      System.out.println("    Number of records Scanned: " + numRecordsScanned);
      System.out.println("   Records Ignored(Retention): " + expiredRecords);
      System.out.println("Recent fetch speed(records/s): " + (numRecordsScanned - numRecordsScannedLast) / ((currentTimeMs - lastReportTimeMs) / 1000));
      System.out.println();
      lastReportTimeMs=currentTimeMs;
      numRecordsScannedLast=numRecordsScanned;
    }
  }
 while (anyNodeHasNext);
  if (verbose) {
    System.out.println("Analyzing....");
  }
  cleanIneligibleKeys(keyVersionNodeSetMap,storeDefinition.getRequiredWrites());
  Set<ByteArray> keysToDelete=new HashSet<ByteArray>();
  for (  ByteArray key : keyVersionNodeSetMap.keySet()) {
    ConsistencyLevel level=determineConsistency(keyVersionNodeSetMap.get(key),storeDefinition);
    if (level == ConsistencyLevel.FULL || level == ConsistencyLevel.LATEST_CONSISTENT) {
      keysToDelete.add(key);
    }
  }
  for (  ByteArray key : keysToDelete) {
    keyVersionNodeSetMap.remove(key);
    preQualifiedKeys++;
  }
  long totalKeys=keyVersionNodeSetMap.size() + preQualifiedKeys;
  long totalKeysConsistent=preQualifiedKeys;
  if (verbose) {
    System.out.println("TYPE,Store,ParId,Key,ServerSet,VersionTS,VectorClock,ConsistentyLevel");
    for (    Map.Entry<ByteArray,Map<Version,Set<Integer>>> entry : keyVersionNodeSetMap.entrySet()) {
      ByteArray key=entry.getKey();
      Map<Version,Set<Integer>> versionMap=entry.getValue();
      System.out.println(keyVersionToString(key,versionMap,storeName,partitionId));
    }
  }
  ConsistencyCheckStats stats=new ConsistencyCheckStats();
  stats.setConsistentKeys(totalKeysConsistent);
  stats.setTotalKeys(totalKeys);
  return stats;
}
