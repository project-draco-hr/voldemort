{
  JsonSchema schema=HadoopUtils.getSchemaFromPath(getInputPath());
  int replicationFactor=props.getInt("build.replication.factor",2);
  int requiredReads=props.getInt("build.required.reads",1);
  int requiredWrites=props.getInt("build.required.writes",1);
  String description=props.getString("push.store.description","");
  String owners=props.getString("push.store.owners","");
  String keySchema="\n\t\t<type>json</type>\n\t\t<schema-info version=\"0\">" + schema.getKeyType() + "</schema-info>\n\t";
  if (jsonKeyField != null && jsonKeyField.length() > 0)   keySchema="\n\t\t<type>json</type>\n\t\t<schema-info version=\"0\">" + schema.getKeyType().subtype(jsonKeyField) + "</schema-info>\n\t";
  String valSchema="\n\t\t<type>json</type>\n\t\t<schema-info version=\"0\">" + schema.getValueType() + "</schema-info>\n\t";
  if (jsonValueField != null && jsonValueField.length() > 0)   valSchema="\n\t\t<type>json</type>\n\t\t<schema-info version=\"0\">" + schema.getValueType().subtype(jsonValueField) + "</schema-info>\n\t";
  boolean hasCompression=false;
  if (props.containsKey("build.compress.value"))   hasCompression=true;
  if (hasCompression) {
    valSchema+="\t<compression><type>gzip</type></compression>\n\t";
  }
  if (props.containsKey("build.force.schema.key")) {
    keySchema=props.get("build.force.schema.key");
  }
  if (props.containsKey("build.force.schema.value")) {
    valSchema=props.get("build.force.schema.value");
  }
  String newStoreDefXml=VoldemortUtils.getStoreDefXml(storeName,replicationFactor,requiredReads,requiredWrites,props.containsKey("build.preferred.reads") ? props.getInt("build.preferred.reads") : null,props.containsKey("build.preferred.writes") ? props.getInt("build.preferred.writes") : null,(props.containsKey("push.force.schema.key")) ? props.getString("push.force.schema.key") : keySchema,(props.containsKey("push.force.schema.value")) ? props.getString("push.force.schema.value") : valSchema,description,owners);
  log.info("Verifying store: \n" + newStoreDefXml.toString());
  StoreDefinition newStoreDef=VoldemortUtils.getStoreDef(newStoreDefXml);
  log.info("Getting store definition from: " + url + " (node id "+ this.nodeId+ ")");
  AdminClient adminClient=new AdminClient(url,new AdminClientConfig(),new ClientConfig());
  try {
    List<StoreDefinition> remoteStoreDefs=adminClient.metadataMgmtOps.getRemoteStoreDefList(this.nodeId).getValue();
    boolean foundStore=false;
    for (    StoreDefinition remoteStoreDef : remoteStoreDefs) {
      if (remoteStoreDef.getName().equals(storeName)) {
        if (!remoteStoreDef.equals(newStoreDef)) {
          SerializerDefinition localKeySerializerDef=newStoreDef.getKeySerializer();
          SerializerDefinition localValueSerializerDef=newStoreDef.getValueSerializer();
          SerializerDefinition remoteKeySerializerDef=remoteStoreDef.getKeySerializer();
          SerializerDefinition remoteValueSerializerDef=remoteStoreDef.getValueSerializer();
          if (remoteKeySerializerDef.getName().equals("json") && remoteValueSerializerDef.getName().equals("json") && remoteKeySerializerDef.getAllSchemaInfoVersions().size() == 1 && remoteValueSerializerDef.getAllSchemaInfoVersions().size() == 1) {
            JsonTypeDefinition remoteKeyDef=JsonTypeDefinition.fromJson(remoteKeySerializerDef.getCurrentSchemaInfo());
            JsonTypeDefinition remoteValDef=JsonTypeDefinition.fromJson(remoteValueSerializerDef.getCurrentSchemaInfo());
            JsonTypeDefinition localKeyDef=JsonTypeDefinition.fromJson(localKeySerializerDef.getCurrentSchemaInfo());
            JsonTypeDefinition localValDef=JsonTypeDefinition.fromJson(localValueSerializerDef.getCurrentSchemaInfo());
            if (remoteKeyDef.equals(localKeyDef) && remoteValDef.equals(localValDef)) {
              String compressionPolicy="";
              if (hasCompression) {
                compressionPolicy="\n\t\t<compression><type>gzip</type></compression>";
              }
              newStoreDefXml=VoldemortUtils.getStoreDefXml(storeName,replicationFactor,requiredReads,requiredWrites,props.containsKey("build.preferred.reads") ? props.getInt("build.preferred.reads") : null,props.containsKey("build.preferred.writes") ? props.getInt("build.preferred.writes") : null,"\n\t\t<type>json</type>\n\t\t<schema-info version=\"0\">" + remoteKeySerializerDef.getCurrentSchemaInfo() + "</schema-info>\n\t","\n\t\t<type>json</type>\n\t\t<schema-info version=\"0\">" + remoteValueSerializerDef.getCurrentSchemaInfo() + "</schema-info>"+ compressionPolicy+ "\n\t");
              newStoreDef=VoldemortUtils.getStoreDef(newStoreDefXml);
              if (!remoteStoreDef.equals(newStoreDef)) {
                throw new RuntimeException("Your store schema is identical, but the store definition does not match. Have: " + newStoreDef + "\nBut expected: "+ remoteStoreDef);
              }
            }
 else {
              throw new RuntimeException("Your store definition does not match the store definition that is already in the cluster. Tried to resolve identical schemas between local and remote, but failed. Have: " + newStoreDef + "\nBut expected: "+ remoteStoreDef);
            }
          }
 else {
            throw new RuntimeException("Your store definition does not match the store definition that is already in the cluster. Have: " + newStoreDef + "\nBut expected: "+ remoteStoreDef);
          }
        }
        foundStore=true;
        break;
      }
    }
    if (!foundStore) {
      if (description.length() == 0) {
        throw new RuntimeException("Description field missing in store definition. " + "Please add \"push.store.description\" with a line describing your store");
      }
      if (owners.length() == 0) {
        throw new RuntimeException("Owner field missing in store definition. " + "Please add \"push.store.owners\" with value being comma-separated list of LinkedIn email ids");
      }
      log.info("Could not find store " + storeName + " on Voldemort. Adding it to all nodes ");
      adminClient.storeMgmtOps.addStore(newStoreDef);
    }
    storeDefs=ImmutableList.of(VoldemortUtils.getStoreDef(VoldemortUtils.getStoreDefXml(storeName,replicationFactor,requiredReads,requiredWrites,props.containsKey("build.preferred.reads") ? props.getInt("build.preferred.reads") : null,props.containsKey("build.preferred.writes") ? props.getInt("build.preferred.writes") : null,keySchema,valSchema)));
    cluster=adminClient.getAdminClientCluster();
  }
  finally {
    adminClient.close();
  }
}
