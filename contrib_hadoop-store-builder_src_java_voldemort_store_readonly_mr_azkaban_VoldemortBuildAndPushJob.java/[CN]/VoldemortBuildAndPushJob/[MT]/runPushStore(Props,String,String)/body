{
  int httpTimeoutMs=1000 * props.getInt(PUSH_HTTP_TIMEOUT_SECONDS,24 * 60 * 60);
  long pushVersion=props.getLong(PUSH_VERSION,-1L);
  if (props.containsKey(PUSH_VERSION_TIMESTAMP)) {
    DateFormat format=new SimpleDateFormat("yyyyMMddHHmmss");
    pushVersion=Long.parseLong(format.format(new Date()));
  }
  int maxBackoffDelayMs=1000 * props.getInt(PUSH_BACKOFF_DELAY_SECONDS,60);
  List<FailedFetchStrategy> failedFetchStrategyList=Lists.newArrayList();
  int maxNodeFailures=0;
  if (!pushHighAvailability) {
    log.info("pushHighAvailability is disabled by the job config.");
  }
 else {
    try {
      VAdminProto.GetHighAvailabilitySettingsResponse serverSettings=adminClientPerCluster.get(url).readonlyOps.getHighAvailabilitySettings(nodeId);
      if (!serverSettings.getEnabled()) {
        log.warn("The server requested pushHighAvailability to be DISABLED on cluster: " + url);
      }
 else {
        maxNodeFailures=serverSettings.getMaxNodeFailure();
        Class<? extends FailedFetchLock> failedFetchLockClass=(Class<? extends FailedFetchLock>)Class.forName(serverSettings.getLockImplementation());
        Props propsForCluster=new Props(props);
        propsForCluster.put(VoldemortConfig.PUSH_HA_LOCK_PATH,serverSettings.getLockPath());
        propsForCluster.put(VoldemortConfig.PUSH_HA_CLUSTER_ID,serverSettings.getClusterId());
        FailedFetchLock failedFetchLock=ReflectUtils.callConstructor(failedFetchLockClass,new Object[]{propsForCluster});
        failedFetchStrategyList.add(new DisableStoreOnFailedNodeFailedFetchStrategy(adminClientPerCluster.get(url),failedFetchLock,maxNodeFailures,propsForCluster.toString()));
        closeables.add(failedFetchLock);
        log.info("pushHighAvailability is enabled for cluster URL: " + url + " with cluster ID: "+ serverSettings.getClusterId());
      }
    }
 catch (    UninitializedMessageException e) {
      log.error("The server does not support HA (introduced in release 1.9.18), so " + "pushHighAvailability will be DISABLED on cluster: " + url);
    }
catch (    ClassNotFoundException e) {
      log.error("Failed to find requested FailedFetchLock implementation, so " + "pushHighAvailability will be DISABLED on cluster: " + url,e);
    }
catch (    Exception e) {
      log.error("Got exception while trying to determine pushHighAvailability settings on cluster: " + url,e);
    }
  }
  boolean rollback=props.getBoolean(PUSH_ROLLBACK,true);
  if (rollback) {
    failedFetchStrategyList.add(new DeleteAllFailedFetchStrategy(adminClientPerCluster.get(url)));
  }
  Cluster cluster=adminClientPerCluster.get(url).getAdminClientCluster();
  log.info("Push starting for cluster: " + url);
  new VoldemortSwapJob(this.getId() + "-push-store",cluster,dataDir,storeName,httpTimeoutMs,pushVersion,maxBackoffDelayMs,rollback,hdfsFetcherProtocol,hdfsFetcherPort,maxNodeFailures,failedFetchStrategyList,url).run();
}
