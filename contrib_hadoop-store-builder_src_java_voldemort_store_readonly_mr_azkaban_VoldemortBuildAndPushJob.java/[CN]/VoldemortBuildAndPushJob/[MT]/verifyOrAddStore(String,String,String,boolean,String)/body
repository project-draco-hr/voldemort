{
  int replicationFactor=props.getInt(BUILD_REPLICATION_FACTOR,2);
  int requiredReads=props.getInt(BUILD_REQUIRED_READS,1);
  int requiredWrites=props.getInt(BUILD_REQUIRED_WRITES,1);
  String description=props.getString(PUSH_STORE_DESCRIPTION,"");
  String owners=props.getString(PUSH_STORE_OWNERS,"");
  String newStoreDefXml=VoldemortUtils.getStoreDefXml(storeName,replicationFactor,requiredReads,requiredWrites,props.getNullableInt(BUILD_PREFERRED_READS),props.getNullableInt(BUILD_PREFERRED_WRITES),props.getString(PUSH_FORCE_SCHEMA_KEY,keySchema),props.getString(PUSH_FORCE_SCHEMA_VALUE,valueSchema),description,owners);
  log.info("Verifying store against cluster URL: " + clusterURL + "\n"+ newStoreDefXml.toString());
  StoreDefinition newStoreDef=VoldemortUtils.getStoreDef(newStoreDefXml);
  List<Integer> nodesMissingNewStore=Lists.newArrayList();
  for (  Node node : adminClientPerCluster.get(clusterURL).getAdminClientCluster().getNodes()) {
    boolean addStoreToCurrentNode=true;
    int nodeId=node.getId();
    List<StoreDefinition> remoteStoreDefs=Lists.newArrayList();
    try {
      remoteStoreDefs=adminClientPerCluster.get(clusterURL).metadataMgmtOps.getRemoteStoreDefList(nodeId).getValue();
    }
 catch (    UnreachableStoreException e) {
      log.warn("Failed to contact " + node.briefToString() + " in order to validate the StoreDefinition.");
      continue;
    }
    for (    StoreDefinition remoteStoreDef : remoteStoreDefs) {
      if (remoteStoreDef.getName().equals(storeName)) {
        if (remoteStoreDef.equals(newStoreDef)) {
          addStoreToCurrentNode=false;
        }
 else {
          SerializerDefinition localKeySerializerDef=newStoreDef.getKeySerializer();
          SerializerDefinition localValueSerializerDef=newStoreDef.getValueSerializer();
          SerializerDefinition remoteKeySerializerDef=remoteStoreDef.getKeySerializer();
          SerializerDefinition remoteValueSerializerDef=remoteStoreDef.getValueSerializer();
          if (remoteKeySerializerDef.getName().equals(serializerName) && remoteValueSerializerDef.getName().equals(serializerName)) {
            Object remoteKeyDef, remoteValDef, localKeyDef, localValDef;
            if (isAvroJob) {
              remoteKeyDef=Schema.parse(remoteKeySerializerDef.getCurrentSchemaInfo());
              remoteValDef=Schema.parse(remoteValueSerializerDef.getCurrentSchemaInfo());
              localKeyDef=Schema.parse(localKeySerializerDef.getCurrentSchemaInfo());
              localValDef=Schema.parse(localValueSerializerDef.getCurrentSchemaInfo());
            }
 else {
              remoteKeyDef=JsonTypeDefinition.fromJson(remoteKeySerializerDef.getCurrentSchemaInfo());
              remoteValDef=JsonTypeDefinition.fromJson(remoteValueSerializerDef.getCurrentSchemaInfo());
              localKeyDef=JsonTypeDefinition.fromJson(localKeySerializerDef.getCurrentSchemaInfo());
              localValDef=JsonTypeDefinition.fromJson(localValueSerializerDef.getCurrentSchemaInfo());
            }
            boolean serializerDefinitionsAreEqual=remoteKeyDef.equals(localKeyDef) && remoteValDef.equals(localValDef);
            if (serializerDefinitionsAreEqual) {
              newStoreDef=getNewStoreDef(hasCompression,replicationFactor,requiredReads,requiredWrites,serializerName,remoteKeySerializerDef,remoteValueSerializerDef);
              if (remoteStoreDef.equals(newStoreDef)) {
                addStoreToCurrentNode=false;
              }
 else {
                String errorMessage="Your store schema is identical, " + "but the store definition does not match on " + node.briefToString();
                log.error(errorMessage + diffMessage(newStoreDef,remoteStoreDef));
                throw new VoldemortException(errorMessage);
              }
            }
 else {
              String errorMessage="Your data schema does not match the schema which is already " + "defined on " + node.briefToString();
              log.error(errorMessage + diffMessage(newStoreDef,remoteStoreDef));
              throw new VoldemortException(errorMessage);
            }
          }
 else {
            String errorMessage="Your store definition does not match the store definition that is " + "already defined on " + node.briefToString();
            log.error(errorMessage + diffMessage(newStoreDef,remoteStoreDef));
            throw new VoldemortException(errorMessage);
          }
        }
        if (!addStoreToCurrentNode) {
          break;
        }
 else {
          throw new VoldemortException("Unexpected code path! At this point, we should either have found " + "a matching store or already thrown another exception. " + "Current remoteStoreDef: '" + remoteStoreDef.getName() + "'. "+ "Current node: "+ node.briefToString());
        }
      }
    }
    if (addStoreToCurrentNode) {
      nodesMissingNewStore.add(nodeId);
    }
  }
  addStore(description,owners,clusterURL,newStoreDef,nodesMissingNewStore);
  storeDefs=ImmutableList.of(VoldemortUtils.getStoreDef(VoldemortUtils.getStoreDefXml(storeName,replicationFactor,requiredReads,requiredWrites,props.getNullableInt(BUILD_PREFERRED_READS),props.getNullableInt(BUILD_PREFERRED_WRITES),keySchema,valueSchema)));
}
