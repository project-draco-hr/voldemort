{
  Schema schema=getInputPathSchema();
  int replicationFactor=props.getInt(BUILD_REPLICATION_FACTOR,2);
  int requiredReads=props.getInt(BUILD_REQUIRED_READS,1);
  int requiredWrites=props.getInt(BUILD_REQUIRED_WRITES,1);
  String description=props.getString(PUSH_STORE_DESCRIPTION,"");
  String owners=props.getString(PUSH_STORE_OWNERS,"");
  String serializerName;
  if (isVersioned)   serializerName=DefaultSerializerFactory.AVRO_GENERIC_VERSIONED_TYPE_NAME;
 else   serializerName=DefaultSerializerFactory.AVRO_GENERIC_TYPE_NAME;
  boolean hasCompression=false;
  if (props.containsKey(BUILD_COMPRESS_VALUE)) {
    hasCompression=true;
  }
  String keySchema, valSchema;
  try {
    if (props.containsKey(BUILD_FORCE_SCHEMA_KEY)) {
      keySchema=props.get(BUILD_FORCE_SCHEMA_KEY);
    }
 else {
      Schema.Field keyField=schema.getField(keyFieldName);
      if (keyField == null) {
        throw new VoldemortException("The configured key field (" + keyFieldName + ") was not found in the input data.");
      }
 else {
        keySchema="\n\t\t<type>" + serializerName + "</type>\n\t\t<schema-info version=\"0\">"+ keyField.schema()+ "</schema-info>\n\t";
      }
    }
  }
 catch (  VoldemortException e) {
    throw e;
  }
catch (  Exception e) {
    throw new VoldemortException("Error while trying to extract the key field",e);
  }
  try {
    if (props.containsKey(BUILD_FORCE_SCHEMA_VALUE)) {
      valSchema=props.get(BUILD_FORCE_SCHEMA_VALUE);
    }
 else {
      Schema.Field valueField=schema.getField(valueFieldName);
      if (valueField == null) {
        throw new VoldemortException("The configured value field (" + valueFieldName + ") was not found in the input data.");
      }
 else {
        valSchema="\n\t\t<type>" + serializerName + "</type>\n\t\t<schema-info version=\"0\">"+ valueField.schema()+ "</schema-info>\n\t";
        if (hasCompression) {
          valSchema+="\t<compression><type>gzip</type></compression>\n\t";
        }
      }
    }
  }
 catch (  VoldemortException e) {
    throw e;
  }
catch (  Exception e) {
    throw new VoldemortException("Error while trying to extract the value field",e);
  }
  if (keySchema == null || valSchema == null) {
    throw new VoldemortException("There was a problem defining the key or value schema for this job.");
  }
 else {
    String newStoreDefXml=VoldemortUtils.getStoreDefXml(storeName,replicationFactor,requiredReads,requiredWrites,props.containsKey(BUILD_PREFERRED_READS) ? props.getInt(BUILD_PREFERRED_READS) : null,props.containsKey(BUILD_PREFERRED_WRITES) ? props.getInt(BUILD_PREFERRED_WRITES) : null,(props.containsKey(PUSH_FORCE_SCHEMA_KEY)) ? props.getString(PUSH_FORCE_SCHEMA_KEY) : keySchema,(props.containsKey(PUSH_FORCE_SCHEMA_VALUE)) ? props.getString(PUSH_FORCE_SCHEMA_VALUE) : valSchema,description,owners);
    KeyValueSchema returnSchemaObj=new KeyValueSchema(keySchema,valSchema);
    boolean foundStore=findAndVerifyAvro(url,newStoreDefXml,hasCompression,replicationFactor,requiredReads,requiredWrites,serializerName,returnSchemaObj);
    if (!foundStore) {
      try {
        StoreDefinition newStoreDef=VoldemortUtils.getStoreDef(newStoreDefXml);
        addStore(description,owners,url,newStoreDef);
      }
 catch (      RuntimeException e) {
        log.error("Error in adding store definition from: " + url,e);
        throw new VoldemortException("Error in adding store definition from: " + url,e);
      }
    }
    storeDefs=ImmutableList.of(VoldemortUtils.getStoreDef(VoldemortUtils.getStoreDefXml(storeName,replicationFactor,requiredReads,requiredWrites,props.containsKey(BUILD_PREFERRED_READS) ? props.getInt(BUILD_PREFERRED_READS) : null,props.containsKey(BUILD_PREFERRED_WRITES) ? props.getInt(BUILD_PREFERRED_WRITES) : null,returnSchemaObj.keySchema,returnSchemaObj.valSchema)));
    cluster=adminClientPerCluster.get(url).getAdminClientCluster();
  }
}
