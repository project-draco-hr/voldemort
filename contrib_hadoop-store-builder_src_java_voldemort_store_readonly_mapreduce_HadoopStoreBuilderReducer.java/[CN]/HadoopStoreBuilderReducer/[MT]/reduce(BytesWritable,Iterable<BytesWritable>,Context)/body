{
  Iterator<BytesWritable> iterator=values.iterator();
  this.indexFileStream.write(key.getBytes(),0,key.getLength());
  this.indexFileStream.writeInt(this.position);
  if (this.checkSumDigestIndex != null) {
    this.checkSumDigestIndex.update(key.getBytes(),0,key.getLength());
    this.checkSumDigestIndex.update(this.position);
  }
  int numKeyValues=0;
  ByteArrayOutputStream stream=new ByteArrayOutputStream();
  DataOutputStream valueStream=new DataOutputStream(stream);
  while (iterator.hasNext()) {
    BytesWritable writable=iterator.next();
    byte[] valueBytes=writable.getBytes();
    if (this.nodeId == -1)     this.nodeId=ByteUtils.readInt(valueBytes,0);
    if (this.partitionId == -1)     this.partitionId=ByteUtils.readInt(valueBytes,4);
    if (this.chunkId == -1)     this.chunkId=ReadOnlyUtils.chunk(key.getBytes(),this.numChunks);
    int valueLength=writable.getLength() - 8;
    if (saveKeys) {
      valueStream.write(valueBytes,8,valueLength);
    }
 else {
      valueStream.writeInt(valueLength);
      valueStream.write(valueBytes,8,valueLength);
    }
    numKeyValues++;
    if (!saveKeys && numKeyValues > 1)     throw new VoldemortException("Duplicate keys detected for md5 sum " + ByteUtils.toHexString(ByteUtils.copy(key.getBytes(),0,key.getLength())));
  }
  if (saveKeys) {
    byte[] numBuf=new byte[1];
    numBuf[0]=(byte)numKeyValues;
    this.valueFileStream.write(numBuf);
    this.position+=1;
    if (this.checkSumDigestValue != null) {
      this.checkSumDigestValue.update(numBuf);
    }
  }
  valueStream.flush();
  byte[] value=stream.toByteArray();
  this.valueFileStream.write(value);
  this.position+=value.length;
  if (this.checkSumDigestValue != null) {
    this.checkSumDigestValue.update(value);
  }
  if (this.position < 0)   throw new VoldemortException("Chunk overflow exception: chunk " + chunkId + " has exceeded "+ Integer.MAX_VALUE+ " bytes.");
}
