{
  Node master=pipelineData.getMaster();
  final Versioned<byte[]> versionedCopy=pipelineData.getVersionedCopy();
  if (logger.isDebugEnabled())   logger.debug("Serial put requests determined master node as " + master.getId() + ", submitting remaining requests in parallel");
  List<Node> nodes=pipelineData.getNodes();
  int firstParallelNodeIndex=nodes.indexOf(master) + 1;
  int attempts=nodes.size() - firstParallelNodeIndex;
  int blocks=Math.min(preferred - 1,attempts);
  final Map<Integer,Response<ByteArray,Object>> responses=new ConcurrentHashMap<Integer,Response<ByteArray,Object>>();
  final CountDownLatch attemptsLatch=new CountDownLatch(attempts);
  final CountDownLatch blocksLatch=new CountDownLatch(blocks);
  if (logger.isTraceEnabled())   logger.trace("Attempting " + attempts + " "+ pipeline.getOperation().getSimpleName()+ " operations in parallel");
  for (int i=firstParallelNodeIndex; i < (firstParallelNodeIndex + attempts); i++) {
    final Node node=nodes.get(i);
    pipelineData.incrementNodeIndex();
    NonblockingStoreCallback callback=new Callback(pipeline,node,versionedCopy,responses,attemptsLatch,blocksLatch);
    if (logger.isTraceEnabled())     logger.trace("Submitting " + pipeline.getOperation().getSimpleName() + " request on node "+ node.getId());
    NonblockingStore store=nonblockingStores.get(node.getId());
    store.submitPutRequest(key,versionedCopy,transforms,callback,timeoutMs);
  }
  waitForResponses(blocksLatch,responses,pipeline);
  boolean quorumSatisfied=true;
  if (pipelineData.getSuccesses() < required) {
    waitForResponses(attemptsLatch,responses,pipeline);
    if (pipelineData.getSuccesses() < required) {
      pipelineData.setFatalError(new InsufficientOperationalNodesException(required + " " + pipeline.getOperation().getSimpleName()+ "s required, but only "+ pipelineData.getSuccesses()+ " succeeded",new ArrayList<Node>(pipelineData.getReplicationSet()),new ArrayList<Node>(pipelineData.getNodes()),new ArrayList<Node>(pipelineData.getFailedNodes()),pipelineData.getFailures()));
      pipeline.abort();
      quorumSatisfied=false;
    }
  }
  if (quorumSatisfied) {
    if (pipelineData.getZonesRequired() != null) {
      int zonesSatisfied=pipelineData.getZoneResponses().size();
      if (zonesSatisfied >= (pipelineData.getZonesRequired() + 1)) {
        pipeline.addEvent(completeEvent);
      }
 else {
        waitForResponses(attemptsLatch,responses,pipeline);
        if (pipelineData.getZoneResponses().size() >= (pipelineData.getZonesRequired() + 1)) {
          pipeline.addEvent(completeEvent);
        }
 else {
          pipelineData.setFatalError(new InsufficientZoneResponsesException((pipelineData.getZonesRequired() + 1) + " " + pipeline.getOperation().getSimpleName()+ "s required zone, but only "+ zonesSatisfied+ " succeeded. Failing nodes : "+ pipelineData.getFailedNodes()));
          pipeline.abort();
        }
      }
    }
 else {
      pipeline.addEvent(completeEvent);
    }
  }
}
