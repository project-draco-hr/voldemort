{
  HashMap<ByteArray,byte[]> entrySet=ServerTestUtils.createRandomKeyValuePairs(10);
  SocketStoreClientFactory factory=new SocketStoreClientFactory(new ClientConfig().setBootstrapUrls(Lists.newArrayList("tcp://" + cluster.getNodeById(0).getHost() + ":"+ cluster.getNodeById(0).getSocketPort())));
  StoreClient<Object,Object> storeClient=factory.getStoreClient("test");
  List<Integer> primaryPartitionsMoved=Lists.newArrayList(0);
  List<Integer> secondaryPartitionsMoved=Lists.newArrayList(4,5,6,7);
  HashMap<ByteArray,byte[]> primaryEntriesMoved=Maps.newHashMap();
  HashMap<ByteArray,byte[]> secondaryEntriesMoved=Maps.newHashMap();
  RoutingStrategy strategy=new RoutingStrategyFactory().updateRoutingStrategy(storeDef,cluster);
  for (  Entry<ByteArray,byte[]> entry : entrySet.entrySet()) {
    storeClient.put(new String(entry.getKey().get()),new String(entry.getValue()));
    List<Integer> pList=strategy.getPartitionList(entry.getKey().get());
    System.out.print("ENTRY - " + ByteUtils.toHexString(entry.getKey().get()) + " - "+ pList);
    if (primaryPartitionsMoved.contains(pList.get(0))) {
      primaryEntriesMoved.put(entry.getKey(),entry.getValue());
      System.out.print(" - primary");
    }
 else     if (secondaryPartitionsMoved.contains(pList.get(0))) {
      secondaryEntriesMoved.put(entry.getKey(),entry.getValue());
      System.out.print(" - secondary");
    }
    System.out.println();
  }
  RebalanceClusterPlan plan=new RebalanceClusterPlan(cluster,targetCluster,Lists.newArrayList(storeDef),true);
  List<RebalancePartitionsInfo> plans=RebalanceUtils.flattenNodePlans(Lists.newArrayList(plan.getRebalancingTaskQueue()));
  System.out.println("PLANS - " + plans);
  try {
    adminClient.rebalanceNode(plans.get(0));
    fail("Should have thrown an exception since not in rebalancing state");
  }
 catch (  VoldemortException e) {
    e.printStackTrace();
  }
  for (  RebalancePartitionsInfo partitionPlan : plans) {
    getServer(partitionPlan.getStealerId()).getMetadataStore().put(MetadataStore.SERVER_STATE_KEY,MetadataStore.VoldemortState.REBALANCING_MASTER_SERVER);
  }
  try {
    adminClient.rebalanceNode(plans.get(0));
    fail("Should have thrown an exception since no steal info");
  }
 catch (  VoldemortException e) {
    e.printStackTrace();
  }
  for (  RebalancePartitionsInfo partitionPlan : plans) {
    getServer(partitionPlan.getStealerId()).getMetadataStore().put(MetadataStore.REBALANCING_STEAL_INFO,new RebalancerState(Lists.newArrayList(partitionPlan)));
  }
  for (  VoldemortServer server : servers) {
    server.getMetadataStore().put(MetadataStore.CLUSTER_KEY,targetCluster);
  }
  try {
    for (    RebalancePartitionsInfo currentPlan : plans) {
      int asyncId=adminClient.rebalanceNode(currentPlan);
      assertNotSame("Got a valid rebalanceAsyncId",-1,asyncId);
      getAdminClient().waitForCompletion(currentPlan.getStealerId(),asyncId,300,TimeUnit.SECONDS);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail("Should not throw any exceptions");
  }
  Store<ByteArray,byte[],byte[]> store0=getStore(0,"test");
  Store<ByteArray,byte[],byte[]> store1=getStore(1,"test");
  Store<ByteArray,byte[],byte[]> store2=getStore(2,"test");
  for (  Entry<ByteArray,byte[]> entry : primaryEntriesMoved.entrySet()) {
    assertSame("entry should be present at store",1,store0.get(entry.getKey(),null).size());
    assertEquals("entry value should match",new String(entry.getValue()),new String(store0.get(entry.getKey(),null).get(0).getValue()));
    assertEquals(store1.get(entry.getKey(),null).size(),0);
  }
  for (  Entry<ByteArray,byte[]> entry : secondaryEntriesMoved.entrySet()) {
    assertSame("entry should be present at store",1,store2.get(entry.getKey(),null).size());
    assertEquals("entry value should match",new String(entry.getValue()),new String(store2.get(entry.getKey(),null).get(0).getValue()));
    assertEquals(store0.get(entry.getKey(),null).size(),0);
  }
}
