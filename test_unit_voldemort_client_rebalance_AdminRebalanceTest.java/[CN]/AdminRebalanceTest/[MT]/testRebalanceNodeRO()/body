{
  try {
    startUp3();
    int numChunks=5;
    for (    StoreDefinition storeDef : Lists.newArrayList(storeDef1,storeDef2)) {
      buildStore(storeDef,numChunks);
    }
    RebalanceClusterPlan plan=new RebalanceClusterPlan(cluster,targetCluster,Lists.newArrayList(storeDef1,storeDef2),true);
    List<RebalancePartitionsInfo> plans=RebalanceUtils.flattenNodePlans(Lists.newArrayList(plan.getRebalancingTaskQueue()));
    for (    RebalancePartitionsInfo partitionPlan : plans) {
      getServer(partitionPlan.getStealerId()).getMetadataStore().put(MetadataStore.SERVER_STATE_KEY,MetadataStore.VoldemortState.REBALANCING_MASTER_SERVER);
      getServer(partitionPlan.getStealerId()).getMetadataStore().put(MetadataStore.REBALANCING_STEAL_INFO,new RebalancerState(Lists.newArrayList(partitionPlan)));
    }
    for (    VoldemortServer server : servers) {
      server.getMetadataStore().put(MetadataStore.CLUSTER_KEY,targetCluster);
    }
    try {
      for (      RebalancePartitionsInfo currentPlan : plans) {
        int asyncId=adminClient.rebalanceNode(currentPlan);
        assertNotSame("Got a valid rebalanceAsyncId",-1,asyncId);
        getAdminClient().waitForCompletion(currentPlan.getStealerId(),asyncId,300,TimeUnit.SECONDS);
        assertFalse(getServer(currentPlan.getStealerId()).getMetadataStore().getRebalancerState().getAll().contains(currentPlan));
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail("Should not throw any exceptions");
    }
    for (    StoreDefinition storeDef : Lists.newArrayList(storeDef1,storeDef2)) {
      String storeName=storeDef.getName();
      for (      RebalancePartitionsInfo currentPlan : plans) {
        File currentDir=new File(((ReadOnlyStorageEngine)getStore(currentPlan.getStealerId(),storeName)).getCurrentDirPath());
        for (        Entry<Integer,List<Integer>> entry : currentPlan.getReplicaToPartitionList().entrySet()) {
          if (entry.getKey() < storeDef.getReplicationFactor()) {
            for (            int partitionId : entry.getValue()) {
              for (int chunkId=0; chunkId < numChunks; chunkId++) {
                assertTrue(new File(currentDir,partitionId + "_" + entry.getKey()+ "_"+ chunkId+ ".data").exists());
                assertTrue(new File(currentDir,partitionId + "_" + entry.getKey()+ "_"+ chunkId+ ".index").exists());
              }
            }
          }
        }
      }
    }
    for (    VoldemortServer server : servers) {
      assertEquals(server.getMetadataStore().getServerState(),MetadataStore.VoldemortState.NORMAL_SERVER);
    }
  }
  finally {
    shutDown();
  }
}
