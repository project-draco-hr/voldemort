{
  try {
    boolean isDeleted=storeClient.deleteWithCustomTimeout(this.deleteRequestObject);
    if (isDeleted) {
      writeResponse();
    }
 else {
      RESTErrorHandler.handleError(NOT_FOUND,this.deleteRequestMessageEvent,"Requested Key with the specified version does not exist");
    }
  }
 catch (  StoreTimeoutException timeoutException) {
    String errorDescription="DELETE Request timed out: " + timeoutException.getMessage();
    logger.error(errorDescription);
    RESTErrorHandler.handleError(REQUEST_TIMEOUT,this.deleteRequestMessageEvent,errorDescription);
  }
catch (  InsufficientOperationalNodesException exception) {
    long currentTimeInNs=System.nanoTime();
    if (currentTimeInNs - startTimestampInNs > deleteRequestObject.getRoutingTimeoutInMs() * Time.NS_PER_MS) {
      String errorDescription="DELETE Request timed out: " + exception.getMessage();
      if (logger.isEnabledFor(Level.ERROR)) {
        logger.error(errorDescription);
      }
      RESTErrorHandler.handleError(REQUEST_TIMEOUT,this.deleteRequestMessageEvent,errorDescription);
    }
 else {
      String errorDescription="Voldemort Exception: " + exception.getMessage();
      RESTErrorHandler.handleError(INTERNAL_SERVER_ERROR,this.deleteRequestMessageEvent,errorDescription);
    }
  }
catch (  VoldemortException ve) {
    ve.printStackTrace();
    String errorDescription="Voldemort Exception: " + ve.getMessage();
    RESTErrorHandler.handleError(INTERNAL_SERVER_ERROR,this.deleteRequestMessageEvent,errorDescription);
  }
}
