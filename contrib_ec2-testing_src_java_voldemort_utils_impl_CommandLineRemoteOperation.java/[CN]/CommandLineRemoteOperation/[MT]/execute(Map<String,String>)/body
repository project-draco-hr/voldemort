{
  CommandLineParser commandLineParser=new CommandLineParser();
  ExecutorService threadPool=Executors.newFixedThreadPool(hostNameCommandLineMap.size());
  List<Future<T>> futures=new ArrayList<Future<T>>();
  for (  Map.Entry<String,String> entry : hostNameCommandLineMap.entrySet()) {
    String hostName=entry.getKey();
    String commandLine=entry.getValue();
    if (logger.isDebugEnabled())     logger.debug("Command to execute: " + commandLine);
    List<String> commandArgs=commandLineParser.parse(commandLine);
    UnixCommand command=new UnixCommand(hostName,commandArgs);
    Callable<T> callable=getCallable(command);
    Future<T> future=threadPool.submit(callable);
    futures.add(future);
  }
  try {
    StringBuilder errors=new StringBuilder();
    List<T> list=new ArrayList<T>();
    for (    Future<T> future : futures) {
      Throwable t=null;
      try {
        T result=future.get();
        list.add(result);
      }
 catch (      ExecutionException ex) {
        t=ex.getCause();
      }
catch (      Exception e) {
        t=e;
      }
      if (t != null) {
        if (logger.isWarnEnabled())         logger.warn(t,t);
        if (errors.length() > 0)         errors.append("; ");
        errors.append(t.getMessage());
      }
    }
    if (errors.length() > 0)     throw new RemoteOperationException(errors.toString());
    return list;
  }
  finally {
    threadPool.shutdown();
    try {
      threadPool.awaitTermination(60,TimeUnit.SECONDS);
    }
 catch (    InterruptedException e) {
      if (logger.isWarnEnabled())       logger.warn(e,e);
    }
  }
}
