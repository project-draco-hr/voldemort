{
  Properties properties=new Properties();
  try {
    properties.load(getClass().getClassLoader().getResourceAsStream("commands.properties"));
  }
 catch (  IOException e1) {
    throw new RemoteOperationException(e1);
  }
  final String rawCommand=properties.getProperty(commandId);
  final ExecutorService threadPool=Executors.newFixedThreadPool(remoteOperationConfig.getHostNames().size());
  final List<Future<T>> futures=new ArrayList<Future<T>>();
  for (  String hostName : remoteOperationConfig.getHostNames()) {
    String parameterizedCommand=parameterizeCommand(hostName,rawCommand);
    List<String> commandArgs=generateCommandArgs(parameterizedCommand);
    UnixCommand command=new UnixCommand(hostName,commandArgs);
    Callable<T> callable=getCallable(command);
    Future<T> future=threadPool.submit(callable);
    futures.add(future);
  }
  List<T> list=new ArrayList<T>();
  try {
    StringBuilder errors=new StringBuilder();
    for (    Future<T> future : futures) {
      Throwable t=null;
      try {
        T result=future.get();
        list.add(result);
      }
 catch (      ExecutionException ex) {
        t=ex.getCause();
      }
catch (      Exception e) {
        t=e;
      }
      if (t != null) {
        if (logger.isWarnEnabled())         logger.warn(t,t);
        if (errors.length() > 0)         errors.append("; ");
        errors.append(t.getMessage());
      }
    }
    if (errors.length() > 0)     throw new RemoteOperationException(errors.toString());
  }
  finally {
    threadPool.shutdown();
    try {
      threadPool.awaitTermination(60,TimeUnit.SECONDS);
    }
 catch (    InterruptedException e) {
      if (logger.isWarnEnabled())       logger.warn(e,e);
    }
  }
  return list;
}
