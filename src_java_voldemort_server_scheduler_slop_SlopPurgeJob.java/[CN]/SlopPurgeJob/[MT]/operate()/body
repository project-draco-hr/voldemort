{
  logger.info("Purging slops that match any of the following. 1) Nodes:" + nodesToPurge + ", 2) Zone:"+ zoneToPurge+ ", 3) Stores:"+ storesToPurge);
  SlopStorageEngine slopStorageEngine=storeRepo.getSlopStore();
  StorageEngine<ByteArray,Slop,byte[]> slopStore=slopStorageEngine.asSlopStore();
  ClosableIterator<Pair<ByteArray,Versioned<Slop>>> iterator=slopStore.entries();
  Set<Integer> nodesInPurgeZone=metadataStore.getCluster().getNodeIdsInZone(zoneToPurge);
  try {
    while (iterator.hasNext()) {
      Pair<ByteArray,Versioned<Slop>> keyAndVal=iterator.next();
      Versioned<Slop> versioned=keyAndVal.getSecond();
      Slop slop=versioned.getValue();
      boolean purge=false;
      if (nodesToPurge.contains(slop.getNodeId())) {
        purge=true;
      }
 else       if (nodesInPurgeZone.contains(slop.getNodeId())) {
        purge=true;
      }
 else       if (storesToPurge.contains(slop.getStoreName())) {
        purge=true;
      }
      if (purge) {
        numKeysUpdatedThisRun.incrementAndGet();
        slopStorageEngine.delete(keyAndVal.getFirst(),versioned.getVersion());
      }
      numKeysScannedThisRun.incrementAndGet();
      throttler.maybeThrottle(1);
      if (numKeysScannedThisRun.get() % STAT_RECORDS_INTERVAL == 0) {
        logger.info("#Scanned:" + numKeysScannedThisRun + " #PurgedSlops:"+ numKeysUpdatedThisRun);
      }
    }
  }
 catch (  Exception e) {
    logger.error("Error while purging slops",e);
  }
  logger.info("Completed purging slops. " + "#Scanned:" + numKeysScannedThisRun + " #PurgedSlops:"+ numKeysUpdatedThisRun);
}
