{
  long startNs=System.nanoTime();
  if (request == null) {
    int size=0;
    try {
      size=inputStream.readInt();
    }
 catch (    EOFException e) {
      if (logger.isTraceEnabled())       logger.trace("Incomplete read for message size");
      networkTimeNs+=System.nanoTime() - startNs;
      return StreamRequestHandlerState.INCOMPLETE_READ;
    }
    if (size == -1) {
      if (logger.isTraceEnabled())       logger.trace("Message size -1, completed slop update");
      return StreamRequestHandlerState.COMPLETE;
    }
    if (logger.isTraceEnabled())     logger.trace("UpdateSlopEntriesRequest message size: " + size);
    byte[] input=new byte[size];
    try {
      ByteUtils.read(inputStream,input);
      networkTimeNs+=System.nanoTime() - startNs;
    }
 catch (    EOFException e) {
      if (logger.isTraceEnabled())       logger.trace("Incomplete read for message");
      return StreamRequestHandlerState.INCOMPLETE_READ;
    }
    VAdminProto.UpdateSlopEntriesRequest.Builder builder=VAdminProto.UpdateSlopEntriesRequest.newBuilder();
    builder.mergeFrom(input);
    request=builder.build();
  }
  StorageEngine<ByteArray,byte[],byte[]> storageEngine=AdminServiceRequestHandler.getStorageEngine(storeRepository,request.getStore());
  StreamingStats streamStats=null;
  if (isJmxEnabled) {
    streamStats=storeRepository.getStreamingStats(storageEngine.getName());
    streamStats.reportNetworkTime(Operation.SLOP_UPDATE,networkTimeNs);
  }
  networkTimeNs=0;
  ByteArray key=ProtoUtils.decodeBytes(request.getKey());
  VectorClock vectorClock=ProtoUtils.decodeClock(request.getVersion());
switch (request.getRequestType()) {
case PUT:
    try {
      byte[] transforms=null;
      if (request.hasTransform()) {
        transforms=ProtoUtils.decodeBytes(request.getTransform()).get();
      }
      byte[] value=ProtoUtils.decodeBytes(request.getValue()).get();
      startNs=System.nanoTime();
      storageEngine.put(key,Versioned.value(value,vectorClock),transforms);
      if (isJmxEnabled)       streamStats.reportStorageTime(Operation.SLOP_UPDATE,System.nanoTime() - startNs);
      if (logger.isTraceEnabled())       logger.trace("updateSlopEntries (Streaming put) successful on key:" + key + " of store: "+ request.getStore());
    }
 catch (    ObsoleteVersionException e) {
      if (logger.isDebugEnabled())       logger.debug("updateSlopEntries (Streaming put) threw ObsoleteVersionException, Ignoring.");
    }
  break;
case DELETE:
try {
  startNs=System.nanoTime();
  storageEngine.delete(key,vectorClock);
  if (isJmxEnabled)   streamStats.reportStorageTime(Operation.SLOP_UPDATE,System.nanoTime() - startNs);
  if (logger.isTraceEnabled())   logger.trace("updateSlopEntries (Streaming delete) successful");
}
 catch (ObsoleteVersionException e) {
  if (logger.isDebugEnabled())   logger.debug("updateSlopEntries (Streaming delete) threw ObsoleteVersionException, Ignoring.");
}
break;
default :
throw new VoldemortException("Unsupported operation ");
}
counter++;
if (isJmxEnabled) streamStats.reportStreamingPut(Operation.SLOP_UPDATE);
if (0 == counter % 100000) {
long totalTime=(System.currentTimeMillis() - startTime) / 1000;
if (logger.isDebugEnabled()) logger.debug("updateSlopEntries() updated " + counter + " entries in "+ totalTime+ " s");
}
request=null;
return StreamRequestHandlerState.READING;
}
