{
  ExecutorService executor=Executors.newCachedThreadPool();
  JobConf conf=new JobConf();
  Path dataPath=new Path(dataDir);
  String modifiedDataDir=dataPath.makeQualified(FileSystem.get(conf)).toString();
  String[] pathComponents=modifiedDataDir.split(":");
  if (pathComponents.length >= 3) {
    String existingProtocol=pathComponents[0];
    String existingPort=pathComponents[2].split("/")[0];
    info("Existing protocol = " + existingProtocol + " and port = "+ existingPort);
    if (hdfsFetcherProtocol.length() > 0 && hdfsFetcherPort.length() > 0) {
      info("New protocol = " + hdfsFetcherProtocol + " and port = "+ hdfsFetcherPort);
      modifiedDataDir=modifiedDataDir.replaceFirst(existingProtocol,hdfsFetcherProtocol);
      modifiedDataDir=modifiedDataDir.replaceFirst(existingPort,hdfsFetcherPort);
    }
  }
 else {
    info("The dataDir will not be modified, since it does not contain the expected " + "structure of protocol:hostname:port/some_path");
  }
  try {
    new Path(modifiedDataDir);
  }
 catch (  IllegalArgumentException e) {
    throw new VoldemortException("Could not create a valid data path out of the supplied dataDir: " + dataDir,e);
  }
  AdminClient client=new AdminClient(cluster,new AdminClientConfig().setMaxConnectionsPerNode(cluster.getNumberOfNodes()).setAdminConnectionTimeoutSec(httpTimeoutMs / 1000).setMaxBackoffDelayMs(maxBackoffDelayMs),new ClientConfig());
  if (pushVersion == -1L) {
    ArrayList<String> stores=new ArrayList<String>();
    stores.add(storeName);
    Map<String,Long> pushVersions=client.readonlyOps.getROMaxVersion(stores,maxNodeFailures);
    if (pushVersions == null || !pushVersions.containsKey(storeName)) {
      throw new RuntimeException("Push version could not be determined for store " + storeName);
    }
    pushVersion=pushVersions.get(storeName);
    pushVersion++;
  }
  info("Initiating swap of " + storeName + " with dataDir: "+ dataDir);
  AdminStoreSwapper swapper=new AdminStoreSwapper(cluster,executor,client,httpTimeoutMs,rollbackFailedSwap,failedFetchStrategyList,clusterName);
  swapper.swapStoreData(storeName,modifiedDataDir,pushVersion);
  info("Swap complete.");
  executor.shutdownNow();
  executor.awaitTermination(10,TimeUnit.SECONDS);
}
