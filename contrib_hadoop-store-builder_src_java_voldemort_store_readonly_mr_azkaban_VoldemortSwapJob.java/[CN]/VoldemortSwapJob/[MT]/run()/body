{
  ExecutorService executor=Executors.newCachedThreadPool();
  JobConf conf=new JobConf();
  Path dataPath=new Path(dataDir);
  dataDir=dataPath.makeQualified(FileSystem.get(conf)).toString();
  String existingProtocol="";
  String existingPort="";
  String[] pathComponents=dataDir.split(":");
  if (pathComponents.length >= 3) {
    existingProtocol=pathComponents[0];
    existingPort=pathComponents[2].split("/")[0];
  }
  info("Existing protocol = " + existingProtocol + " and port = "+ existingPort);
  if (hdfsFetcherProtocol.length() > 0 && hdfsFetcherPort.length() > 0) {
    dataDir=dataDir.replaceFirst(existingProtocol,hdfsFetcherProtocol);
    dataDir=dataDir.replaceFirst(existingPort,hdfsFetcherPort);
  }
  AdminClient client=new AdminClient(cluster,new AdminClientConfig().setMaxConnectionsPerNode(cluster.getNumberOfNodes()).setAdminConnectionTimeoutSec(httpTimeoutMs / 1000).setMaxBackoffDelayMs(maxBackoffDelayMs),new ClientConfig());
  if (pushVersion == -1L) {
    ArrayList<String> stores=new ArrayList<String>();
    stores.add(storeName);
    Map<String,Long> pushVersions=client.readonlyOps.getROMaxVersion(stores,maxNodeFailures);
    if (pushVersions == null || !pushVersions.containsKey(storeName)) {
      throw new RuntimeException("Push version could not be determined for store " + storeName);
    }
    pushVersion=pushVersions.get(storeName);
    pushVersion++;
  }
  info("Initiating swap of " + storeName + " with dataDir:"+ dataDir);
  AdminStoreSwapper swapper=new AdminStoreSwapper(cluster,executor,client,httpTimeoutMs,rollbackFailedSwap,failedFetchStrategyList);
  swapper.swapStoreData(storeName,dataDir,pushVersion);
  info("Swap complete.");
  executor.shutdownNow();
  executor.awaitTermination(10,TimeUnit.SECONDS);
}
