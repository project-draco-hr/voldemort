{
  StoreUtils.assertValidKeys(keys);
  boolean allowReadRepair=repairReads && (transforms == null || transforms.size() == 0);
  GetAllPipelineData pipelineData=new GetAllPipelineData();
  if (zoneRoutingEnabled)   pipelineData.setZonesRequired(storeDef.getZoneCountReads());
 else   pipelineData.setZonesRequired(null);
  pipelineData.setStats(stats);
  Pipeline pipeline=new Pipeline(Operation.GET_ALL,timeoutConfig.getOperationTimeout(VoldemortOperation.GETALL),TimeUnit.MILLISECONDS);
  pipeline.addEventAction(Event.STARTED,new GetAllConfigureNodes(pipelineData,Event.CONFIGURED,failureDetector,storeDef.getPreferredReads(),storeDef.getRequiredReads(),routingStrategy,keys,transforms,clientZone));
  pipeline.addEventAction(Event.CONFIGURED,new PerformParallelGetAllRequests(pipelineData,Event.INSUFFICIENT_SUCCESSES,failureDetector,timeoutConfig.getOperationTimeout(VoldemortOperation.GETALL),nonblockingStores));
  pipeline.addEventAction(Event.INSUFFICIENT_SUCCESSES,new PerformSerialGetAllRequests(pipelineData,allowReadRepair ? Event.RESPONSES_RECEIVED : Event.COMPLETED,keys,failureDetector,innerStores,storeDef.getPreferredReads(),storeDef.getRequiredReads(),timeoutConfig.isPartialGetAllAllowed()));
  if (allowReadRepair)   pipeline.addEventAction(Event.RESPONSES_RECEIVED,new GetAllReadRepair(pipelineData,Event.COMPLETED,storeDef.getPreferredReads(),timeoutConfig.getOperationTimeout(VoldemortOperation.GETALL),nonblockingStores,readRepairer));
  pipeline.addEvent(Event.STARTED);
  if (logger.isDebugEnabled()) {
    StringBuilder keyStr=new StringBuilder();
    for (    ByteArray key : keys) {
      keyStr.append(ByteUtils.toHexString(key.get()) + ",");
    }
    logger.debug("Operation " + pipeline.getOperation().getSimpleName() + " Keys "+ keyStr.toString());
  }
  try {
    pipeline.execute();
  }
 catch (  VoldemortException e) {
    stats.reportException(e);
    throw e;
  }
  if (pipelineData.getFatalError() != null)   throw pipelineData.getFatalError();
  return pipelineData.getResult();
}
