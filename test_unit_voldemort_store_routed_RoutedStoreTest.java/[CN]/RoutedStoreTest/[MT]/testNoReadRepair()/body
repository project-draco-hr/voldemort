{
  cluster=VoldemortTestConstants.getThreeNodeCluster();
  StoreDefinition storeDef=ServerTestUtils.getStoreDef("test",3,2,1,3,2,RoutingStrategyType.CONSISTENT_STRATEGY);
  Map<Integer,Store<ByteArray,byte[]>> subStores=Maps.newHashMap();
  Map<Integer,NonblockingStore> nonblockingStores=new HashMap<Integer,NonblockingStore>();
  ExecutorService threadPool=Executors.newFixedThreadPool(1);
  StatTrackingStore<ByteArray,byte[]> statTrackingStore=null;
  for (int i=0; i < 3; ++i) {
    int id=Iterables.get(cluster.getNodes(),i).getId();
    statTrackingStore=new StatTrackingStore<ByteArray,byte[]>(new InMemoryStorageEngine<ByteArray,byte[]>("test"),null);
    subStores.put(id,statTrackingStore);
    nonblockingStores.put(id,new ThreadPoolBasedNonblockingStoreImpl(threadPool,statTrackingStore));
  }
  setFailureDetector(subStores);
  RoutedStore routedStore=new RoutedStore("test",subStores,nonblockingStores,cluster,storeDef,true,threadPool,1000L,failureDetector);
  ByteArray key1=aKey;
  routedStore.put(key1,Versioned.value("value1".getBytes()));
  ByteArray key2=TestUtils.toByteArray("voldemort");
  routedStore.put(key2,Versioned.value("value2".getBytes()));
  long putCount=statTrackingStore.getStats().getCount(Tracked.PUT);
  routedStore.getAll(Arrays.asList(key1,key2));
  Thread.sleep(500);
  assertEquals("put count should remain the same if there are no read repairs",putCount,statTrackingStore.getStats().getCount(Tracked.PUT));
}
