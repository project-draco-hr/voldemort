{
  cluster=VoldemortTestConstants.getTwoNodeCluster();
  StoreDefinition storeDef=ServerTestUtils.getStoreDef("test",2,1,1,2,2,RoutingStrategyType.CONSISTENT_STRATEGY);
  Map<Integer,Store<ByteArray,byte[]>> subStores=Maps.newHashMap();
  Map<Integer,NonblockingStore> nonblockingStores=new HashMap<Integer,NonblockingStore>();
  ExecutorService threadPool=Executors.newFixedThreadPool(1);
  int id1=Iterables.get(cluster.getNodes(),0).getId();
  int id2=Iterables.get(cluster.getNodes(),1).getId();
  subStores.put(id1,new InMemoryStorageEngine<ByteArray,byte[]>("test"));
  subStores.put(id2,new FailingReadsStore<ByteArray,byte[]>("test"));
  nonblockingStores.put(id1,new ThreadPoolBasedNonblockingStoreImpl(threadPool,subStores.get(id1)));
  nonblockingStores.put(id2,new ThreadPoolBasedNonblockingStoreImpl(threadPool,subStores.get(id2)));
  setFailureDetector(subStores);
  RoutableStore routableStore=new NewRoutedStore("test",subStores,nonblockingStores,cluster,storeDef,true,threadPool,1000L,failureDetector);
  Store<ByteArray,byte[]> store=new InconsistencyResolvingStore<ByteArray,byte[]>(routableStore,new VectorClockInconsistencyResolver<byte[]>());
  Map<ByteArray,byte[]> expectedValues=Maps.newHashMap();
  for (byte i=1; i < 11; ++i) {
    ByteArray key=new ByteArray(new byte[]{i});
    byte[] value=new byte[]{(byte)(i + 50)};
    store.put(key,Versioned.value(value));
    expectedValues.put(key,value);
  }
  Map<ByteArray,List<Versioned<byte[]>>> all=store.getAll(expectedValues.keySet());
  assertEquals(expectedValues.size(),all.size());
  for (  Map.Entry<ByteArray,List<Versioned<byte[]>>> mapEntry : all.entrySet()) {
    byte[] value=expectedValues.get(mapEntry.getKey());
    assertEquals(new ByteArray(value),new ByteArray(mapEntry.getValue().get(0).getValue()));
  }
}
