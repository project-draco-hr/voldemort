{
  this.baseDir=directory;
  if (!Utils.isReadableDir(directory))   throw new VoldemortException(directory.getAbsolutePath() + " is not a readable directory.");
  this.numBuffersPerChunk=numBuffersPerChunk;
  this.bufferWaitTimeoutMs=bufferWaitTimeoutMs;
  this.indexFileSizes=new ArrayList<Integer>();
  this.dataFileSizes=new ArrayList<Integer>();
  this.indexFiles=new ArrayList<BlockingQueue<MappedByteBuffer>>();
  this.dataFiles=new ArrayList<BlockingQueue<MappedByteBuffer>>();
  if (baseDir.list() != null && baseDir.list().length == 0) {
    try {
      new File(baseDir,"0.index").createNewFile();
      new File(baseDir,"0.data").createNewFile();
    }
 catch (    IOException e) {
      throw new VoldemortException("Error creating empty read-only files.",e);
    }
  }
  int chunkId=0;
  while (true) {
    File index=new File(baseDir,Integer.toString(chunkId) + ".index");
    File data=new File(baseDir,Integer.toString(chunkId) + ".data");
    if (!index.exists() && !data.exists())     break;
 else     if (index.exists() ^ data.exists())     throw new VoldemortException("One of the following does not exist: " + index.toString() + " and "+ data.toString()+ ".");
    long indexLength=index.length();
    long dataLength=data.length();
    validateFileSizes(indexLength,dataLength);
    indexFileSizes.add((int)indexLength);
    dataFileSizes.add((int)dataLength);
    BlockingQueue<MappedByteBuffer> indexFds=new ArrayBlockingQueue<MappedByteBuffer>(numBuffersPerChunk);
    BlockingQueue<MappedByteBuffer> dataFds=new ArrayBlockingQueue<MappedByteBuffer>(numBuffersPerChunk);
    for (int i=0; i < numBuffersPerChunk; i++) {
      indexFds.add(mapFile(index));
      dataFds.add(mapFile(data));
    }
    indexFiles.add(indexFds);
    dataFiles.add(dataFds);
    chunkId++;
  }
  if (chunkId == 0)   throw new VoldemortException("No data chunks found in directory " + baseDir.toString());
  this.numChunks=chunkId;
}
