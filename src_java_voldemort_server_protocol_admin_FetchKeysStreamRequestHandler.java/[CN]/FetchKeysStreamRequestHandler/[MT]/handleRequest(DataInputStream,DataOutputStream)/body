{
  if (!keyIterator.hasNext())   return StreamRequestHandlerState.COMPLETE;
  long startNs=System.nanoTime();
  ByteArray key=keyIterator.next();
  if (streamStats != null) {
    streamStats.reportStorageTime(operation,System.nanoTime() - startNs);
    streamStats.reportStreamingScan(operation);
  }
  throttler.maybeThrottle(key.length());
  boolean keyAccepted=false;
  if (!fetchOrphaned) {
    if (StoreInstance.checkKeyBelongsToPartition(nodeId,key.get(),replicaToPartitionList,initialCluster,storeDef) && filter.accept(key,null) && counter % skipRecords == 0) {
      keyAccepted=true;
    }
  }
 else {
    if (!StoreInstance.checkKeyBelongsToNode(key.get(),nodeId,initialCluster,storeDef)) {
      keyAccepted=true;
    }
  }
  if (keyAccepted) {
    VAdminProto.FetchPartitionEntriesResponse.Builder response=VAdminProto.FetchPartitionEntriesResponse.newBuilder();
    response.setKey(ProtoUtils.encodeBytes(key));
    fetched++;
    if (streamStats != null)     streamStats.reportStreamingFetch(operation);
    Message message=response.build();
    startNs=System.nanoTime();
    ProtoUtils.writeMessage(outputStream,message);
    if (streamStats != null)     streamStats.reportNetworkTime(operation,System.nanoTime() - startNs);
  }
  counter++;
  if (0 == counter % STAT_RECORDS_INTERVAL) {
    long totalTime=(System.currentTimeMillis() - startTime) / 1000;
    logger.info("Fetch keys scanned " + counter + " keys, fetched "+ fetched+ " keys for store '"+ storageEngine.getName()+ "' replicaToPartitionList:"+ replicaToPartitionList+ " in "+ totalTime+ " s");
  }
  if (keyIterator.hasNext())   return StreamRequestHandlerState.WRITING;
 else {
    return StreamRequestHandlerState.COMPLETE;
  }
}
