{
  if (!isServerNormal()) {
    logger.error("Cannot run repair job since Voldemort server is not in normal state");
    return;
  }
  isRunning.set(true);
  ClosableIterator<ByteArray> iterator=null;
  Date startTime=new Date();
  logger.info("Starting VersionedPutPruneJob at " + startTime);
  if (!acquireScanPermit()) {
    isRunning.set(false);
    return;
  }
  try {
    StoreDefinition storeDef=StoreDefinitionUtils.getStoreDefinitionWithName(metadataStore.getStoreDefList(),storeName);
    if (storeDef == null) {
      throw new VoldemortException("Unknown store " + storeName);
    }
    if (isWritableStore(storeDef)) {
      StoreRoutingPlan routingPlan=new StoreRoutingPlan(metadataStore.getCluster(),storeDef);
      logger.info("Pruning store " + storeDef.getName());
      StorageEngine<ByteArray,byte[],byte[]> engine=storeRepo.getStorageEngine(storeDef.getName());
      iterator=engine.keys();
      long itemsScanned=0;
      long numPrunedKeys=0;
      while (iterator.hasNext()) {
        ByteArray key=iterator.next();
        KeyLockHandle<byte[]> lockHandle=engine.getAndLock(key);
        List<Versioned<byte[]>> vals=lockHandle.getValues();
        List<Integer> keyReplicas=routingPlan.getReplicationNodeList(routingPlan.getMasterPartitionId(key.get()));
        MutableBoolean didPrune=new MutableBoolean(false);
        List<Versioned<byte[]>> prunedVals=pruneNonReplicaEntries(vals,keyReplicas,didPrune);
        if (didPrune.booleanValue()) {
          List<Versioned<byte[]>> resolvedVals=VectorClockUtils.resolveVersions(prunedVals);
          lockHandle.setValues(resolvedVals);
          engine.putAndUnlock(key,lockHandle);
          numPrunedKeys=this.numKeysUpdatedThisRun.incrementAndGet();
        }
        itemsScanned=this.numKeysScannedThisRun.incrementAndGet();
        if (itemsScanned % STAT_RECORDS_INTERVAL == 0)         logger.info("#Scanned:" + itemsScanned + " #Pruned:"+ numPrunedKeys);
      }
      closeIterator(iterator);
      logger.info("Completed store " + storeDef.getName() + " #Scanned:"+ itemsScanned+ " #Pruned:"+ numPrunedKeys);
    }
  }
 catch (  Exception e) {
    logger.error("Error running Prune Job..",e);
  }
 finally {
    closeIterator(iterator);
    this.scanPermits.release(this.getClass().getCanonicalName());
    resetStats();
    logger.info("Completed prune job started at " + startTime);
    isRunning.set(false);
  }
}
