{
  logger.info("Starting testServerSideRouting");
  try {
    final Cluster currentCluster=ServerTestUtils.getLocalCluster(2,new int[][]{{0,1,2,3,4,5,6},{7,8}});
    final Cluster targetCluster=RebalanceUtils.createUpdatedCluster(currentCluster,1,Lists.newArrayList(2,3));
    final List<Integer> serverList=Arrays.asList(0,1);
    Map<String,String> configProps=new HashMap<String,String>();
    configProps.put("admin.max.threads","50");
    final Cluster updatedCurrentCluster=startServers(currentCluster,storeDefFileWithReplication,serverList,configProps);
    final Cluster updatedTargetCluster=updateCluster(targetCluster);
    ExecutorService executors=Executors.newFixedThreadPool(2);
    final AtomicBoolean rebalancingToken=new AtomicBoolean(false);
    final List<Exception> exceptions=Collections.synchronizedList(new ArrayList<Exception>());
    String bootstrapUrl=getBootstrapUrl(updatedCurrentCluster,0);
    int maxParallel=2;
    int maxTries=RebalanceController.MAX_TRIES_REBALANCING;
    long timeout=RebalanceController.REBALANCING_CLIENT_TIMEOUT_SEC;
    boolean stealerBased=!useDonorBased;
    final RebalanceController rebalanceClient=new RebalanceController(bootstrapUrl,maxParallel,maxTries,timeout,stealerBased);
    int batchSize=RebalancePlan.PRIMARY_PARTITION_BATCH_SIZE;
    final RebalancePlan rebalancePlan=rebalanceClient.getPlan(updatedTargetCluster,batchSize);
    populateData(updatedCurrentCluster,roStoreDefWithReplication,rebalanceClient.getAdminClient(),true);
    populateData(updatedCurrentCluster,rwStoreDefWithReplication,rebalanceClient.getAdminClient(),false);
    Node node=updatedCurrentCluster.getNodeById(1);
    final Store<ByteArray,byte[],byte[]> serverSideRoutingStoreRW=getSocketStore(testStoreNameRW,node.getHost(),node.getSocketPort(),true);
    final Store<ByteArray,byte[],byte[]> serverSideRoutingStoreRO=getSocketStore(testStoreNameRO,node.getHost(),node.getSocketPort(),true);
    final CountDownLatch latch=new CountDownLatch(1);
    executors.execute(new Runnable(){
      @Override public void run(){
        try {
          List<String> keys=new ArrayList<String>(testEntries.keySet());
          while (!rebalancingToken.get()) {
            int index=(int)(Math.random() * keys.size());
            try {
              List<Versioned<byte[]>> values=serverSideRoutingStoreRW.get(new ByteArray(ByteUtils.getBytes(keys.get(index),"UTF-8")),null);
              assertEquals("serverSideRoutingStore should return value.",1,values.size());
              assertEquals("Value returned should be good",new Versioned<String>(testEntries.get(keys.get(index))),new Versioned<String>(ByteUtils.getString(values.get(0).getValue(),"UTF-8"),values.get(0).getVersion()));
              values=serverSideRoutingStoreRO.get(new ByteArray(ByteUtils.getBytes(keys.get(index),"UTF-8")),null);
              assertEquals("serverSideRoutingStore should return value.",1,values.size());
              assertEquals("Value returned should be good",new Versioned<String>(testEntries.get(keys.get(index))),new Versioned<String>(ByteUtils.getString(values.get(0).getValue(),"UTF-8"),values.get(0).getVersion()));
            }
 catch (            UnreachableStoreException e) {
            }
catch (            Exception e) {
              exceptions.add(e);
            }
          }
          latch.countDown();
        }
 catch (        Exception e) {
          exceptions.add(e);
        }
      }
    }
);
    executors.execute(new Runnable(){
      @Override public void run(){
        try {
          Thread.sleep(500);
          rebalanceAndCheck(rebalancePlan,rebalanceClient,Arrays.asList(0,1));
          Thread.sleep(500);
          rebalancingToken.set(true);
          checkConsistentMetadata(targetCluster,serverList);
        }
 catch (        Exception e) {
          exceptions.add(e);
        }
 finally {
          try {
            latch.await(300,TimeUnit.SECONDS);
            stopServer(serverList);
          }
 catch (          Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
);
    executors.shutdown();
    executors.awaitTermination(300,TimeUnit.SECONDS);
    if (exceptions.size() > 0) {
      for (      Exception e : exceptions) {
        e.printStackTrace();
      }
      fail("Should not see any exceptions !!");
    }
  }
 catch (  AssertionError ae) {
    logger.error("Assertion broken in testServerSideRouting ",ae);
    throw ae;
  }
}
