{
  JobConf conf=new JobConf(config);
  conf.setInt("io.file.buffer.size",DEFAULT_BUFFER_SIZE);
  conf.set("cluster.xml",new ClusterMapper().writeCluster(cluster));
  conf.set("stores.xml",new StoreDefinitionsMapper().writeStoreList(Collections.singletonList(storeDef)));
  conf.setBoolean("save.keys",saveKeys);
  conf.setPartitionerClass(HadoopStoreBuilderPartitioner.class);
  conf.setMapperClass(mapperClass);
  conf.setMapOutputKeyClass(BytesWritable.class);
  conf.setMapOutputValueClass(BytesWritable.class);
  conf.setReducerClass(HadoopStoreBuilderReducer.class);
  conf.setInputFormat(inputFormatClass);
  conf.setOutputFormat(SequenceFileOutputFormat.class);
  conf.setOutputKeyClass(BytesWritable.class);
  conf.setOutputValueClass(BytesWritable.class);
  conf.setJarByClass(getClass());
  FileInputFormat.setInputPaths(conf,inputPath);
  conf.set("final.output.dir",outputDir.toString());
  conf.set("checksum.type",CheckSum.toString(checkSumType));
  FileOutputFormat.setOutputPath(conf,tempDir);
  try {
    FileSystem outputFs=outputDir.getFileSystem(conf);
    if (outputFs.exists(outputDir)) {
      throw new IOException("Final output directory already exists.");
    }
    FileSystem tempFs=tempDir.getFileSystem(conf);
    tempFs.delete(tempDir,true);
    long size=sizeOfPath(tempFs,inputPath);
    int numChunksPerPartition=Math.max((int)(storeDef.getReplicationFactor() * size / cluster.getNumberOfPartitions() / chunkSizeBytes),1);
    logger.info("Data size = " + size + ", replication factor = "+ storeDef.getReplicationFactor()+ ", numNodes = "+ cluster.getNumberOfNodes()+ ", chunk size = "+ chunkSizeBytes+ ",  num.chunks per partition = "+ numChunksPerPartition);
    conf.setInt("num.chunks",numChunksPerPartition);
    int numReduces=cluster.getNumberOfPartitions() * numChunksPerPartition;
    conf.setNumReduceTasks(numReduces);
    logger.info("Number of reduces: " + numReduces);
    logger.info("Building store...");
    JobClient.runJob(conf);
    CheckSum checkSumGenerator=CheckSum.getInstance(this.checkSumType);
    if (!this.checkSumType.equals(CheckSumType.NONE) && checkSumGenerator == null) {
      throw new VoldemortException("Could not generate checksum digest for type " + this.checkSumType);
    }
    for (    Node node : cluster.getNodes()) {
      ReadOnlyStorageMetadata metadata=new ReadOnlyStorageMetadata();
      if (saveKeys)       metadata.add(ReadOnlyStorageMetadata.FORMAT,ReadOnlyStorageFormat.READONLY_V2.getCode());
 else       metadata.add(ReadOnlyStorageMetadata.FORMAT,ReadOnlyStorageFormat.READONLY_V1.getCode());
      Path nodePath=new Path(outputDir.toString(),"node-" + node.getId());
      if (!outputFs.exists(nodePath)) {
        outputFs.mkdirs(nodePath);
      }
      if (checkSumType != CheckSumType.NONE) {
        FileStatus[] storeFiles=outputFs.listStatus(nodePath,new PathFilter(){
          public boolean accept(          Path arg0){
            if (arg0.getName().endsWith("checksum") && !arg0.getName().startsWith(".")) {
              return true;
            }
            return false;
          }
        }
);
        if (storeFiles != null && storeFiles.length > 0) {
          Arrays.sort(storeFiles,new IndexFileLastComparator());
          for (          FileStatus file : storeFiles) {
            FSDataInputStream input=outputFs.open(file.getPath());
            byte fileCheckSum[]=new byte[CheckSum.checkSumLength(this.checkSumType)];
            input.read(fileCheckSum);
            checkSumGenerator.update(fileCheckSum);
            outputFs.delete(file.getPath(),true);
          }
          metadata.add(ReadOnlyStorageMetadata.CHECKSUM_TYPE,CheckSum.toString(checkSumType));
          metadata.add(ReadOnlyStorageMetadata.CHECKSUM,new String(Hex.encodeHex(checkSumGenerator.getCheckSum())));
        }
      }
      FSDataOutputStream metadataStream=outputFs.create(new Path(nodePath,".metadata"));
      metadataStream.write(metadata.toJsonString().getBytes());
      metadataStream.flush();
      metadataStream.close();
    }
  }
 catch (  Exception e) {
    logger.error("Error in Store builder",e);
    throw new VoldemortException(e);
  }
}
