{
  int currentNode=0;
  List<Node> nodes=pipelineData.getNodes();
  if (logger.isDebugEnabled())   logger.debug("Performing serial put requests to determine master");
  for (; currentNode < nodes.size(); currentNode++) {
    Node node=nodes.get(currentNode);
    long startNs=System.nanoTime();
    try {
      VectorClock versionedClock=(VectorClock)versioned.getVersion();
      Versioned<byte[]> versionedCopy=new Versioned<byte[]>(versioned.getValue(),versionedClock.incremented(node.getId(),time.getMilliseconds()));
      if (logger.isTraceEnabled())       logger.trace("Attempt # " + (currentNode + 1) + " to perform put (node "+ node.getId()+ ")");
      final CountDownLatch latch=new CountDownLatch(1);
      PutCallback callback=new PutCallback(latch);
      NonblockingStore store=nonblockingStores.get(node.getId());
      store.submitPutRequest(key,versionedCopy,callback);
      boolean successful=false;
      try {
        successful=latch.await(timeoutMs,TimeUnit.MILLISECONDS);
      }
 catch (      InterruptedException e) {
        if (logger.isEnabledFor(Level.WARN))         logger.warn(e,e);
      }
      if (!successful) {
        List<Exception> failures=pipelineData.getFailures();
        pipelineData.setFatalError(new InsufficientOperationalNodesException("No master node succeeded!",failures.size() > 0 ? failures.get(0) : null));
        pipeline.addEvent(Event.ERROR);
        return;
      }
      if (callback.result instanceof Exception)       throw (Exception)callback.result;
      pipelineData.incrementSuccesses();
      long requestTime=(System.nanoTime() - startNs) / Time.NS_PER_MS;
      failureDetector.recordSuccess(node,requestTime);
      if (logger.isTraceEnabled())       logger.trace("Put on node " + node.getId() + " succeeded, using as master");
      pipelineData.setMaster(node);
      pipelineData.setVersionedCopy(versionedCopy);
      break;
    }
 catch (    UnreachableStoreException e) {
      if (logger.isTraceEnabled())       logger.trace("Put on node " + node.getId() + " failed: "+ e);
      pipelineData.recordFailure(e);
      long requestTime=(System.nanoTime() - startNs) / Time.NS_PER_MS;
      failureDetector.recordException(node,requestTime,e);
    }
catch (    VoldemortApplicationException e) {
      pipelineData.setFatalError(e);
      pipeline.addEvent(Event.ERROR);
      return;
    }
catch (    Exception e) {
      if (logger.isTraceEnabled())       logger.trace("Put on node " + node.getId() + " failed: "+ e);
      pipelineData.recordFailure(e);
    }
  }
  if (pipelineData.getSuccesses() < 1) {
    List<Exception> failures=pipelineData.getFailures();
    pipelineData.setFatalError(new InsufficientOperationalNodesException("No master node succeeded!",failures.size() > 0 ? failures.get(0) : null));
    pipeline.addEvent(Event.ERROR);
    return;
  }
  currentNode++;
  if (currentNode == nodes.size()) {
    if (pipelineData.getSuccesses() < required) {
      pipelineData.setFatalError(new InsufficientOperationalNodesException(required + " " + pipeline.getOperation().getSimpleName()+ "s required, but "+ pipelineData.getSuccesses()+ " succeeded",pipelineData.getFailures()));
      pipeline.addEvent(Event.ERROR);
    }
 else {
      pipeline.addEvent(completeEvent);
    }
  }
 else {
    pipeline.addEvent(masterDeterminedEvent);
  }
}
