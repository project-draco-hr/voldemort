{
  acquireCleanupPermit(progressThisRun);
  ClosableIterator<Pair<K,Versioned<V>>> iterator=null;
  try {
    logger.info("Starting data cleanup on store \"" + store.getName() + "\"...");
    int deleted=0;
    long now=time.getMilliseconds();
    iterator=store.entries();
    while (iterator.hasNext()) {
      if (Thread.currentThread().isInterrupted()) {
        logger.info("Datacleanup job halted.");
        return;
      }
      progressThisRun.incrementAndGet();
      Pair<K,Versioned<V>> keyAndVal=iterator.next();
      VectorClock clock=(VectorClock)keyAndVal.getSecond().getVersion();
      if (now - clock.getTimestamp() > maxAgeMs) {
        store.delete(keyAndVal.getFirst(),clock);
        deleted++;
        if (deleted % 10000 == 0)         logger.debug("Deleted item " + deleted);
      }
      throttler.maybeThrottle(1);
    }
    logger.info("Data cleanup on store \"" + store.getName() + "\" is complete; "+ deleted+ " items deleted. "+ progressThisRun.get()+ " items scanned");
  }
 catch (  Exception e) {
    logger.error("Error in data cleanup job for store " + store.getName() + ": ",e);
  }
 finally {
    closeIterator(iterator);
    logger.info("Releasing lock  after data cleanup on \"" + store.getName() + "\".");
    this.cleanupPermits.release();
synchronized (this) {
      totalEntriesScanned+=progressThisRun.get();
      progressThisRun.set(0);
    }
  }
}
